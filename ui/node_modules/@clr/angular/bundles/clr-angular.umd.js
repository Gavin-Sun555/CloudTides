(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),require('@angular/forms'),require('rxjs'),exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@angular/animations'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@clr/angular', ['@angular/core','@angular/common','@angular/forms','rxjs','exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators', '@angular/animations', '@angular/forms'], factory) :
    (global = global || self, factory(global.ng.core,global.ng.common,global.ng.forms,global.rxjs,(global.clr = global.clr || {}, global.clr.angular = {}), global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators, global.ng.animations, global.ng.forms));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,ɵngcc3,exports, core, common, rxjs, operators, animations, forms) { 
var _c0 = ["buttonProjectedRef"];
function ClrButton_ng_template_0_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 3);
} }
function ClrButton_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵlistener("click", function ClrButton_ng_template_0_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.emitClick($event); });
    ɵngcc0.ɵɵtemplate(1, ClrButton_ng_template_0_span_1_Template, 1, 0, "span", 2);
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r1.classNames);
    ɵngcc0.ɵɵattribute("type", ctx_r1.type)("name", ctx_r1.name)("disabled", ctx_r1.disabled)("id", ctx_r1.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.loading);
} }
var _c1 = ["*"];
function ClrButtonGroup_ng_container_0_ng_template_1_Template(rf, ctx) { }
function ClrButtonGroup_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrButtonGroup_ng_container_0_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var inlineButton_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", inlineButton_r4.templateRef);
} }
function ClrButtonGroup_ng_container_1_div_5_ng_template_1_Template(rf, ctx) { }
function ClrButtonGroup_ng_container_1_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtemplate(1, ClrButtonGroup_ng_container_1_div_5_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    var _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵproperty("id", ctx_r7.popoverId);
    ɵngcc0.ɵɵattribute("id", ctx_r7.popoverId)("aria-hidden", !ctx_r7.open);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function ClrButtonGroup_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 4, 5);
    ɵngcc0.ɵɵelementStart(3, "button", 6);
    ɵngcc0.ɵɵelement(4, "clr-icon", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, ClrButtonGroup_ng_container_1_div_5_Template, 2, 4, "div", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.menuPosition);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r1.popoverId)("aria-expanded", ctx_r1.open)("aria-label", ctx_r1.commonStrings.keys.rowActions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("title", ctx_r1.commonStrings.keys.more);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("clrPopoverContent", ctx_r1.open)("clrPopoverContentAt", ctx_r1.popoverPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
} }
function ClrButtonGroup_ng_template_2_ng_container_0_ng_template_1_Template(rf, ctx) { }
function ClrButtonGroup_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrButtonGroup_ng_template_2_ng_container_0_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var menuButton_r10 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", menuButton_r10.templateRef);
} }
function ClrButtonGroup_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ClrButtonGroup_ng_template_2_ng_container_0_Template, 2, 1, "ng-container", 0);
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.menuButtons);
} }
var _c2 = ["clrLoading", ""];
function ClrLoadingButton_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵelement(1, "span", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@spinner", undefined);
} }
function ClrLoadingButton_span_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵelementStart(1, "span", 3);
    ɵngcc0.ɵɵlistener("@validated.done", function ClrLoadingButton_span_2_Template_span_animation_validated_done_1_listener() { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.loadingStateChange(ctx_r3.buttonState.DEFAULT); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@validated", undefined);
} }
function ClrLoadingButton_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("@defaultButton", undefined);
} }
function ClrControlContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrControlContainer_clr_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 4);
} }
function ClrControlContainer_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrControlContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c3 = [[["label"]], "*", [["clr-control-helper"]], [["clr-control-error"]]];
var _c4 = ["label", "*", "clr-control-helper", "clr-control-error"];
function ClrCheckboxWrapper_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
var _c5 = [[["", "clrCheckbox", ""], ["", "clrToggle", ""]], [["label"]]];
var _c6 = ["[clrCheckbox],[clrToggle]", "label"];
function ClrCheckboxContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrCheckboxContainer_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrCheckboxContainer_clr_icon_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 4);
} }
function ClrCheckboxContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c7 = [[["label"]], [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c8 = ["label", "clr-checkbox-wrapper,clr-toggle-wrapper", "clr-control-helper", "clr-control-error"];
function ClrCalendar_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var day_r2 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("aria-label", day_r2.day);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", day_r2.narrow, " ");
} }
function ClrCalendar_tr_3_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 7);
    ɵngcc0.ɵɵelement(1, "clr-day", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var dayView_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("clrDayView", dayView_r5);
} }
function ClrCalendar_tr_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 5);
    ɵngcc0.ɵɵtemplate(1, ClrCalendar_tr_3_td_1_Template, 2, 1, "td", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var row_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", row_r3);
} }
var _c9 = ["actionButton"];
function ClrDateContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrDateContainer_button_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 7, 8);
    ɵngcc0.ɵɵelement(2, "clr-icon", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r1.isInputDateDisabled);
    ɵngcc0.ɵɵattribute("title", ctx_r1.commonStrings.keys.datepickerToggle)("aria-label", ctx_r1.commonStrings.keys.datepickerToggle);
} }
function ClrDateContainer_clr_datepicker_view_manager_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-datepicker-view-manager", 10);
} }
function ClrDateContainer_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrDateContainer_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c10 = [[["label"]], [["", "clrDate", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c11 = ["label", "[clrDate]", "clr-control-helper", "clr-control-error"];
function ClrDatepickerViewManager_clr_monthpicker_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-monthpicker");
} }
function ClrDatepickerViewManager_clr_yearpicker_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-yearpicker");
} }
function ClrDatepickerViewManager_clr_daypicker_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-daypicker");
} }
function ClrMonthpicker_button_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵlistener("click", function ClrMonthpicker_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var monthIndex_r2 = ctx.index; var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.changeMonth(monthIndex_r2); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var month_r1 = ctx.$implicit;
    var monthIndex_r2 = ctx.index;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("is-selected", monthIndex_r2 === ctx_r0.calendarMonthIndex);
    ɵngcc0.ɵɵattribute("tabindex", ctx_r0.getTabIndex(monthIndex_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", month_r1, " ");
} }
function ClrYearpicker_button_8_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7);
    ɵngcc0.ɵɵlistener("click", function ClrYearpicker_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var year_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.changeYear(year_r1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var year_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("is-selected", year_r1 === ctx_r0.calendarYear);
    ɵngcc0.ɵɵattribute("tabindex", ctx_r0.getTabIndex(year_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", year_r1, " ");
} }
function ClrInputContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrInputContainer_clr_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 4);
} }
function ClrInputContainer_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrInputContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c12 = [[["label"]], [["", "clrInput", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c13 = ["label", "[clrInput]", "clr-control-helper", "clr-control-error"];
function ClrPasswordContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrPasswordContainer_button_6_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 6);
    ɵngcc0.ɵɵlistener("click", function ClrPasswordContainer_button_6_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.toggle(); });
    ɵngcc0.ɵɵelement(1, "clr-icon");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r1.control == null ? null : ctx_r1.control.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("shape", ctx_r1.show ? "eye-hide" : "eye")("title", ctx_r1.show ? ctx_r1.commonStrings.keys.hide : ctx_r1.commonStrings.keys.show);
} }
function ClrPasswordContainer_clr_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 7);
} }
function ClrPasswordContainer_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrPasswordContainer_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c14 = [[["label"]], [["", "clrPassword", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c15 = ["label", "[clrPassword]", "clr-control-helper", "clr-control-error"];
function ClrRadioWrapper_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
var _c16 = [[["", "clrRadio", ""]], [["label"]]];
var _c17 = ["[clrRadio]", "label"];
function ClrRadioContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrRadioContainer_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrRadioContainer_clr_icon_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 4);
} }
function ClrRadioContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c18 = [[["label"]], [["clr-radio-wrapper"]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c19 = ["label", "clr-radio-wrapper", "clr-control-helper", "clr-control-error"];
function ClrSelectContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrSelectContainer_clr_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 4);
} }
function ClrSelectContainer_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrSelectContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c20 = [[["label"]], [["", "clrSelect", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c21 = ["label", "[clrSelect]", "clr-control-helper", "clr-control-error"];
function ClrTextareaContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrTextareaContainer_clr_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 4);
} }
function ClrTextareaContainer_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrTextareaContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c22 = [[["label"]], [["", "clrTextarea", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c23 = ["label", "[clrTextarea]", "clr-control-helper", "clr-control-error"];
function ClrRangeContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrRangeContainer_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 5);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r1.getRangeProgressFillWidth());
} }
function ClrRangeContainer_clr_icon_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 6);
} }
function ClrRangeContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrRangeContainer_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
var _c24 = [[["label"]], [["", "clrRange", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c25 = ["label", "[clrRange]", "clr-control-helper", "clr-control-error"];
function ClrDatalistContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrDatalistContainer_clr_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 5);
} }
function ClrDatalistContainer_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "!invalid"]);
} }
function ClrDatalistContainer_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 4, ["*ngIf", "invalid"]);
} }
var _c26 = [[["label"]], [["", "clrDatalistInput", ""]], [["datalist"]], [["clr-control-helper"]], [["clr-control-error"]]];
var _c27 = ["label", "[clrDatalistInput]", "datalist", "clr-control-helper", "clr-control-error"];
var _c28 = ["anchor"];
function ClrDatagridFilter_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "div", 5);
    ɵngcc0.ɵɵelementStart(2, "button", 6);
    ɵngcc0.ɵɵelement(3, "clr-icon", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.popoverId);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵattribute("title", ctx_r1.commonStrings.keys.close);
} }
var _c29 = ["input"];
var _c30 = ["input_low"];
var _c31 = ["columnPortal"];
function WrappedColumn_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function ClrDatagridColumn_button_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function ClrDatagridColumn_button_1_clr_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 10);
} if (rf & 2) {
    var ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("shape", ctx_r8.sortIcon);
} }
function ClrDatagridColumn_button_1_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridColumn_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.sort(); });
    ɵngcc0.ɵɵtemplate(1, ClrDatagridColumn_button_1_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, ClrDatagridColumn_button_1_clr_icon_2_Template, 1, 1, "clr-icon", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    var _r3 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.sortIcon);
} }
function ClrDatagridColumn_clr_dg_string_filter_3_Template(rf, ctx) { if (rf & 1) {
    var _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "clr-dg-string-filter", 11);
    ɵngcc0.ɵɵlistener("clrFilterValueChange", function ClrDatagridColumn_clr_dg_string_filter_3_Template_clr_dg_string_filter_clrFilterValueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.filterValue = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("clrDgStringFilter", ctx_r1.registered)("clrFilterValue", ctx_r1.filterValue);
} }
function ClrDatagridColumn_clr_dg_numeric_filter_4_Template(rf, ctx) { if (rf & 1) {
    var _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "clr-dg-numeric-filter", 12);
    ɵngcc0.ɵɵlistener("clrFilterValueChange", function ClrDatagridColumn_clr_dg_numeric_filter_4_Template_clr_dg_numeric_filter_clrFilterValueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.filterValue = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("clrDgNumericFilter", ctx_r2.registered)("clrFilterValue", ctx_r2.filterValue);
} }
function ClrDatagridColumn_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function ClrDatagridColumn_span_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function ClrDatagridColumn_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 13);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridColumn_span_7_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    var _r3 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function ClrDatagridColumn_clr_dg_column_separator_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-dg-column-separator");
} }
var _c32 = [[["clr-dg-filter"], ["clr-dg-string-filter"], ["clr-dg-numeric-filter"]], "*"];
var _c33 = ["clr-dg-filter, clr-dg-string-filter, clr-dg-numeric-filter", "*"];
function ClrDatagridPlaceholder_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 3);
} }
function ClrDatagridPlaceholder_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "emptyDatagrid"]);
} }
function ClrSignpost_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 1);
    ɵngcc0.ɵɵelement(2, "clr-icon", 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("title", ctx_r0.commonStrings.keys.info);
} }
var _c34 = ["cellPortal"];
function WrappedCell_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
var _c35 = ["rowPortal"];
function WrappedRow_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
var _c36 = ["detailButton"];
var _c37 = ["stickyCells"];
var _c38 = ["scrollableCells"];
var _c39 = ["calculatedCells"];
function ClrDatagridRow_label_0_clr_expandable_animation_1_ng_template_1_Template(rf, ctx) { }
function ClrDatagridRow_label_0_clr_expandable_animation_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "clr-expandable-animation", 7);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridRow_label_0_clr_expandable_animation_1_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    var _r5 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("clrExpandTrigger", ctx_r8.expandAnimationTrigger);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5);
} }
function ClrDatagridRow_label_0_2_ng_template_0_Template(rf, ctx) { }
function ClrDatagridRow_label_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ClrDatagridRow_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    var _r5 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5);
} }
function ClrDatagridRow_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 6);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridRow_label_0_clr_expandable_animation_1_Template, 2, 2, "clr-expandable-animation", 1);
    ɵngcc0.ɵɵtemplate(2, ClrDatagridRow_label_0_2_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.expand.expandable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.expand.expandable);
} }
function ClrDatagridRow_clr_expandable_animation_1_ng_template_1_Template(rf, ctx) { }
function ClrDatagridRow_clr_expandable_animation_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "clr-expandable-animation", 7);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridRow_clr_expandable_animation_1_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    var _r5 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("clrExpandTrigger", ctx_r1.expandAnimationTrigger);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5);
} }
function ClrDatagridRow_2_ng_template_0_Template(rf, ctx) { }
function ClrDatagridRow_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ClrDatagridRow_2_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    var _r5 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5);
} }
function ClrDatagridRow_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
var _c40 = function (a0) { return { "clr-form-control-disabled": a0 }; };
function ClrDatagridRow_ng_template_5_div_4_Template(rf, ctx) { if (rf & 1) {
    var _r24 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵelementStart(1, "input", 20);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrDatagridRow_ng_template_5_div_4_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); var ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.toggle($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c40, !ctx_r15.clrDgSelectable));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r15.selected)("id", ctx_r15.checkboxId);
    ɵngcc0.ɵɵattribute("disabled", ctx_r15.clrDgSelectable ? null : true)("aria-disabled", ctx_r15.clrDgSelectable ? null : true)("aria-label", ctx_r15.commonStrings.keys.select);
} }
function ClrDatagridRow_ng_template_5_div_5_Template(rf, ctx) { if (rf & 1) {
    var _r26 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵelementStart(1, "input", 21);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrDatagridRow_ng_template_5_div_5_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); var ctx_r25 = ɵngcc0.ɵɵnextContext(2); return ctx_r25.selection.currentSingle = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(9, _c40, !ctx_r16.clrDgSelectable));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r16.radioId)("name", ctx_r16.selection.id + "-radio")("value", ctx_r16.item)("ngModel", ctx_r16.selection.currentSingle)("checked", ctx_r16.selection.currentSingle === ctx_r16.item);
    ɵngcc0.ɵɵattribute("disabled", ctx_r16.clrDgSelectable ? null : true)("aria-disabled", ctx_r16.clrDgSelectable ? null : true)("aria-label", ctx_r16.commonStrings.keys.select);
} }
function ClrDatagridRow_ng_template_5_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 22);
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementEnd();
} }
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template(rf, ctx) { if (rf & 1) {
    var _r31 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 26);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r31); var ctx_r30 = ɵngcc0.ɵɵnextContext(4); return ctx_r30.toggleExpand(); });
    ɵngcc0.ɵɵelement(1, "clr-icon", 27);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r28 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵattribute("aria-expanded", ctx_r28.expand.expanded)("aria-label", ctx_r28.expand.expanded ? ctx_r28.clrDgDetailCloseLabel : ctx_r28.clrDgDetailOpenLabel)("aria-controls", ctx_r28.expandableId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dir", ctx_r28.expand.expanded ? "down" : "right")("title", ctx_r28.expand.expanded ? ctx_r28.commonStrings.keys.collapse : ctx_r28.commonStrings.keys.expand);
} }
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_clr_spinner_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "clr-spinner", 28);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r29 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r29.commonStrings.keys.loading);
} }
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template, 2, 5, "button", 24);
    ɵngcc0.ɵɵtemplate(2, ClrDatagridRow_ng_template_5_div_7_ng_container_1_clr_spinner_2_Template, 2, 1, "clr-spinner", 25);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r27 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r27.expand.loading);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r27.expand.loading);
} }
function ClrDatagridRow_ng_template_5_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_7_ng_container_1_Template, 3, 2, "ng-container", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r18.expand.expandable);
} }
function ClrDatagridRow_ng_template_5_div_8_Template(rf, ctx) { if (rf & 1) {
    var _r34 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 29);
    ɵngcc0.ɵɵelementStart(1, "button", 30, 31);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_8_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r34); var _r32 = ɵngcc0.ɵɵreference(2); var ctx_r33 = ɵngcc0.ɵɵnextContext(2); return ctx_r33.detailService.toggle(ctx_r33.item, _r32); });
    ɵngcc0.ɵɵelement(3, "clr-icon", 32);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("is-open", ctx_r19.detailService.isRowOpen(ctx_r19.item));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r19.detailService.isOpen ? ctx_r19.clrDgDetailCloseLabel : ctx_r19.clrDgDetailOpenLabel)("aria-expanded", ctx_r19.detailService.isOpen)("aria-controls", ctx_r19.detailService.id);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("dir", ctx_r19.detailService.isRowOpen(ctx_r19.item) ? "left" : "right")("title", ctx_r19.detailService.isRowOpen(ctx_r19.item) ? ctx_r19.commonStrings.keys.close : ctx_r19.commonStrings.keys.open);
} }
function ClrDatagridRow_ng_template_5_14_ng_template_0_Template(rf, ctx) { }
function ClrDatagridRow_ng_template_5_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ClrDatagridRow_ng_template_5_14_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    var _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function ClrDatagridRow_ng_template_5_15_ng_template_0_Template(rf, ctx) { }
function ClrDatagridRow_ng_template_5_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ClrDatagridRow_ng_template_5_15_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    var _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
var _c41 = function (a0) { return { "is-replaced": a0 }; };
function ClrDatagridRow_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "div", 10);
    ɵngcc0.ɵɵelementContainerStart(2, null, 11);
    ɵngcc0.ɵɵtemplate(4, ClrDatagridRow_ng_template_5_div_4_Template, 2, 8, "div", 12);
    ɵngcc0.ɵɵtemplate(5, ClrDatagridRow_ng_template_5_div_5_Template, 2, 11, "div", 12);
    ɵngcc0.ɵɵtemplate(6, ClrDatagridRow_ng_template_5_div_6_Template, 2, 0, "div", 13);
    ɵngcc0.ɵɵtemplate(7, ClrDatagridRow_ng_template_5_div_7_Template, 2, 1, "div", 14);
    ɵngcc0.ɵɵtemplate(8, ClrDatagridRow_ng_template_5_div_8_Template, 4, 7, "div", 15);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 16);
    ɵngcc0.ɵɵelementStart(10, "div", 17);
    ɵngcc0.ɵɵprojection(11, 1);
    ɵngcc0.ɵɵelementContainer(12, null, 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(14, ClrDatagridRow_ng_template_5_14_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵtemplate(15, ClrDatagridRow_ng_template_5_15_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("datagrid-row-detail-open", ctx_r6.detailService.isRowOpen(ctx_r6.item));
    ɵngcc0.ɵɵproperty("id", ctx_r6.id);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.selection.selectionType === ctx_r6.SELECTION_TYPE.Multi);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.selection.selectionType === ctx_r6.SELECTION_TYPE.Single);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.rowActionService.hasActionableRow);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.globalExpandable.hasExpandableRow);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.detailService.enabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(11, _c41, ctx_r6.replaced && ctx_r6.expanded));
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.replaced && !ctx_r6.expand.loading);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r6.replaced && !ctx_r6.expand.loading);
} }
var _c42 = [[["clr-dg-row-detail"]], [["clr-dg-cell"]], [["clr-dg-action-overflow"]]];
var _c43 = ["clr-dg-row-detail", "clr-dg-cell", "clr-dg-action-overflow"];
var _c44 = ["scrollableColumns"];
var _c45 = ["datagridTable"];
var _c46 = ["projectedDisplayColumns"];
var _c47 = ["projectedCalculationColumns"];
var _c48 = ["displayedRows"];
var _c49 = ["calculationRows"];
function ClrDatagrid_div_12_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵelementStart(1, "span", 24);
    ɵngcc0.ɵɵelementStart(2, "input", 25);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrDatagrid_div_12_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.allSelected = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "div", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r2.allSelected);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.commonStrings.keys.selectAll);
} }
function ClrDatagrid_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵelement(1, "div", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.clrDgSingleSelectionAriaLabel);
} }
function ClrDatagrid_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 27);
    ɵngcc0.ɵɵelement(1, "div", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r4.clrDgSingleActionableAriaLabel);
} }
function ClrDatagrid_div_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 28);
    ɵngcc0.ɵɵelement(1, "div", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r5.clrDetailExpandableAriaLabel);
} }
function ClrDatagrid_clr_dg_placeholder_22_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-dg-placeholder");
} }
function ClrDatagrid_div_24_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 29);
    ɵngcc0.ɵɵelementStart(1, "clr-spinner", 30);
    ɵngcc0.ɵɵtext(2, "Loading");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
var _c50 = [[["clr-dg-action-bar"]], [["clr-dg-placeholder"]], [["clr-dg-footer"]], [["", "clrIfDetail", ""], ["clr-dg-detail"]]];
var _c51 = ["clr-dg-action-bar", "clr-dg-placeholder", "clr-dg-footer", "[clrIfDetail],clr-dg-detail"];
function ClrDatagridActionOverflow_div_3_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridActionOverflow_div_3_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.closeOverflowContent($event); });
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r1.popoverId);
    ɵngcc0.ɵɵattribute("aria-hidden", !ctx_r1.open)("id", ctx_r1.popoverId);
} }
var _c52 = ["menuDescription"];
var _c53 = ["allSelected"];
function ClrDatagridColumnToggle_div_2_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.commonStrings.keys.showColumns);
} }
function ClrDatagridColumnToggle_div_2_li_13_ng_template_4_Template(rf, ctx) { }
function ClrDatagridColumnToggle_div_2_li_13_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "clr-checkbox-wrapper");
    ɵngcc0.ɵɵelementStart(2, "input", 15);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrDatagridColumnToggle_div_2_li_13_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var columnState_r6 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.toggleColumnState(columnState_r6, !$event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "label");
    ɵngcc0.ɵɵtemplate(4, ClrDatagridColumnToggle_div_2_li_13_ng_template_4_Template, 0, 0, "ng-template", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var columnState_r6 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("disabled", ctx_r4.hasOnlyOneVisibleColumn && !columnState_r6.hidden)("ngModel", !columnState_r6.hidden);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", columnState_r6.titleTemplateRef);
} }
function ClrDatagridColumnToggle_div_2_clr_dg_column_toggle_button_16_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "clr-dg-column-toggle-button", 17);
    ɵngcc0.ɵɵlistener("clrAllSelected", function ClrDatagridColumnToggle_div_2_clr_dg_column_toggle_button_16_Template_clr_dg_column_toggle_button_clrAllSelected_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.allColumnsSelected(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.commonStrings.keys.selectAll, " ");
} }
function ClrDatagridColumnToggle_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵelementStart(1, "div", 4);
    ɵngcc0.ɵɵelementStart(2, "div", 5, 6);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 5, 7);
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, ClrDatagridColumnToggle_div_2_ng_container_8_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵprojection(9);
    ɵngcc0.ɵɵelementStart(10, "button", 9);
    ɵngcc0.ɵɵelement(11, "clr-icon", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "ul", 11);
    ɵngcc0.ɵɵtemplate(13, ClrDatagridColumnToggle_div_2_li_13_Template, 5, 3, "li", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(14, "div", 13);
    ɵngcc0.ɵɵprojection(15, 1);
    ɵngcc0.ɵɵtemplate(16, ClrDatagridColumnToggle_div_2_clr_dg_column_toggle_button_16_Template, 2, 1, "clr-dg-column-toggle-button", 14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r0.popoverId);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.commonStrings.keys.showColumnsMenuDescription);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.commonStrings.keys.allColumnsSelected);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.customToggleTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.close);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("title", ctx_r0.commonStrings.keys.close);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.hideableColumnStates)("ngForTrackBy", ctx_r0.trackByFn);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.customToggleButton);
} }
var _c54 = [[["clr-dg-column-toggle-title"]], [["clr-dg-column-toggle-button"]]];
var _c55 = ["clr-dg-column-toggle-title", "clr-dg-column-toggle-button"];
var _c56 = function () { return { strict: false }; };
function ClrDatagridDetail_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(3);
    ɵngcc0.ɵɵelementStart(4, "div", 2);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("clrFocusTrap", ɵngcc0.ɵɵpureFunction0(5, _c56))("id", ctx_r0.detailService.id);
    ɵngcc0.ɵɵattribute("aria-describedby", ctx_r0.header ? ctx_r0.header.titleId : "");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.commonStrings.keys.detailPaneStart);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.commonStrings.keys.detailPaneEnd);
} }
function ClrDatagridFooter_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 1);
    ɵngcc0.ɵɵelementStart(2, "clr-checkbox-wrapper", 2);
    ɵngcc0.ɵɵelement(3, "input", 3);
    ɵngcc0.ɵɵelementStart(4, "label");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.selection.current.length);
} }
function ClrDatagridFooter_ng_container_1_clr_dg_column_toggle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-dg-column-toggle");
} }
function ClrDatagridFooter_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵtemplate(2, ClrDatagridFooter_ng_container_1_clr_dg_column_toggle_2_Template, 1, 0, "clr-dg-column-toggle", 0);
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵprojection(4, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.hasHideableColumns && !ctx_r1.toggle);
} }
var _c57 = [[["clr-dg-pagination"]], [["clr-dg-column-toggle"]], "*"];
var _c58 = ["clr-dg-pagination", "clr-dg-column-toggle", "*"];
function ClrDatagridPageSize_option_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var option_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngValue", option_r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(option_r1);
} }
var _c59 = ["currentPageInput"];
function ClrDatagridPagination_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function ClrDatagridPagination_ng_container_0_div_4_input_5_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 16, 17);
    ɵngcc0.ɵɵlistener("keydown.enter", function ClrDatagridPagination_ng_container_0_div_4_input_5_Template_input_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r8 = ɵngcc0.ɵɵnextContext(3); return ctx_r8.updateCurrentPage($event); })("blur", function ClrDatagridPagination_ng_container_0_div_4_input_5_Template_input_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(3); return ctx_r10.updateCurrentPage($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("size", ctx_r4.page.last.toString().length)("value", ctx_r4.page.current);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r4.commonStrings.keys.currentPage);
} }
function ClrDatagridPagination_ng_container_0_div_4_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r6.page.current);
} }
function ClrDatagridPagination_ng_container_0_div_4_Template(rf, ctx) { if (rf & 1) {
    var _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵelementStart(1, "button", 6);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r12); var ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.page.current = 1; });
    ɵngcc0.ɵɵelement(2, "clr-icon", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 8);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r12); var ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.page.current = ctx_r13.page.current - 1; });
    ɵngcc0.ɵɵelement(4, "clr-icon", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, ClrDatagridPagination_ng_container_0_div_4_input_5_Template, 2, 3, "input", 10);
    ɵngcc0.ɵɵtemplate(6, ClrDatagridPagination_ng_container_0_div_4_ng_template_6_Template, 2, 1, "ng-template", null, 11, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtext(8, " \u00A0/\u00A0");
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "button", 12);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_11_listener() { ɵngcc0.ɵɵrestoreView(_r12); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.page.current = ctx_r14.page.current + 1; });
    ɵngcc0.ɵɵelement(12, "clr-icon", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(13, "button", 14);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_13_listener() { ɵngcc0.ɵɵrestoreView(_r12); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.page.current = ctx_r15.page.last; });
    ɵngcc0.ɵɵelement(14, "clr-icon", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var _r5 = ɵngcc0.ɵɵreference(7);
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r3.page.current <= 1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.firstPage);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("disabled", ctx_r3.page.current <= 1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.previousPage);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.disableCurrentPageInput)("ngIfElse", _r5);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.totalPages);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.page.last);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r3.page.current >= ctx_r3.page.last);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.nextPage);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("disabled", ctx_r3.page.current >= ctx_r3.page.last);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.lastPage);
} }
function ClrDatagridPagination_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrDatagridPagination_ng_container_0_div_1_Template, 2, 0, "div", 1);
    ɵngcc0.ɵɵelementStart(2, "div", 2);
    ɵngcc0.ɵɵprojection(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, ClrDatagridPagination_ng_container_0_div_4_Template, 15, 12, "div", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0._pageSizeComponent);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.page.last > 1);
} }
function ClrDatagridPagination_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 18);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 5);
    ɵngcc0.ɵɵelementStart(4, "button", 8);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridPagination_ng_container_1_Template_button_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.page.current = ctx_r16.page.current - 1; });
    ɵngcc0.ɵɵelement(5, "clr-icon", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "button", 12);
    ɵngcc0.ɵɵlistener("click", function ClrDatagridPagination_ng_container_1_Template_button_click_8_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.page.current = ctx_r18.page.current + 1; });
    ɵngcc0.ɵɵelement(9, "clr-icon", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate3(" ", ctx_r1.page.firstItem + 1, "-", ctx_r1.page.lastItem + 1, " / ", ctx_r1.page.totalItems, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.previousPage);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.page.current);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.nextPage);
} }
var _c60 = ["*", [["clr-dg-page-size"]]];
var _c61 = ["*", "clr-dg-page-size"];
function ClrStackBlock_clr_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("dir", ctx_r0.caretDirection);
} }
function ClrStackBlock_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.commonStrings.keys.stackViewChanged);
} }
var _c62 = [[["clr-stack-label"]], "*", [["clr-stack-block"]]];
var _c63 = ["clr-stack-label", "*", "clr-stack-block"];
var _c64 = [[["clr-stack-header"]], "*"];
var _c65 = ["clr-stack-header", "*"];
function ClrStackHeader_button_5_Template(rf, ctx) { if (rf & 1) {
    var _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function ClrStackHeader_button_5_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); var ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.stackView.editing = !ctx_r1.stackView.editing; });
    ɵngcc0.ɵɵtext(1, " Edit ");
    ɵngcc0.ɵɵelementEnd();
} }
var _c66 = ["*", [["", 8, "stack-action"]]];
var _c67 = ["*", ".stack-action"];
function ClrStackInput_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.model);
} }
function ClrStackInput_input_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 2);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrStackInput_input_1_Template_input_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.model = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", ctx_r1.type)("ngModel", ctx_r1.model);
} }
function ClrStackSelect_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.model);
} }
function ClrStackSelect_div_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelementStart(1, "select", 3);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrStackSelect_div_1_Template_select_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.model = $event; });
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1.model);
} }
var _c68 = ["contentContainer"];
function ClrTreeNode_button_2_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 9);
    ɵngcc0.ɵɵlistener("click", function ClrTreeNode_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.expandService.toggle(); })("focus", function ClrTreeNode_button_2_Template_button_focus_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.focusTreeNode(); });
    ɵngcc0.ɵɵelement(1, "clr-icon", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dir", ctx_r1.expandService.expanded ? "down" : "right");
} }
function ClrTreeNode_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵelement(1, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} }
function ClrTreeNode_div_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵelementStart(1, "input", 14);
    ɵngcc0.ɵɵlistener("change", function ClrTreeNode_div_4_Template_input_change_1_listener() { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8._model.toggleSelection(ctx_r8.featuresService.eager); })("focus", function ClrTreeNode_div_4_Template_input_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.focusTreeNode(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(2, "label", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate1("id", "", ctx_r3.nodeId, "-check");
    ɵngcc0.ɵɵproperty("checked", ctx_r3._model.selected.value === ctx_r3.STATES.SELECTED)("indeterminate", ctx_r3._model.selected.value === ctx_r3.STATES.INDETERMINATE);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate1("for", "", ctx_r3.nodeId, "-check");
} }
function ClrTreeNode_div_7_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1, " selected ");
    ɵngcc0.ɵɵelementEnd();
} }
function ClrTreeNode_div_7_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1, " unselected ");
    ɵngcc0.ɵɵelementEnd();
} }
function ClrTreeNode_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵtemplate(1, ClrTreeNode_div_7_span_1_Template, 2, 0, "span", 17);
    ɵngcc0.ɵɵtemplate(2, ClrTreeNode_div_7_span_2_Template, 2, 0, "span", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.ariaSelected);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.ariaSelected);
} }
var _c69 = ["*", [["clr-tree-node"]], [["", "clrIfExpanded", ""]]];
var _c70 = ["*", "clr-tree-node", "[clrIfExpanded]"];
function ClrTree_clr_recursive_children_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-recursive-children", 1);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("children", ctx_r0.featuresService.recursion.root);
} }
function RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function RecursiveChildren_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var child_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.featuresService.recursion.template)("ngTemplateOutletContext", ctx_r1.getContext(child_r2));
} }
function RecursiveChildren_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_Template, 2, 2, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", (ctx_r0.parent == null ? null : ctx_r0.parent.children) || ctx_r0.children);
} }
function ClrAlert_div_0_button_3_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function ClrAlert_div_0_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(2); return ctx_r2.close(); });
    ɵngcc0.ɵɵelement(1, "clr-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.clrCloseButtonAriaLabel);
} }
function ClrAlert_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, ClrAlert_div_0_button_3_Template, 2, 1, "button", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("alert-hidden", ctx_r0.hidden)("alert-sm", ctx_r0.isSmall)("alert-app-level", ctx_r0.isAppLevel);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.alertClass);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.closable);
} }
function ClrAlerts_clr_alerts_pager_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-alerts-pager", 1);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("clrCurrentAlertIndex", ctx_r0.currentAlertIndex);
} }
var _c71 = [[["clr-alert"]]];
var _c72 = ["clr-alert"];
function ClrHeader_button_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 3);
    ɵngcc0.ɵɵlistener("click", function ClrHeader_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.toggleNav(ctx_r2.responsiveNavCodes.NAV_LEVEL_1); });
    ɵngcc0.ɵɵelement(1, "span");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.openNavLevel !== ctx_r0.responsiveNavCodes.NAV_LEVEL_1 ? ctx_r0.commonStrings.keys.open : ctx_r0.commonStrings.keys.close);
} }
function ClrHeader_button_2_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function ClrHeader_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.toggleNav(ctx_r4.responsiveNavCodes.NAV_LEVEL_2); });
    ɵngcc0.ɵɵelement(1, "span");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.openNavLevel !== ctx_r1.responsiveNavCodes.NAV_LEVEL_2 ? ctx_r1.commonStrings.keys.open : ctx_r1.commonStrings.keys.close);
} }
function TemplateRefContainer_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
var _c73 = ["tabContentProjectedRef"];
function ClrTabContent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "section", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r1.active);
    ɵngcc0.ɵɵproperty("id", ctx_r1.tabContentId)("hidden", !ctx_r1.active);
    ɵngcc0.ɵɵattribute("aria-labelledby", ctx_r1.ariaLabelledBy)("aria-expanded", ctx_r1.active)("aria-hidden", !ctx_r1.active);
} }
var _c74 = ["clrKeyFocus", ""];
var _c75 = ["tabContentViewContainer"];
function ClrTabs_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "li", 4);
    ɵngcc0.ɵɵelementContainer(2, 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var link_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", link_r3.templateRefContainer.template);
} }
function ClrTabs_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrTabs_ng_container_1_ng_container_1_Template, 3, 1, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var link_r3 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", link_r3.tabsId === ctx_r0.tabsId && !link_r3.inOverflow);
} }
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 5);
} if (rf & 2) {
    var link_r9 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", link_r9.templateRefContainer.template);
} }
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_ng_container_1_Template, 1, 1, "ng-container", 13);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var link_r9 = ctx.$implicit;
    var ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", link_r9.tabsId === ctx_r8.tabsId && link_r9.inOverflow);
} }
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "clr-tab-overflow-content", 12);
    ɵngcc0.ɵɵlistener("keydown.esc", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_keydown_esc_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.closeOnEscapeKey(); }, false, ɵngcc0.ɵɵresolveDocument)("click", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); ɵngcc0.ɵɵnextContext(); var _r6 = ɵngcc0.ɵɵreference(4); var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.closeOnOutsideClick($event, _r6); }, false, ɵngcc0.ɵɵresolveDocument)("focusout", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_focusout_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.closeOnFocusOut($event); });
    ɵngcc0.ɵɵtemplate(1, ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_Template, 2, 1, "ng-container", 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r7.tabLinkDirectives);
} }
function ClrTabs_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 6);
    ɵngcc0.ɵɵelementStart(2, "li", 7);
    ɵngcc0.ɵɵelementStart(3, "button", 8, 9);
    ɵngcc0.ɵɵlistener("mousedown", function ClrTabs_ng_container_2_Template_button_mousedown_3_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16._mousedown = true; })("focus", function ClrTabs_ng_container_2_Template_button_focus_3_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.openOverflowOnFocus(); })("click", function ClrTabs_ng_container_2_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.toggleOverflowOnClick(); });
    ɵngcc0.ɵɵelement(5, "clr-icon", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template, 2, 1, "clr-tab-overflow-content", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("open", ctx_r1.toggleService.open);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("active", ctx_r1.activeTabInOverflow)("open", ctx_r1.toggleService.open);
    ɵngcc0.ɵɵattribute("tabindex", ctx_r1.activeTabInOverflow && !ctx_r1.toggleService.open ? 0 : 0 - 1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("is-info", ctx_r1.toggleService.open);
    ɵngcc0.ɵɵattribute("title", ctx_r1.commonStrings.keys.more);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.toggleService.open);
} }
function ClrVerticalNav_button_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 3);
    ɵngcc0.ɵɵlistener("click", function ClrVerticalNav_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.toggleByButton(); });
    ɵngcc0.ɵɵelement(1, "clr-icon", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("on-collapse", ctx_r0.collapsed);
    ɵngcc0.ɵɵattribute("aria-expanded", ctx_r0.ariaExpanded)("aria-label", ctx_r0.commonStrings.keys.verticalNavToggle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dir", ctx_r0.collapsed ? "right" : "left")("title", ctx_r0.collapsed ? ctx_r0.commonStrings.keys.expand : ctx_r0.commonStrings.keys.collapse);
} }
function ClrVerticalNav_button_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function ClrVerticalNav_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.collapsed = false; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.verticalNavToggle);
} }
var _c76 = [[["", "clrVerticalNavLink", ""]], [["", "clrVerticalNavIcon", ""]], "*", [["", "clrIfExpanded", ""], ["clr-vertical-nav-group-children"]]];
var _c77 = ["[clrVerticalNavLink]", "[clrVerticalNavIcon]", "*", "[clrIfExpanded], clr-vertical-nav-group-children"];
var _c78 = ["clrVerticalNavLink", ""];
var _c79 = [[["", "clrVerticalNavIcon", ""]], "*"];
var _c80 = ["[clrVerticalNavIcon]", "*"];
function ClrModal_div_0_button_8_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function ClrModal_div_0_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(2); return ctx_r2.close(); });
    ɵngcc0.ɵɵelement(1, "clr-icon", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.close);
} }
function ClrModal_div_0_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵlistener("@fadeDown.done", function ClrModal_div_0_Template_div_animation_fadeDown_done_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.fadeDone($event); });
    ɵngcc0.ɵɵelementStart(2, "div", 3);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 4);
    ɵngcc0.ɵɵprojection(5);
    ɵngcc0.ɵɵelementStart(6, "div", 5);
    ɵngcc0.ɵɵelementStart(7, "div", 6);
    ɵngcc0.ɵɵtemplate(8, ClrModal_div_0_button_8_Template, 2, 1, "button", 7);
    ɵngcc0.ɵɵelementStart(9, "div", 8);
    ɵngcc0.ɵɵprojection(10, 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(11, 2);
    ɵngcc0.ɵɵprojection(12, 3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(13, "div", 3);
    ɵngcc0.ɵɵtext(14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(15, "div", 9);
    ɵngcc0.ɵɵlistener("click", function ClrModal_div_0_Template_div_click_15_listener() { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.staticBackdrop || ctx_r6.close(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("modal-sm", ctx_r0.size == "sm")("modal-lg", ctx_r0.size == "lg")("modal-xl", ctx_r0.size == "xl");
    ɵngcc0.ɵɵproperty("@fadeDown", ctx_r0.skipAnimation);
    ɵngcc0.ɵɵattribute("aria-hidden", !ctx_r0._open)("aria-labelledby", ctx_r0.modalId);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.commonStrings.keys.modalContentStart);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.closable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("id", ctx_r0.modalId);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.commonStrings.keys.modalContentEnd);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@fade", undefined);
} }
var _c81 = [[["", 8, "modal-nav"]], [["", 8, "modal-title"]], [["", 8, "modal-body"]], [["", 8, "modal-footer"]]];
var _c82 = [".modal-nav", ".modal-title", ".modal-body", ".modal-footer"];
var _c83 = ["wizardTitle"];
function ClrWizard_ng_template_8_Template(rf, ctx) { }
function ClrWizard_div_9_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementEnd();
} }
function ClrWizard_div_9_div_2_ng_template_1_Template(rf, ctx) { }
function ClrWizard_div_9_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, ClrWizard_div_9_div_2_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.navService.currentPage.headerActions);
} }
function ClrWizard_div_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, ClrWizard_div_9_div_1_Template, 2, 0, "div", 14);
    ɵngcc0.ɵɵtemplate(2, ClrWizard_div_9_div_2_Template, 2, 1, "div", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.headerActionService.showWizardHeaderActions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.headerActionService.currentPageHasHeaderActions);
} }
function ClrWizard_div_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵprojection(1, 3);
    ɵngcc0.ɵɵelementEnd();
} }
function ClrWizard_div_16_ng_template_1_Template(rf, ctx) { }
function ClrWizard_div_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, ClrWizard_div_16_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.navService.currentPage.buttons);
} }
var _c84 = [[["clr-wizard-title"]], "*", [["clr-wizard-header-action"]], [["clr-wizard-button"]]];
var _c85 = ["clr-wizard-title", "*", "clr-wizard-header-action", "clr-wizard-button"];
function ClrWizardStepnav_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var page_r1 = ctx.$implicit;
    var i_r2 = ctx.index;
    ɵngcc0.ɵɵproperty("page", page_r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(i_r2 + 1);
} }
var _c86 = ["clr-wizard-stepnav-item", ""];
function ClrWizardStepnavItem_clr_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 6);
} }
function ClrWizardStepnavItem_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!hasError"]);
} }
function ClrWizardStepnavItem_ng_template_5_Template(rf, ctx) { }
function ClrAccordionPanel_ng_container_0_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.commonStrings.keys.danger);
} }
function ClrAccordionPanel_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, ClrAccordionPanel_ng_container_0_div_1_ng_container_1_Template, 2, 1, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var panel_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status === ctx_r2.AccordionStatus.Error);
} }
function ClrAccordionPanel_ng_container_0_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.commonStrings.keys.danger);
} }
function ClrAccordionPanel_ng_container_0_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.commonStrings.keys.success);
} }
function ClrAccordionPanel_ng_container_0_div_18_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵlistener("@toggle.done", function ClrAccordionPanel_ng_container_0_div_18_Template_div_animation_toggle_done_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); var panel_r1 = ɵngcc0.ɵɵnextContext().$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.collapsePanelOnAnimationDone(panel_r1); });
    ɵngcc0.ɵɵelementStart(1, "div", 16);
    ɵngcc0.ɵɵprojection(2, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("@toggle", undefined);
} }
function ClrAccordionPanel_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrAccordionPanel_ng_container_0_div_1_Template, 2, 1, "div", 1);
    ɵngcc0.ɵɵelementStart(2, "div", 2);
    ɵngcc0.ɵɵelementStart(3, "div", 3);
    ɵngcc0.ɵɵelementStart(4, "button", 4, 5);
    ɵngcc0.ɵɵlistener("click", function ClrAccordionPanel_ng_container_0_Template_button_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.togglePanel(); });
    ɵngcc0.ɵɵpipe(6, "async");
    ɵngcc0.ɵɵelementStart(7, "span", 6);
    ɵngcc0.ɵɵtemplate(8, ClrAccordionPanel_ng_container_0_ng_container_8_Template, 2, 1, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(9, ClrAccordionPanel_ng_container_0_ng_container_9_Template, 2, 1, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "span", 7);
    ɵngcc0.ɵɵelement(11, "clr-icon", 8);
    ɵngcc0.ɵɵelement(12, "span", 9);
    ɵngcc0.ɵɵelement(13, "clr-icon", 10);
    ɵngcc0.ɵɵelement(14, "clr-icon", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(15);
    ɵngcc0.ɵɵprojection(16, 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(17, "div", 12);
    ɵngcc0.ɵɵtemplate(18, ClrAccordionPanel_ng_container_0_div_18_Template, 3, 1, "div", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var panel_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    var tmp_2_0 = null;
    var currVal_2 = ((tmp_2_0 = ɵngcc0.ɵɵpipeBind1(6, 16, ctx_r0.accordionDescription.changes)) == null ? null : tmp_2_0.length) || ctx_r0.accordionDescription.length;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status !== ctx_r0.AccordionStatus.Inactive);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.getPanelStateClasses(panel_r1));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("clr-accordion-header-has-description", currVal_2);
    ɵngcc0.ɵɵproperty("id", ctx_r0.getAccordionHeaderId(panel_r1.templateId))("disabled", ctx_r0.isAccordion && panel_r1.disabled);
    ɵngcc0.ɵɵattribute("aria-disabled", !ctx_r0.isAccordion && panel_r1.disabled)("aria-controls", ctx_r0.getAccordionContentId(panel_r1.templateId))("aria-expanded", panel_r1.open);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status === ctx_r0.AccordionStatus.Error);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status === ctx_r0.AccordionStatus.Complete);
    ɵngcc0.ɵɵadvance(8);
    ɵngcc0.ɵɵproperty("@skipInitialRender", undefined)("id", ctx_r0.getAccordionContentId(panel_r1.templateId));
    ɵngcc0.ɵɵattribute("aria-hidden", !panel_r1.open)("aria-labelledby", ctx_r0.getAccordionHeaderId(panel_r1.templateId));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.open);
} }
var _c87 = [[["clr-accordion-title"], ["clr-step-title"]], [["clr-accordion-description"], ["clr-step-description"]], "*"];
var _c88 = ["clr-accordion-title, clr-step-title", "clr-accordion-description, clr-step-description", "*"];
var _c89 = ["headerButton"];
function ClrStepperPanel_ng_container_0_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.commonStrings.keys.danger);
} }
function ClrStepperPanel_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, ClrStepperPanel_ng_container_0_div_1_ng_container_1_Template, 2, 1, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var panel_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status === ctx_r2.AccordionStatus.Error);
} }
function ClrStepperPanel_ng_container_0_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.commonStrings.keys.danger);
} }
function ClrStepperPanel_ng_container_0_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.commonStrings.keys.success);
} }
function ClrStepperPanel_ng_container_0_div_18_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵlistener("@toggle.done", function ClrStepperPanel_ng_container_0_div_18_Template_div_animation_toggle_done_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); var panel_r1 = ɵngcc0.ɵɵnextContext().$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.collapsePanelOnAnimationDone(panel_r1); });
    ɵngcc0.ɵɵelementStart(1, "div", 16);
    ɵngcc0.ɵɵprojection(2, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("@toggle", undefined);
} }
function ClrStepperPanel_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ClrStepperPanel_ng_container_0_div_1_Template, 2, 1, "div", 1);
    ɵngcc0.ɵɵelementStart(2, "div", 2);
    ɵngcc0.ɵɵelementStart(3, "div", 3);
    ɵngcc0.ɵɵelementStart(4, "button", 4, 5);
    ɵngcc0.ɵɵlistener("click", function ClrStepperPanel_ng_container_0_Template_button_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.togglePanel(); });
    ɵngcc0.ɵɵpipe(6, "async");
    ɵngcc0.ɵɵelementStart(7, "span", 6);
    ɵngcc0.ɵɵtemplate(8, ClrStepperPanel_ng_container_0_ng_container_8_Template, 2, 1, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(9, ClrStepperPanel_ng_container_0_ng_container_9_Template, 2, 1, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "span", 7);
    ɵngcc0.ɵɵelement(11, "clr-icon", 8);
    ɵngcc0.ɵɵelement(12, "span", 9);
    ɵngcc0.ɵɵelement(13, "clr-icon", 10);
    ɵngcc0.ɵɵelement(14, "clr-icon", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(15);
    ɵngcc0.ɵɵprojection(16, 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(17, "div", 12);
    ɵngcc0.ɵɵtemplate(18, ClrStepperPanel_ng_container_0_div_18_Template, 3, 1, "div", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var panel_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    var tmp_2_0 = null;
    var currVal_2 = ((tmp_2_0 = ɵngcc0.ɵɵpipeBind1(6, 16, ctx_r0.accordionDescription.changes)) == null ? null : tmp_2_0.length) || ctx_r0.accordionDescription.length;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status !== ctx_r0.AccordionStatus.Inactive);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.getPanelStateClasses(panel_r1));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("clr-accordion-header-has-description", currVal_2);
    ɵngcc0.ɵɵproperty("id", ctx_r0.getAccordionHeaderId(panel_r1.templateId))("disabled", ctx_r0.isAccordion && panel_r1.disabled);
    ɵngcc0.ɵɵattribute("aria-disabled", !ctx_r0.isAccordion && panel_r1.disabled)("aria-controls", ctx_r0.getAccordionContentId(panel_r1.templateId))("aria-expanded", panel_r1.open);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status === ctx_r0.AccordionStatus.Error);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.status === ctx_r0.AccordionStatus.Complete);
    ɵngcc0.ɵɵadvance(8);
    ɵngcc0.ɵɵproperty("@skipInitialRender", undefined)("id", ctx_r0.getAccordionContentId(panel_r1.templateId));
    ɵngcc0.ɵɵattribute("aria-hidden", !panel_r1.open)("aria-labelledby", ctx_r0.getAccordionHeaderId(panel_r1.templateId));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", panel_r1.open);
} }
var _c90 = ["clrStepper", ""];
function ClrProgressBar_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.displayValue);
} }
function ClrTimelineStep_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "clr-icon");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("shape", ctx_r0.iconShape)("aria-label", ctx_r0.iconAriaLabel)("aria-current", ctx_r0.iconAriaCurrent);
} }
function ClrTimelineStep_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-spinner", 4);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.iconAriaLabel);
} }
var _c91 = [[["clr-timeline-step-header"]], [["clr-timeline-step-title"]], [["clr-timeline-step-description"]]];
var _c92 = ["clr-timeline-step-header", "clr-timeline-step-title", "clr-timeline-step-description"];
'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var ClrIconCustomTag = /** @class */ (function () {
        function ClrIconCustomTag() {
        }
ClrIconCustomTag.ɵfac = function ClrIconCustomTag_Factory(t) { return new (t || ClrIconCustomTag)(); };
ClrIconCustomTag.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIconCustomTag, selectors: [["clr-icon"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIconCustomTag, [{
        type: core.Directive,
        args: [{ selector: 'clr-icon' }]
    }], function () { return []; }, null); })();
        return ClrIconCustomTag;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_ICON_DIRECTIVES = [ClrIconCustomTag];
    var ClrIconModule = /** @class */ (function () {
        function ClrIconModule() {
        }
ClrIconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrIconModule });
ClrIconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrIconModule_Factory(t) { return new (t || ClrIconModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrIconModule, { declarations: [ClrIconCustomTag], imports: [ɵngcc1.CommonModule], exports: [ClrIconCustomTag] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIconModule, [{
        type: core.NgModule,
        args: [{ imports: [common.CommonModule], declarations: [CLR_ICON_DIRECTIVES], exports: [CLR_ICON_DIRECTIVES] }]
    }], function () { return []; }, null); })();
        return ClrIconModule;
    }());

    var ClrPopoverToggleService = /** @class */ (function () {
        function ClrPopoverToggleService() {
            /**
             *  Popovers might need to ignore click events on an element
             *  (eg: popover opens on focus on an input field. Clicks should be ignored in this case)
             */
            this._open = false;
            this._openChange = new rxjs.Subject();
            this._openEventChange = new rxjs.Subject();
        }
        Object.defineProperty(ClrPopoverToggleService.prototype, "openChange", {
            get: function () {
                return this._openChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrPopoverToggleService.prototype, "openEvent", {
            get: function () {
                return this._openEvent;
            },
            set: function (event) {
                this._openEvent = event;
                this._openEventChange.next(event);
            },
            enumerable: true,
            configurable: true
        });
        ClrPopoverToggleService.prototype.getEventChange = function () {
            return this._openEventChange.asObservable();
        };
        Object.defineProperty(ClrPopoverToggleService.prototype, "open", {
            get: function () {
                return this._open;
            },
            set: function (value) {
                value = !!value;
                if (this._open !== value) {
                    this._open = value;
                    this._openChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrPopoverToggleService.prototype, "originalEvent", {
            get: function () {
                return this._openEvent;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sometimes, we need to remember the event that triggered the toggling to avoid loops.
         * This is for instance the case of components that open on a click, but close on a click outside.
         */
        ClrPopoverToggleService.prototype.toggleWithEvent = function (event) {
            this.openEvent = event;
            this.open = !this.open;
        };
ClrPopoverToggleService.ɵfac = function ClrPopoverToggleService_Factory(t) { return new (t || ClrPopoverToggleService)(); };
ClrPopoverToggleService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ClrPopoverToggleService, factory: function (t) { return ClrPopoverToggleService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverToggleService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ClrPopoverToggleService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    // https://github.com/angular/angular/issues/20351#issuecomment-344009887
    /** @dynamic */
    var ClrPopoverEventsService = /** @class */ (function () {
        function ClrPopoverEventsService(renderer, smartOpenService, document) {
            var _this = this;
            this.renderer = renderer;
            this.smartOpenService = smartOpenService;
            this.document = document;
            this.outsideClickClose = true;
            this.scrollToClose = true;
            this.subscriptions = [];
            this.subscriptions.push(smartOpenService.openChange.subscribe(function (open) {
                if (open) {
                    _this.addEscapeListener();
                    _this.addClickListener();
                    _this.addScrollListener();
                }
                else {
                    _this.removeAllEventListeners();
                }
            }), smartOpenService.getEventChange().subscribe(function (event) {
                // Remember the event that was used to open the content
                _this.ignoredEvent = event;
            }));
        }
        ClrPopoverEventsService.prototype.addScrollListener = function () {
            var _this = this;
            if (this.scrollToClose) {
                this.documentScroller = rxjs.fromEvent(this.document, 'scroll', { capture: true });
                this.scrollSubscription = this.documentScroller
                    .pipe(operators.filter(this.testForSmartPopoverContentContainer))
                    .subscribe(function () {
                    _this.smartOpenService.open = false;
                    _this.setAnchorFocus();
                });
            }
            else {
                // I think this is where dynamic re-positioning will be added
                // Instead of testing like we do in the close pipe below
                // we need to switch positioning to use an observable and then
                // debounce the scroll events to recalculate content position in a performant way
                // For now, ignore scrolling events.
                return;
            }
        };
        ClrPopoverEventsService.prototype.removeScrollListener = function () {
            if (this.documentScroller) {
                this.scrollSubscription.unsubscribe();
                delete this.documentScroller;
            }
        };
        ClrPopoverEventsService.prototype.testForSmartPopoverContentContainer = function (event) {
            // Filter for the documentScroller observable event targets
            var target = event.target;
            // Walk up the DOM tree until we get to the element that is a direct child of the body.
            while (target.classList && target.parentElement.localName !== 'body') {
                target = target.parentElement;
            }
            // Target is the child element of body where the scroll events originated.
            // Return false and prevent the popover content container from closing for any scroll events inside a popover
            // content container.
            if (target.classList) {
                // check scroll events to see if they are happening in popover content or elsewhere
                return target.classList.contains('clr-popover-content') ? false : true;
            }
            else {
                // prevents it from closing right after first opening
                return false;
            }
        };
        ClrPopoverEventsService.prototype.addClickListener = function () {
            var _this = this;
            if (this.outsideClickClose) {
                this.documentClickListener = this.renderer.listen(this.document, 'click', function (event) {
                    if (event === _this.ignoredEvent) {
                        // Here we ignore the opening click event (w/o this content opens and immediately closes.
                        delete _this.ignoredEvent;
                    }
                    else {
                        _this.smartOpenService.open = false;
                        // Rather than a complex change to the focus trap I put focus on the element that was clicked
                        var clickedElement = event.target;
                        clickedElement.focus();
                    }
                });
            }
        };
        ClrPopoverEventsService.prototype.removeClickListener = function () {
            if (this.outsideClickClose) {
                delete this.ignoredEvent;
                if (this.documentClickListener) {
                    this.documentClickListener();
                    delete this.documentClickListener;
                }
            }
        };
        ClrPopoverEventsService.prototype.addEscapeListener = function () {
            var _this = this;
            this.escapeListener = this.renderer.listen(this.document, 'keydown.escape', function (event) {
                _this.smartOpenService.open = false;
                _this.setAnchorFocus();
            });
        };
        ClrPopoverEventsService.prototype.removeEscapeListener = function () {
            if (this.escapeListener) {
                this.escapeListener();
                delete this.escapeListener;
            }
        };
        Object.defineProperty(ClrPopoverEventsService.prototype, "anchorButtonRef", {
            get: function () {
                return this._anchorButtonRef;
            },
            set: function (ref) {
                this._anchorButtonRef = ref;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrPopoverEventsService.prototype, "closeButtonRef", {
            get: function () {
                return this._closeButtonRef;
            },
            set: function (ref) {
                this._closeButtonRef = ref;
            },
            enumerable: true,
            configurable: true
        });
        ClrPopoverEventsService.prototype.setCloseFocus = function () {
            this._closeButtonRef.nativeElement.focus();
        };
        ClrPopoverEventsService.prototype.setAnchorFocus = function () {
            this.anchorButtonRef.nativeElement.focus();
        };
        Object.defineProperty(ClrPopoverEventsService.prototype, "contentRef", {
            get: function () {
                return this._contentRef;
            },
            set: function (host) {
                this._contentRef = host;
            },
            enumerable: true,
            configurable: true
        });
        ClrPopoverEventsService.prototype.removeAllEventListeners = function () {
            this.removeScrollListener();
            this.removeClickListener();
            this.removeEscapeListener();
        };
        ClrPopoverEventsService.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            this.removeAllEventListeners();
        };
        ClrPopoverEventsService.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: ClrPopoverToggleService },
            { type: HTMLDocument, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        ClrPopoverEventsService = __decorate([ __param(2, core.Inject(common.DOCUMENT))
        ], ClrPopoverEventsService);
ClrPopoverEventsService.ɵfac = function ClrPopoverEventsService_Factory(t) { return new (t || ClrPopoverEventsService)(ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(ClrPopoverToggleService), ɵngcc0.ɵɵinject(common.DOCUMENT)); };
ClrPopoverEventsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ClrPopoverEventsService, factory: function (t) { return ClrPopoverEventsService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverEventsService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ClrPopoverToggleService }, { type: HTMLDocument, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }]; }, null); })();
        return ClrPopoverEventsService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var ClrViewportViolation;
    (function (ClrViewportViolation) {
        ClrViewportViolation[ClrViewportViolation["BOTTOM"] = 0] = "BOTTOM";
        ClrViewportViolation[ClrViewportViolation["LEFT"] = 1] = "LEFT";
        ClrViewportViolation[ClrViewportViolation["RIGHT"] = 2] = "RIGHT";
        ClrViewportViolation[ClrViewportViolation["TOP"] = 3] = "TOP";
    })(ClrViewportViolation || (ClrViewportViolation = {}));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */

    (function (ClrAlignment) {
        ClrAlignment[ClrAlignment["START"] = 0] = "START";
        ClrAlignment[ClrAlignment["CENTER"] = 0.5] = "CENTER";
        ClrAlignment[ClrAlignment["END"] = 1] = "END";
    })(exports.ClrAlignment || (exports.ClrAlignment = {}));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var flipSides = function (position) {
        return __assign(__assign({}, position), { side: -1 * position.side });
    };
    // This could be used in more advanced positioning algorithms.
    // flipAxisFlipSideAndNudgeContent(flipAxis, flipSide, nudge, nudgeForward?): ClrTransform {...}
    // I would like to keep it for now.
    var flipAxis = function (position) {
        return __assign(__assign({}, position), { axis: position.axis === 0 ? 1 : 0 });
    };
    var nudgeContent = function (position, forward) {
        var nextAlignment = position.content + (forward ? 0.5 : -0.5);
        if (nextAlignment < 0 || nextAlignment > 1) {
            return position;
        }
        else {
            return __assign(__assign({}, position), { content: nextAlignment });
        }
    };
    function flipSidesAndNudgeContent(flip, nudge, nudgeBack) {
        return function (position) { return nudge(flip(position), nudgeBack); };
    }
    function align(position, anchor, content) {
        var xDiff = anchor.left;
        var yDiff = anchor.top;
        // When ClrAxis is VERTICAL BEFORE = left, AFTER = right
        // When ClrAxis is HORIZONTAL BEFORE is top, AFTER is bottom
        switch (position.axis + position.side) {
            case -1: {
                // ClrAxis.VERTICAL + ClrSide.BEFORE
                xDiff += alignHorizontal(position, anchor, content);
                yDiff -= content.height; // pull content up to the top of the anchor
                break;
            }
            case 1: {
                // ClrAxis.VERTICAL + ClrSide.AFTER
                xDiff += alignHorizontal(position, anchor, content);
                yDiff += anchor.height; // push the content down to below the anchor
                break;
            }
            case 0: {
                // ClrAxis.HORIZONTAL + ClrSide.BEFORE
                xDiff -= content.width; // pull the content left of the anchor
                yDiff += alignVertical(position, anchor, content);
                break;
            }
            case 2: {
                // ClrAxis.HORIZONTAL + ClrSide.AFTER
                xDiff += anchor.width; // push the content right of of the anchor
                yDiff += alignVertical(position, anchor, content);
                break;
            }
            default: {
                break;
            }
        }
        return { xOffset: xDiff, yOffset: yDiff };
    }
    function alignHorizontal(position, anchor, content) {
        var horizontalOffset = 0;
        // horizontal offset for the anchor position
        switch (position.anchor /*calculate for the anchor alignment*/) {
            case exports.ClrAlignment.START: {
                // nothing to calculate here
                break;
            }
            case exports.ClrAlignment.CENTER: {
                horizontalOffset += anchor.width / 2; // push content over 1/2 anchor width
                break;
            }
            case exports.ClrAlignment.END: {
                horizontalOffset += anchor.width; //  push content over width of the anchor
                break;
            }
            default: {
                break;
            }
        }
        // horizontal offsets for anchor alignment
        switch (position.content // calculate for the content alignment
        ) {
            case exports.ClrAlignment.START: {
                // Nothing to calculate here
                break;
            }
            case exports.ClrAlignment.CENTER: {
                horizontalOffset -= content.width / 2; // pull content left by a value of 1/2 content width
                break;
            }
            case exports.ClrAlignment.END: {
                // subtract the width of currentContent from horizontalOffset to pull it back
                horizontalOffset -= content.width;
                break;
            }
            default: {
                break;
            }
        }
        return horizontalOffset;
    }
    function alignVertical(position, anchor, content) {
        // y axis offsets for anchor alignment
        var verticalOffset = 0;
        // Calculate y offset for anchor position
        switch (position.anchor) {
            case exports.ClrAlignment.START: {
                // nothing to calculate here
                break;
            }
            case exports.ClrAlignment.CENTER: {
                verticalOffset += anchor.height / 2; // push content down to the middle of the anchor rect
                break;
            }
            case exports.ClrAlignment.END: {
                verticalOffset += anchor.height; // push content down to the bottom of the anchor
                break;
            }
            default: {
                break;
            }
        }
        // Calculate y offsets for content alignment
        switch (position.content) {
            case exports.ClrAlignment.START: {
                // aligned to the top of the content rect
                break;
            }
            case exports.ClrAlignment.CENTER: {
                verticalOffset -= content.height / 2; // pull content back up to the middle of the content rect
                break;
            }
            case exports.ClrAlignment.END: {
                verticalOffset -= content.height; // pull content back up to the bottom of the content rect
                break;
            }
            default: {
                break;
            }
        }
        return verticalOffset;
    }
    function testVisibility(offset, content) {
        var violations = [];
        var mockCoords = {
            bottom: offset.yOffset + content.height,
            left: offset.xOffset,
            right: offset.xOffset + content.width,
            top: offset.yOffset,
        };
        if (!(mockCoords.top >= 0)) {
            violations.push(ClrViewportViolation.TOP);
        }
        if (!(mockCoords.left >= 0)) {
            violations.push(ClrViewportViolation.LEFT);
        }
        if (!(mockCoords.bottom <= (window.innerHeight || document.documentElement.clientHeight))) {
            violations.push(ClrViewportViolation.BOTTOM);
        }
        if (!(mockCoords.right <= (window.innerWidth || document.documentElement.clientWidth))) {
            violations.push(ClrViewportViolation.RIGHT);
        }
        return violations;
    }

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */

    (function (ClrAxis) {
        ClrAxis[ClrAxis["VERTICAL"] = 0] = "VERTICAL";
        ClrAxis[ClrAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
    })(exports.ClrAxis || (exports.ClrAxis = {}));

    var ClrPopoverPositionService = /** @class */ (function () {
        function ClrPopoverPositionService(eventService, platformId) {
            this.eventService = eventService;
            this.platformId = platformId;
            this._shouldRealign = new rxjs.Subject();
            this.shouldRealign = this._shouldRealign.asObservable();
        }
        ClrPopoverPositionService.prototype.realign = function () {
            this._shouldRealign.next();
        };
        Object.defineProperty(ClrPopoverPositionService.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position = position;
            },
            enumerable: true,
            configurable: true
        });
        ClrPopoverPositionService.prototype.alignContent = function (content) {
            if (!common.isPlatformBrowser(this.platformId)) {
                // Only position when in a browser.
                // Default to the browser origin and prevent getBoundingClientRect from running.
                return {
                    xOffset: 0,
                    yOffset: 0,
                };
            }
            this.currentAnchorCoords = this.eventService.anchorButtonRef.nativeElement.getBoundingClientRect();
            this.currentContentCoords = content.getBoundingClientRect();
            this.contentOffsets = align(this.position, this.currentAnchorCoords, this.currentContentCoords);
            var visibilityViolations = testVisibility(this.contentOffsets, this.currentContentCoords);
            /**
             * Calculate the sum of viewport errors. This calculation is used below with the provided Axis in the given
             * ClrPopoverPosition. Its worth putting the ClrViewportViolation enum values here:
             *
             *   BOTTOM = 0,
             *   LEFT = 1,
             *   RIGHT = 2,
             *   TOP = 3,
             *
             *   So, this.visibilityViolations.length tells us how many sides of the viewport that the popover content was
             *   clipped on. We can only help when the content has an issue on one or two sides.
             *   errorSum is calculated to determine _how_ to change the position. Looking at both the axis and the number
             *   of violations I can use the errorSum to determine how to transform the position (on the fly) and adjust
             *   where it can be improved.
             *
             *   Note, more than 3 viewport violations and there isn't anything we can do to help. Also when there are two
             *   violations, we can't help if the violations are TOP+BOTTOM || LEFT+RIGHT => There is no transformation we
             *   can make to the postion that will help.
             *
             *   Some examples:
             *   There is only one error and Primary axis is VERTICAL
             *   - this.handleVerticalAxisOneViolation has a switch that will use the error sum to apply the correct
             *   transform to the postion based on the reduction of visibilityViolations.
             *
             *   There are two errors and Primary axis is HORIZONTAL
             *   - handleHorizontalAxisTwoViolations has a switch that uses the error sum to apply both transforms needed to
             *   improve the content position based on the reduction of visibilityViolations.
             */
            var errorSum = visibilityViolations.reduce(function (count, current) {
                return count + current;
            }, 0);
            if (visibilityViolations.length === 1 && this.position.axis === exports.ClrAxis.VERTICAL) {
                // When primary axis is VERTICAL and there is one viewport violation
                this.handleVerticalAxisOneViolation(errorSum);
            }
            else if (visibilityViolations.length === 1 && this.position.axis === exports.ClrAxis.HORIZONTAL) {
                // When primary axis is HORIZONTAL and there is one viewport violation
                this.handleHorizontalAxisOneViolation(errorSum);
            }
            else if (visibilityViolations.length === 2 && this.position.axis === exports.ClrAxis.VERTICAL) {
                // When primary axis is VERTICAL and there are two viewport violations
                this.handleVerticalAxisTwoViolations(errorSum);
            }
            else if (visibilityViolations.length === 2 && this.position.axis === exports.ClrAxis.HORIZONTAL) {
                // When primary axis is HORIZONTAL and there are two viewport violations
                this.handleHorizontalAxisTwoViolations(errorSum);
            }
            return this.contentOffsets;
        };
        ClrPopoverPositionService.prototype.handleVerticalAxisOneViolation = function (errorSum) {
            switch (errorSum) {
                case 0:
                case 3: {
                    // BOTTOM(0) or TOP(3) are primary violations and we can just flip sides
                    this.contentOffsets = align(flipSides(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 1: {
                    // LEFT(1) is secondary and needs to nudge content right
                    this.contentOffsets = align(nudgeContent(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 2: {
                    // RIGHT(2) is secondary and  needs to nudge content left
                    this.contentOffsets = align(nudgeContent(this.position, true), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                default: {
                    break;
                }
            }
        };
        ClrPopoverPositionService.prototype.handleVerticalAxisTwoViolations = function (errorSum) {
            switch (errorSum) {
                // We know there are two violations. We can use the errorSum to determine which combination of sides were
                // violated and handle appropriately.
                case 5: {
                    // TOP(3)+RIGHT(2) is case 5. We need to flip sides and nudge the content to the left
                    var flipAndNudgeLeft = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
                    this.contentOffsets = align(flipAndNudgeLeft(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 4: {
                    //TOP(3)+LEFT(1) is case 4, we need to flip sides and nudge content to the right
                    var flipAndNudgeRight = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
                    this.contentOffsets = align(flipAndNudgeRight(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 3: {
                    // TOP(3)+BOTTOM(0) || left(1)+RIGHT(2) is case 3. There is nothing we can do position wise to improve the
                    // placement for this content.
                    break;
                }
                case 2: {
                    // BOTTOM(0)+RIGHT(2) is case 2. We need to flip sides and nudge the content to the left
                    var flipAndNudgeLeft = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
                    this.contentOffsets = align(flipAndNudgeLeft(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 1: {
                    // BOTTOM(0)+LEFT(1) is case 1. We need to flip sides and nudge to the right
                    var flipAndNudgeRight = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
                    this.contentOffsets = align(flipAndNudgeRight(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                default: {
                    break;
                }
            }
        };
        ClrPopoverPositionService.prototype.handleHorizontalAxisOneViolation = function (errorSum) {
            switch (errorSum) {
                case 1:
                case 2: {
                    // LEFT(1) and RIGHT(2) are primary violations so we can flip sides
                    this.contentOffsets = align(flipSides(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 0: {
                    // BOTTOM(0) is a secondary violation and we need to nudge content up
                    this.contentOffsets = align(nudgeContent(this.position, true), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 3: {
                    // TOP(3) is a secondary violation and we need to nudge content down
                    this.contentOffsets = align(nudgeContent(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                default: {
                    break;
                }
            }
        };
        ClrPopoverPositionService.prototype.handleHorizontalAxisTwoViolations = function (errorSum) {
            switch (errorSum) {
                case 5:
                case 4: {
                    // TOP(3)+LEFT(1) is case 4.
                    // TOP(3)+RIGHT(2) is case 5.
                    // In both of these cases we need to flip sides and nudge content down
                    var flipAndNudgeDown = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
                    this.contentOffsets = align(flipAndNudgeDown(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                case 3: {
                    // TOP(3)+BOTTOM(0) || left(1)+RIGHT(2) is case 3. There is nothing we can do position wise to improve the
                    // placement for this content.
                    break;
                }
                case 2:
                case 1: {
                    // BOTTOM(0)+RIGHT(2) is case 2.
                    // BOTTOM(0)+LEFT(1) is case 1.
                    // In both cases we  need to flip sides and nudge content up
                    var flipAndNudgeUp = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
                    this.contentOffsets = align(flipAndNudgeUp(this.position), this.currentAnchorCoords, this.currentContentCoords);
                    break;
                }
                default: {
                    break;
                }
            }
        };
        ClrPopoverPositionService.ctorParameters = function () { return [
            { type: ClrPopoverEventsService },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        ClrPopoverPositionService = __decorate([ __param(1, core.Inject(core.PLATFORM_ID))
        ], ClrPopoverPositionService);
ClrPopoverPositionService.ɵfac = function ClrPopoverPositionService_Factory(t) { return new (t || ClrPopoverPositionService)(ɵngcc0.ɵɵinject(ClrPopoverEventsService), ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
ClrPopoverPositionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ClrPopoverPositionService, factory: function (t) { return ClrPopoverPositionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverPositionService, [{
        type: core.Injectable
    }], function () { return [{ type: ClrPopoverEventsService }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return ClrPopoverPositionService;
    }());

    // https://github.com/angular/angular/issues/20351#issuecomment-344009887
    /** @dynamic */
    var ClrPopoverContent = /** @class */ (function () {
        function ClrPopoverContent(document, container, template, renderer, smartPositionService, smartEventsService, smartOpenService) {
            this.document = document;
            this.container = container;
            this.template = template;
            this.renderer = renderer;
            this.smartPositionService = smartPositionService;
            this.smartEventsService = smartEventsService;
            this.smartOpenService = smartOpenService;
            this.subscriptions = [];
            this.shouldRealign = false;
            // Check-collector pattern:
            // In order to get accurate content height/width values, we cannot calculate alignment offsets until
            // after the projected content has stabilized.
            // As multiple check events may happen in the same rendering cycle, we need to collect all events
            // and only act after the content is really stable. Or we may get wrong intermediate positioning values.
            // We will channel subsequent content check events through this observable.
            this.checkCollector = new core.EventEmitter();
        }
        Object.defineProperty(ClrPopoverContent.prototype, "open", {
            set: function (value) {
                this.smartOpenService.open = !!value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrPopoverContent.prototype, "contentAt", {
            set: function (position) {
                this.smartPositionService.position = position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrPopoverContent.prototype, "outsideClickClose", {
            set: function (clickToClose) {
                this.smartEventsService.outsideClickClose = !!clickToClose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrPopoverContent.prototype, "scrollToClose", {
            set: function (scrollToClose) {
                this.smartEventsService.scrollToClose = !!scrollToClose;
            },
            enumerable: true,
            configurable: true
        });
        ClrPopoverContent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.subscriptions.push(this.smartOpenService.openChange.subscribe(function (change) {
                if (change) {
                    _this.addContent();
                }
                else {
                    _this.removeContent();
                }
            }), this.smartPositionService.shouldRealign.subscribe(function () {
                _this.shouldRealign = true;
                // Avoid flickering on initialization, caused by the asynchronous nature of the
                // check-collector pattern.
                if (_this.view) {
                    _this.renderer.setStyle(_this.view.rootNodes[0], 'opacity', '0');
                }
            }), 
            // Here we collect subsequent synchronously received content-check events and only take action
            // at the end of the cycle. See below for details on the check-collector pattern.
            this.checkCollector.pipe(operators.debounceTime(0)).subscribe(function () {
                _this.alignContent();
                _this.shouldRealign = false;
                if (_this.view) {
                    _this.renderer.setStyle(_this.view.rootNodes[0], 'opacity', '1');
                }
            }));
        };
        ClrPopoverContent.prototype.ngOnDestroy = function () {
            this.removeContent();
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrPopoverContent.prototype.removeContent = function () {
            var _this = this;
            if (!this.view) {
                return;
            }
            this.view.rootNodes.forEach(function (node) { return _this.renderer.removeChild(_this.document.body, node); });
            this.container.clear();
            delete this.view;
        };
        /**
         * TODO(matt): investigate why DebugElement retains a reference to the nodes and causes a memory leak.
         * A note about the use of appendChild/removeChild
         * The DebugElement is keeping a reference to the detached node and its unclear why.
         * This does warrant further investigation. But, since it doesn't happen in production mode
         * it is a low priority issue for now.
         */
        ClrPopoverContent.prototype.addContent = function () {
            var _this = this;
            // Create the view container
            this.view = this.container.createEmbeddedView(this.template);
            this.smartEventsService.contentRef = this.view.rootNodes[0]; // So we know where/what to set close focus on
            this.renderer.addClass(this.view.rootNodes[0], 'clr-popover-content');
            // Reset to the begining of the document to be available for sizing/positioning calculations.
            // If we add new content to the bottom it triggers changes in the layout that may lead to false anchor
            // coordinates values.
            this.renderer.setStyle(this.view.rootNodes[0], 'top', '0px');
            this.renderer.setStyle(this.view.rootNodes[0], 'left', '0px');
            // We need to hide it during the calculation phase, while it's not yet finally positioned.
            this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '0');
            this.renderer.listen(this.view.rootNodes[0], 'click', function (event) {
                _this.smartOpenService.openEvent = event;
            });
            this.view.rootNodes.forEach(function (node) {
                _this.renderer.appendChild(_this.document.body, node);
            });
            // Mark for realingment on the next content-check cycle.
            this.shouldRealign = true;
        };
        ClrPopoverContent.prototype.ngAfterContentChecked = function () {
            if (this.smartOpenService.open && this.view && this.shouldRealign) {
                // Channel content-check event through the check-collector
                this.checkCollector.emit();
            }
        };
        ClrPopoverContent.prototype.alignContent = function () {
            if (!this.view) {
                return;
            }
            var positionCoords = this.smartPositionService.alignContent(this.view.rootNodes[0]);
            this.renderer.setStyle(this.view.rootNodes[0], 'top', positionCoords.yOffset + "px");
            this.renderer.setStyle(this.view.rootNodes[0], 'left', positionCoords.xOffset + "px");
        };
        ClrPopoverContent.ctorParameters = function () { return [
            { type: HTMLDocument, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.ViewContainerRef },
            { type: core.TemplateRef },
            { type: core.Renderer2 },
            { type: ClrPopoverPositionService },
            { type: ClrPopoverEventsService },
            { type: ClrPopoverToggleService }
        ]; };
        __decorate([
            core.Input('clrPopoverContent')
        ], ClrPopoverContent.prototype, "open", null);
        __decorate([
            core.Input('clrPopoverContentAt')
        ], ClrPopoverContent.prototype, "contentAt", null);
        __decorate([
            core.Input('clrPopoverContentOutsideClickToClose')
        ], ClrPopoverContent.prototype, "outsideClickClose", null);
        __decorate([
            core.Input('clrPopoverContentScrollToClose')
        ], ClrPopoverContent.prototype, "scrollToClose", null);
        ClrPopoverContent = __decorate([ __param(0, core.Inject(common.DOCUMENT))
        ], ClrPopoverContent);
ClrPopoverContent.ɵfac = function ClrPopoverContent_Factory(t) { return new (t || ClrPopoverContent)(ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ClrPopoverPositionService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverEventsService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService)); };
ClrPopoverContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrPopoverContent, selectors: [["", "clrPopoverContent", ""]], inputs: { open: ["clrPopoverContent", "open"], contentAt: ["clrPopoverContentAt", "contentAt"], outsideClickClose: ["clrPopoverContentOutsideClickToClose", "outsideClickClose"], scrollToClose: ["clrPopoverContentScrollToClose", "scrollToClose"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverContent, [{
        type: core.Directive,
        args: [{ selector: '[clrPopoverContent]' }]
    }], function () { return [{ type: HTMLDocument, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.Renderer2 }, { type: ClrPopoverPositionService }, { type: ClrPopoverEventsService }, { type: ClrPopoverToggleService }]; }, { open: [{
            type: core.Input,
            args: ['clrPopoverContent']
        }], contentAt: [{
            type: core.Input,
            args: ['clrPopoverContentAt']
        }], outsideClickClose: [{
            type: core.Input,
            args: ['clrPopoverContentOutsideClickToClose']
        }], scrollToClose: [{
            type: core.Input,
            args: ['clrPopoverContentScrollToClose']
        }] }); })();
        return ClrPopoverContent;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var ClrPopoverOpenCloseButton = /** @class */ (function () {
        function ClrPopoverOpenCloseButton(smartOpenService) {
            var _this = this;
            this.smartOpenService = smartOpenService;
            this.subscriptions = [];
            this.openCloseChange = new core.EventEmitter();
            this.subscriptions.push(this.smartOpenService.openChange.subscribe(function (change) {
                _this.openCloseChange.next(change);
            }));
        }
        ClrPopoverOpenCloseButton.prototype.handleClick = function (event) {
            this.smartOpenService.toggleWithEvent(event);
        };
        ClrPopoverOpenCloseButton.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrPopoverOpenCloseButton.ctorParameters = function () { return [
            { type: ClrPopoverToggleService }
        ]; };
        __decorate([
            core.Output('clrPopoverOpenCloseChange')
        ], ClrPopoverOpenCloseButton.prototype, "openCloseChange", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], ClrPopoverOpenCloseButton.prototype, "handleClick", null);
ClrPopoverOpenCloseButton.ɵfac = function ClrPopoverOpenCloseButton_Factory(t) { return new (t || ClrPopoverOpenCloseButton)(ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService)); };
ClrPopoverOpenCloseButton.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrPopoverOpenCloseButton, selectors: [["", "clrPopoverOpenCloseButton", ""]], hostVars: 2, hostBindings: function ClrPopoverOpenCloseButton_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrPopoverOpenCloseButton_click_HostBindingHandler($event) { return ctx.handleClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-smart-open-close", true);
    } }, outputs: { openCloseChange: "clrPopoverOpenCloseChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverOpenCloseButton, [{
        type: core.Directive,
        args: [{
                selector: '[clrPopoverOpenCloseButton]',
                host: {
                    '[class.clr-smart-open-close]': 'true'
                }
            }]
    }], function () { return [{ type: ClrPopoverToggleService }]; }, { openCloseChange: [{
            type: core.Output,
            args: ['clrPopoverOpenCloseChange']
        }], handleClick: [{
            type: core.HostListener,
            args: ['click', ['$event']]
        }] }); })();
        return ClrPopoverOpenCloseButton;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var ClrPopoverCloseButton = /** @class */ (function () {
        function ClrPopoverCloseButton(elementRef, smartEventsService, smartOpenService) {
            var _this = this;
            this.elementRef = elementRef;
            this.smartEventsService = smartEventsService;
            this.smartOpenService = smartOpenService;
            this.subscriptions = [];
            this.closeChange = new core.EventEmitter();
            this.subscriptions.push(smartOpenService.openChange.pipe(operators.filter(function (value) { return !value; })).subscribe(function () {
                _this.closeChange.next();
            }));
        }
        ClrPopoverCloseButton.prototype.handleClick = function (event) {
            this.smartOpenService.toggleWithEvent(event);
            this.smartEventsService.setAnchorFocus();
        };
        ClrPopoverCloseButton.prototype.ngAfterViewInit = function () {
            this.smartEventsService.closeButtonRef = this.elementRef;
            this.smartEventsService.setCloseFocus();
        };
        ClrPopoverCloseButton.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrPopoverCloseButton.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: ClrPopoverEventsService },
            { type: ClrPopoverToggleService }
        ]; };
        __decorate([
            core.Output('clrPopoverOnCloseChange')
        ], ClrPopoverCloseButton.prototype, "closeChange", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], ClrPopoverCloseButton.prototype, "handleClick", null);
ClrPopoverCloseButton.ɵfac = function ClrPopoverCloseButton_Factory(t) { return new (t || ClrPopoverCloseButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ClrPopoverEventsService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService)); };
ClrPopoverCloseButton.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrPopoverCloseButton, selectors: [["", "clrPopoverCloseButton", ""]], hostVars: 2, hostBindings: function ClrPopoverCloseButton_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrPopoverCloseButton_click_HostBindingHandler($event) { return ctx.handleClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-smart-close-button", true);
    } }, outputs: { closeChange: "clrPopoverOnCloseChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverCloseButton, [{
        type: core.Directive,
        args: [{
                selector: '[clrPopoverCloseButton]',
                host: {
                    '[class.clr-smart-close-button]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ClrPopoverEventsService }, { type: ClrPopoverToggleService }]; }, { closeChange: [{
            type: core.Output,
            args: ['clrPopoverOnCloseChange']
        }], handleClick: [{
            type: core.HostListener,
            args: ['click', ['$event']]
        }] }); })();
        return ClrPopoverCloseButton;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var ClrPopoverAnchor = /** @class */ (function () {
        function ClrPopoverAnchor(smartEventService, element) {
            smartEventService.anchorButtonRef = element;
        }
        ClrPopoverAnchor.ctorParameters = function () { return [
            { type: ClrPopoverEventsService },
            { type: core.ElementRef }
        ]; };
ClrPopoverAnchor.ɵfac = function ClrPopoverAnchor_Factory(t) { return new (t || ClrPopoverAnchor)(ɵngcc0.ɵɵdirectiveInject(ClrPopoverEventsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrPopoverAnchor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrPopoverAnchor, selectors: [["", "clrPopoverAnchor", ""]], hostVars: 2, hostBindings: function ClrPopoverAnchor_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-anchor", true);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverAnchor, [{
        type: core.Directive,
        args: [{
                selector: '[clrPopoverAnchor]',
                host: {
                    '[class.clr-anchor]': 'true'
                }
            }]
    }], function () { return [{ type: ClrPopoverEventsService }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrPopoverAnchor;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var ClrPopoverModuleNext = /** @class */ (function () {
        function ClrPopoverModuleNext() {
        }
ClrPopoverModuleNext.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrPopoverModuleNext });
ClrPopoverModuleNext.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrPopoverModuleNext_Factory(t) { return new (t || ClrPopoverModuleNext)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrPopoverModuleNext, { declarations: [ClrPopoverAnchor,
        ClrPopoverCloseButton,
        ClrPopoverOpenCloseButton,
        ClrPopoverContent], exports: [ClrPopoverAnchor,
        ClrPopoverCloseButton,
        ClrPopoverOpenCloseButton,
        ClrPopoverContent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverModuleNext, [{
        type: core.NgModule,
        args: [{
                imports: [],
                declarations: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
                exports: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent]
            }]
    }], function () { return []; }, null); })();
        return ClrPopoverModuleNext;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
     * This does not mean you should extend it, simply implementing it is fine.
     */
    var LoadingListener = /** @class */ (function () {
        function LoadingListener() {
        }
        return LoadingListener;
    }());


    (function (ClrLoadingState) {
        ClrLoadingState[ClrLoadingState["DEFAULT"] = 0] = "DEFAULT";
        ClrLoadingState[ClrLoadingState["LOADING"] = 1] = "LOADING";
        ClrLoadingState[ClrLoadingState["SUCCESS"] = 2] = "SUCCESS";
        ClrLoadingState[ClrLoadingState["ERROR"] = 3] = "ERROR";
    })(exports.ClrLoadingState || (exports.ClrLoadingState = {}));
    var ClrLoading = /** @class */ (function () {
        // We find the first parent that handles something loading
        function ClrLoading(listener) {
            this.listener = listener;
            this._loadingState = exports.ClrLoadingState.DEFAULT;
        }
        Object.defineProperty(ClrLoading.prototype, "loadingState", {
            get: function () {
                return this._loadingState;
            },
            set: function (value) {
                if (value === true) {
                    value = exports.ClrLoadingState.LOADING;
                }
                else if (!value) {
                    value = exports.ClrLoadingState.DEFAULT;
                }
                if (value === this._loadingState) {
                    return;
                }
                this._loadingState = value;
                if (this.listener) {
                    this.listener.loadingStateChange(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrLoading.prototype.ngOnDestroy = function () {
            this.loadingState = exports.ClrLoadingState.DEFAULT;
        };
        ClrLoading.ctorParameters = function () { return [
            { type: LoadingListener, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input('clrLoading')
        ], ClrLoading.prototype, "loadingState", null);
        ClrLoading = __decorate([ __param(0, core.Optional())
        ], ClrLoading);
ClrLoading.ɵfac = function ClrLoading_Factory(t) { return new (t || ClrLoading)(ɵngcc0.ɵɵdirectiveInject(LoadingListener, 8)); };
ClrLoading.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrLoading, selectors: [["", "clrLoading", ""]], inputs: { loadingState: ["clrLoading", "loadingState"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLoading, [{
        type: core.Directive,
        args: [{ selector: '[clrLoading]' }]
    }], function () { return [{ type: LoadingListener, decorators: [{
                type: core.Optional
            }] }]; }, { loadingState: [{
            type: core.Input,
            args: ['clrLoading']
        }] }); })();
        return ClrLoading;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ButtonInGroupService = /** @class */ (function () {
        function ButtonInGroupService() {
            this._changes = new rxjs.Subject();
        }
        Object.defineProperty(ButtonInGroupService.prototype, "changes", {
            get: function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        ButtonInGroupService.prototype.updateButtonGroup = function (button) {
            this._changes.next(button);
        };
ButtonInGroupService.ɵfac = function ButtonInGroupService_Factory(t) { return new (t || ButtonInGroupService)(); };
ButtonInGroupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ButtonInGroupService, factory: function (t) { return ButtonInGroupService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ButtonInGroupService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ButtonInGroupService;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrButton = /** @class */ (function () {
        function ClrButton(buttonInGroupService, toggleService) {
            this.buttonInGroupService = buttonInGroupService;
            this.toggleService = toggleService;
            this._enableService = false;
            this._inMenu = false;
            this._classNames = 'btn';
            this._name = null;
            this._type = null;
            this._id = null;
            this._disabled = null;
            this._click = new core.EventEmitter(false);
        }
        ClrButton_1 = ClrButton;
        Object.defineProperty(ClrButton.prototype, "inMenu", {
            get: function () {
                return this._inMenu;
            },
            set: function (value) {
                value = !!value;
                if (this._inMenu !== value) {
                    this._inMenu = value;
                    // We check if the service flag is enabled
                    // and if the service exists because the service is optional
                    if (this._enableService && this.buttonInGroupService) {
                        this.buttonInGroupService.updateButtonGroup(this);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "classNames", {
            get: function () {
                return this._classNames;
            },
            set: function (value) {
                if (typeof value === 'string') {
                    var classNames = value.split(' ');
                    if (classNames.indexOf('btn') === -1) {
                        classNames.push('btn');
                    }
                    this._classNames = classNames.join(' ');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (value) {
                if (typeof value === 'string') {
                    this._name = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (value) {
                if (typeof value === 'string') {
                    this._type = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                if (typeof value === 'string') {
                    this._id = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "disabled", {
            get: function () {
                return this._disabled;
            },
            set: function (value) {
                if (value !== null && value !== false) {
                    this._disabled = '';
                }
                else {
                    this._disabled = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrButton.prototype.loadingStateChange = function (state) {
            this.loading = state === exports.ClrLoadingState.LOADING;
        };
        ClrButton.prototype.emitClick = function ($event) {
            if (this.inMenu) {
                this.toggleService.toggleWithEvent($event);
            }
            this._click.emit(true);
        };
        ClrButton.prototype.ngAfterViewInit = function () {
            this._enableService = true;
        };
        var ClrButton_1;
        ClrButton.ctorParameters = function () { return [
            { type: ButtonInGroupService, decorators: [{ type: core.SkipSelf }, { type: core.Optional }] },
            { type: ClrPopoverToggleService }
        ]; };
        __decorate([
            core.ViewChild('buttonProjectedRef', { static: true })
        ], ClrButton.prototype, "templateRef", void 0);
        __decorate([
            core.Input('clrInMenu')
        ], ClrButton.prototype, "inMenu", null);
        __decorate([
            core.Input('class')
        ], ClrButton.prototype, "classNames", null);
        __decorate([
            core.Input('name')
        ], ClrButton.prototype, "name", null);
        __decorate([
            core.Input('type')
        ], ClrButton.prototype, "type", null);
        __decorate([
            core.Input('id')
        ], ClrButton.prototype, "id", null);
        __decorate([
            core.Input('disabled')
        ], ClrButton.prototype, "disabled", null);
        __decorate([
            core.Output('click')
        ], ClrButton.prototype, "_click", void 0);
        ClrButton = ClrButton_1 = __decorate([ __param(0, core.SkipSelf()),
            __param(0, core.Optional())
        ], ClrButton);
ClrButton.ɵfac = function ClrButton_Factory(t) { return new (t || ClrButton)(ɵngcc0.ɵɵdirectiveInject(ButtonInGroupService, 12), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService)); };
ClrButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrButton, selectors: [["clr-button"]], viewQuery: function ClrButton_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, inputs: { inMenu: ["clrInMenu", "inMenu"], classNames: ["class", "classNames"], name: "name", type: "type", id: "id", disabled: "disabled" }, outputs: { _click: "click" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: LoadingListener, useExisting: ClrButton_1 }])], ngContentSelectors: _c1, decls: 2, vars: 0, consts: [["buttonProjectedRef", ""], [3, "click"], ["class", "spinner spinner-inline", 4, "ngIf"], [1, "spinner", "spinner-inline"]], template: function ClrButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrButton_ng_template_0_Template, 3, 7, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrButton, [{
        type: core.Component,
        args: [{
                selector: 'clr-button',
                template: "\n        <ng-template #buttonProjectedRef>\n            <button\n                [class]=\"classNames\"\n                (click)=\"emitClick($event)\"\n                [attr.type]=\"type\"\n                [attr.name]=\"name\"\n                [attr.disabled]=\"disabled\"\n                [attr.id]=\"id\">\n                <span class=\"spinner spinner-inline\" *ngIf=\"loading\"></span>\n                <ng-content></ng-content>\n            </button>\n        </ng-template>\n    ",
                providers: [{ provide: LoadingListener, useExisting: ClrButton_1 }]
            }]
    }], function () { return [{ type: ButtonInGroupService, decorators: [{
                type: core.SkipSelf
            }, {
                type: core.Optional
            }] }, { type: ClrPopoverToggleService }]; }, { _click: [{
            type: core.Output,
            args: ['click']
        }], inMenu: [{
            type: core.Input,
            args: ['clrInMenu']
        }], classNames: [{
            type: core.Input,
            args: ['class']
        }], name: [{
            type: core.Input,
            args: ['name']
        }], type: [{
            type: core.Input,
            args: ['type']
        }], id: [{
            type: core.Input,
            args: ['id']
        }], disabled: [{
            type: core.Input,
            args: ['disabled']
        }], templateRef: [{
            type: core.ViewChild,
            args: ['buttonProjectedRef', { static: true }]
        }] }); })();
        return ClrButton;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var commonStringsDefault = {
        open: 'Open',
        close: 'Close',
        show: 'Show',
        hide: 'Hide',
        expand: 'Expand',
        collapse: 'Collapse',
        more: 'More',
        select: 'Select',
        selectAll: 'Select All',
        previous: 'Previous',
        next: 'Next',
        current: 'Jump to current',
        info: 'Info',
        success: 'Success',
        warning: 'Warning',
        danger: 'Error',
        rowActions: 'Available actions',
        pickColumns: 'Show or hide columns',
        showColumns: 'Show Columns',
        sortColumn: 'Sort Column',
        firstPage: 'First Page',
        lastPage: 'Last Page',
        nextPage: 'Next Page',
        previousPage: 'Previous Page',
        currentPage: 'Current Page',
        totalPages: 'Total Pages',
        minValue: 'Min value',
        maxValue: 'Max value',
        modalContentStart: 'Beginning of Modal Content',
        modalContentEnd: 'End of Modal Content',
        showColumnsMenuDescription: 'Show or hide columns menu',
        allColumnsSelected: 'All columns selected',
        signpostToggle: 'Signpost Toggle',
        signpostClose: 'Signpost Close',
        loading: 'Loading',
        // Datagrid
        detailPaneStart: 'Start of row details',
        detailPaneEnd: 'End of row details',
        singleSelectionAriaLabel: 'Single selection header',
        singleActionableAriaLabel: 'Single actionable header',
        detailExpandableAriaLabel: 'Toggle more row content',
        datagridFilterAriaLabel: 'Toggle column filter',
        // Alert
        alertCloseButtonAriaLabel: 'Close alert',
        // Date Picker
        datepickerToggle: 'Toggle datepicker',
        datepickerPreviousMonth: 'Previous month',
        datepickerCurrentMonth: 'Current month',
        datepickerNextMonth: 'Next month',
        datepickerPreviousDecade: 'Previous decade',
        datepickerNextDecade: 'Next decade',
        datepickerCurrentDecade: 'Current decade',
        datepickerSelectMonthText: 'Select month, the current month is {CALENDAR_MONTH}',
        datepickerSelectYearText: 'Select year, the current year is {CALENDAR_YEAR}',
        daypickerSRCurrentMonthPhrase: 'The current month is {CURRENT_MONTH}',
        daypickerSRCurrentYearPhrase: 'The current year is {CURRENT_YEAR}',
        daypickerSRCurrentDecadePhrase: 'The current decade is {DECADE_RANGE}',
        // Stack View
        stackViewChanged: 'Value changed.',
        // Forms
        formErrorSummary: 'The form has {ERROR_NUMBER} errors.',
        //Vertical Nav
        verticalNavToggle: 'Toggle vertical navigation',
        verticalNavGroupToggle: 'Toggle vertical navigation group',
        // Timeline steps
        timelineStepNotStarted: 'Not started',
        timelineStepCurrent: 'Current',
        timelineStepSuccess: 'Completed',
        timelineStepError: 'Error',
        timelineStepProcessing: 'In progress',
        // Datagrid expandable rows
        dategridExpandableBeginningOf: 'Beginning of',
        dategridExpandableEndOf: 'End of',
        dategridExpandableRowContent: 'Expandable row content',
        dategridExpandableRowsHelperText: "Screen reader table commands may not work for viewing expanded content, please use your screen reader's browse mode to read the content exposed by this button",
    };

    var ClrCommonStringsService = /** @class */ (function () {
        function ClrCommonStringsService() {
            this._strings = commonStringsDefault;
        }
        /**
         * Allows you to pass in new overrides for localization
         */
        ClrCommonStringsService.prototype.localize = function (overrides) {
            this._strings = __assign(__assign({}, this._strings), overrides);
        };
        Object.defineProperty(ClrCommonStringsService.prototype, "keys", {
            /**
             * Access to all of the keys as strings
             */
            get: function () {
                return this._strings;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Parse a string with a set of tokens to replace
         */
        ClrCommonStringsService.prototype.parse = function (source, tokens) {
            if (tokens === void 0) { tokens = {}; }
            var names = Object.keys(tokens);
            var output = source;
            if (names.length) {
                names.forEach(function (name) {
                    output = output.replace("{" + name + "}", tokens[name]);
                });
            }
            return output;
        };
        ClrCommonStringsService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function ClrCommonStringsService_Factory() { return new ClrCommonStringsService(); }, token: ClrCommonStringsService, providedIn: "root" });
ClrCommonStringsService.ɵfac = function ClrCommonStringsService_Factory(t) { return new (t || ClrCommonStringsService)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCommonStringsService, [{
        type: core.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
        return ClrCommonStringsService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var NB_INSTANCES = 0;
    var UNIQUE_ID = new core.InjectionToken('UNIQUE_ID');
    function uniqueIdFactory() {
        return 'clr-id-' + NB_INSTANCES++;
    }
    var UNIQUE_ID_PROVIDER = {
        provide: UNIQUE_ID,
        useFactory: uniqueIdFactory,
    };

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */

    (function (ClrSide) {
        ClrSide[ClrSide["BEFORE"] = -1] = "BEFORE";
        ClrSide[ClrSide["AFTER"] = 1] = "AFTER";
    })(exports.ClrSide || (exports.ClrSide = {}));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var ClrPopoverPositions = /** @class */ (function () {
        function ClrPopoverPositions() {
        }
        ClrPopoverPositions['top-right'] = {
            axis: exports.ClrAxis.VERTICAL,
            side: exports.ClrSide.BEFORE,
            anchor: exports.ClrAlignment.END,
            content: exports.ClrAlignment.END,
        };
        ClrPopoverPositions['top-left'] = {
            axis: exports.ClrAxis.VERTICAL,
            side: exports.ClrSide.BEFORE,
            anchor: exports.ClrAlignment.START,
            content: exports.ClrAlignment.START,
        };
        ClrPopoverPositions['bottom-right'] = {
            axis: exports.ClrAxis.VERTICAL,
            side: exports.ClrSide.AFTER,
            anchor: exports.ClrAlignment.END,
            content: exports.ClrAlignment.END,
        };
        ClrPopoverPositions['bottom-left'] = {
            axis: exports.ClrAxis.VERTICAL,
            side: exports.ClrSide.AFTER,
            anchor: exports.ClrAlignment.START,
            content: exports.ClrAlignment.START,
        };
        ClrPopoverPositions['right-top'] = {
            axis: exports.ClrAxis.HORIZONTAL,
            side: exports.ClrSide.AFTER,
            anchor: exports.ClrAlignment.CENTER,
            content: exports.ClrAlignment.END,
        };
        ClrPopoverPositions['right-bottom'] = {
            axis: exports.ClrAxis.HORIZONTAL,
            side: exports.ClrSide.AFTER,
            anchor: exports.ClrAlignment.START,
            content: exports.ClrAlignment.START,
        };
        ClrPopoverPositions['left-top'] = {
            axis: exports.ClrAxis.HORIZONTAL,
            side: exports.ClrSide.BEFORE,
            anchor: exports.ClrAlignment.CENTER,
            content: exports.ClrAlignment.END,
        };
        ClrPopoverPositions['left-bottom'] = {
            axis: exports.ClrAxis.HORIZONTAL,
            side: exports.ClrSide.BEFORE,
            anchor: exports.ClrAlignment.START,
            content: exports.ClrAlignment.START,
        };
        return ClrPopoverPositions;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrButtonGroup = /** @class */ (function () {
        function ClrButtonGroup(buttonGroupNewService, toggleService, popoverId, commonStrings) {
            this.buttonGroupNewService = buttonGroupNewService;
            this.toggleService = toggleService;
            this.popoverId = popoverId;
            this.commonStrings = commonStrings;
            this.popoverPosition = ClrPopoverPositions['bottom-left'];
            this.inlineButtons = [];
            this.menuButtons = [];
        }
        Object.defineProperty(ClrButtonGroup.prototype, "open", {
            get: function () {
                return this.toggleService.open;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         */
        ClrButtonGroup.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.initializeButtons();
            this.buttonGroupNewService.changes.subscribe(function (button) { return _this.rearrangeButton(button); });
            this.buttons.changes.subscribe(function () {
                _this.initializeButtons();
            });
        };
        /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param button
         */
        ClrButtonGroup.prototype.rearrangeButton = function (button) {
            var fromView;
            var toView;
            if (button.inMenu) {
                fromView = this.inlineButtons;
                toView = this.menuButtons;
            }
            else {
                fromView = this.menuButtons;
                toView = this.inlineButtons;
            }
            var index = fromView.indexOf(button);
            if (index > -1) {
                fromView.splice(index, 1);
                var moveIndex = this.getMoveIndex(button);
                if (moveIndex <= toView.length) {
                    toView.splice(moveIndex, 0, button);
                }
            }
        };
        /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param buttonToMove
         * @returns
         */
        ClrButtonGroup.prototype.getMoveIndex = function (buttonToMove) {
            var tempArr = this.buttons.filter(function (button) { return button.inMenu === buttonToMove.inMenu; });
            return tempArr.indexOf(buttonToMove);
        };
        ClrButtonGroup.prototype.initializeButtons = function () {
            var tempInlineButtons = [];
            var tempInMenuButtons = [];
            this.buttons.forEach(function (button) {
                if (button.inMenu) {
                    tempInMenuButtons.push(button);
                }
                else {
                    tempInlineButtons.push(button);
                }
            });
            this.inlineButtons = tempInlineButtons;
            this.menuButtons = tempInMenuButtons;
        };
        Object.defineProperty(ClrButtonGroup.prototype, "menuPosition", {
            get: function () {
                return this._menuPosition;
            },
            set: function (pos) {
                if (pos && ClrPopoverPositions[pos]) {
                    this._menuPosition = pos;
                }
                else {
                    this._menuPosition = 'bottom-left';
                }
                this.popoverPosition = ClrPopoverPositions[this._menuPosition];
            },
            enumerable: true,
            configurable: true
        });
        ClrButtonGroup.ctorParameters = function () { return [
            { type: ButtonInGroupService },
            { type: ClrPopoverToggleService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.ContentChildren(ClrButton)
        ], ClrButtonGroup.prototype, "buttons", void 0);
        __decorate([
            core.Input('clrMenuPosition')
        ], ClrButtonGroup.prototype, "menuPosition", null);
        ClrButtonGroup = __decorate([ __param(2, core.Inject(UNIQUE_ID))
        ], ClrButtonGroup);
ClrButtonGroup.ɵfac = function ClrButtonGroup_Factory(t) { return new (t || ClrButtonGroup)(ɵngcc0.ɵɵdirectiveInject(ButtonInGroupService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrButtonGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrButtonGroup, selectors: [["clr-button-group"]], contentQueries: function ClrButtonGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrButton, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.buttons = _t);
    } }, hostVars: 2, hostBindings: function ClrButtonGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("btn-group", true);
    } }, inputs: { menuPosition: ["clrMenuPosition", "menuPosition"] }, features: [ɵngcc0.ɵɵProvidersFeature([
            ButtonInGroupService,
            UNIQUE_ID_PROVIDER,
            ClrPopoverToggleService,
            ClrPopoverEventsService,
            ClrPopoverPositionService,
        ])], decls: 4, vars: 2, consts: [[4, "ngFor", "ngForOf"], [4, "ngIf"], ["ref", ""], [3, "ngTemplateOutlet"], [1, "btn-group-overflow", "open", 3, "ngClass"], ["anchor", ""], ["clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "btn", "dropdown-toggle"], ["shape", "ellipsis-horizontal"], ["role", "menu", "class", "dropdown-menu clr-button-group-menu", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "menu", 1, "dropdown-menu", "clr-button-group-menu", 3, "id"]], template: function ClrButtonGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ClrButtonGroup_ng_container_0_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, ClrButtonGroup_ng_container_1_Template, 6, 9, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, ClrButtonGroup_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.inlineButtons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuButtons.length > 0);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass, ClrPopoverAnchor,
        ClrPopoverOpenCloseButton,
        ClrIconCustomTag,
        ClrPopoverContent], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrButtonGroup, [{
        type: core.Component,
        args: [{
                selector: 'clr-button-group',
                template: "<!--\n  ~ Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-container *ngFor=\"let inlineButton of inlineButtons\">\n    <ng-template [ngTemplateOutlet]=\"inlineButton.templateRef\"></ng-template>\n</ng-container>\n<ng-container *ngIf=\"menuButtons.length > 0\">\n    <div\n        class=\"btn-group-overflow open\"\n        [ngClass]=\"menuPosition\"\n        #anchor>\n        <button\n            class=\"btn dropdown-toggle\"\n            clrPopoverAnchor\n            clrPopoverOpenCloseButton\n            [attr.aria-controls]=\"popoverId\"\n            [attr.aria-expanded]=\"open\"\n            [attr.aria-label]=\"commonStrings.keys.rowActions\">\n            <clr-icon shape=\"ellipsis-horizontal\" [attr.title]=\"commonStrings.keys.more\"></clr-icon>\n        </button>\n        <div\n            role=\"menu\" \n            class=\"dropdown-menu clr-button-group-menu\"\n            [id]=\"popoverId\"\n            [attr.id]=\"popoverId\"\n            [attr.aria-hidden]=\"!open\"\n            *clrPopoverContent=\"open at popoverPosition; outsideClickToClose: true; scrollToClose: true\">\n            <ng-template [ngTemplateOutlet]=\"ref\"></ng-template>\n        </div>\n    </div>\n</ng-container>\n<ng-template #ref>\n    <ng-container *ngFor=\"let menuButton of menuButtons\">\n        <ng-template [ngTemplateOutlet]=\"menuButton.templateRef\"></ng-template>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    ButtonInGroupService,
                    UNIQUE_ID_PROVIDER,
                    ClrPopoverToggleService,
                    ClrPopoverEventsService,
                    ClrPopoverPositionService,
                ],
                host: { '[class.btn-group]': 'true' }
            }]
    }], function () { return [{ type: ButtonInGroupService }, { type: ClrPopoverToggleService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: ClrCommonStringsService }]; }, { menuPosition: [{
            type: core.Input,
            args: ['clrMenuPosition']
        }], buttons: [{
            type: core.ContentChildren,
            args: [ClrButton]
        }] }); })();
        return ClrButtonGroup;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
    var ClrButtonGroupModule = /** @class */ (function () {
        function ClrButtonGroupModule() {
        }
ClrButtonGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrButtonGroupModule });
ClrButtonGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrButtonGroupModule_Factory(t) { return new (t || ClrButtonGroupModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrPopoverModuleNext]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrButtonGroupModule, { declarations: [ClrButton,
        ClrButtonGroup], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrPopoverModuleNext], exports: [ClrButton,
        ClrButtonGroup] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrButtonGroupModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrPopoverModuleNext],
                declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
                exports: [CLR_BUTTON_GROUP_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrButtonGroupModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrLoadingButton = /** @class */ (function () {
        function ClrLoadingButton(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.buttonState = exports.ClrLoadingState;
            this.state = exports.ClrLoadingState.DEFAULT;
            this.clrLoadingChange = new core.EventEmitter(false);
        }
        ClrLoadingButton_1 = ClrLoadingButton;
        ClrLoadingButton.prototype.loadingStateChange = function (state) {
            if (state === this.state) {
                return;
            }
            this.state = state;
            switch (state) {
                case exports.ClrLoadingState.DEFAULT:
                    this.renderer.removeStyle(this.el.nativeElement, 'width');
                    this.renderer.removeStyle(this.el.nativeElement, 'transform'); // for chromium render bug see issue https://github.com/vmware/clarity/issues/2700
                    if (!this.disabled) {
                        this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                    }
                    break;
                case exports.ClrLoadingState.LOADING:
                    this.setExplicitButtonWidth();
                    this.renderer.setStyle(this.el.nativeElement, 'transform', 'translatez(0)'); // for chromium render bug see issue https://github.com/vmware/clarity/issues/2700
                    this.renderer.setAttribute(this.el.nativeElement, 'disabled', '');
                    break;
                case exports.ClrLoadingState.SUCCESS:
                    this.setExplicitButtonWidth();
                    break;
                case exports.ClrLoadingState.ERROR:
                    this.loadingStateChange(exports.ClrLoadingState.DEFAULT);
                    break;
                default:
                    break;
            }
            this.clrLoadingChange.emit(state);
        };
        ClrLoadingButton.prototype.setExplicitButtonWidth = function () {
            if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
                var boundingClientRect = this.el.nativeElement.getBoundingClientRect();
                this.renderer.setStyle(this.el.nativeElement, 'width', boundingClientRect.width + "px");
            }
        };
        var ClrLoadingButton_1;
        ClrLoadingButton.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.Input('disabled')
        ], ClrLoadingButton.prototype, "disabled", void 0);
        __decorate([
            core.Output('clrLoadingChange')
        ], ClrLoadingButton.prototype, "clrLoadingChange", void 0);
ClrLoadingButton.ɵfac = function ClrLoadingButton_Factory(t) { return new (t || ClrLoadingButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ClrLoadingButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrLoadingButton, selectors: [["button", "clrLoading", ""]], hostVars: 1, hostBindings: function ClrLoadingButton_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("disabled", ctx.disabled ? "" : null);
    } }, inputs: { disabled: "disabled" }, outputs: { clrLoadingChange: "clrLoadingChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: LoadingListener, useExisting: ClrLoadingButton_1 }])], attrs: _c2, ngContentSelectors: _c1, decls: 4, vars: 4, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [1, "spinner", "spinner-inline"], [1, "spinner", "spinner-inline", "spinner-check"]], template: function ClrLoadingButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, ClrLoadingButton_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, ClrLoadingButton_span_2_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵtemplate(3, ClrLoadingButton_span_3_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.state);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.buttonState.LOADING);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.buttonState.SUCCESS);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.buttonState.DEFAULT);
    } }, directives: [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase], encapsulation: 2, data: { animation: [
            animations.trigger('defaultButton', [
                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                // TODO: see if we can get leave animation to work before spinner's enter animation
                animations.transition(':leave', [animations.style({ opacity: 0 })]),
            ]),
            animations.trigger('spinner', [
                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
            ]),
            animations.trigger('validated', [
                animations.transition(':enter', [
                    animations.animate('600ms', animations.keyframes([
                        animations.style({ transform: 'scale(0,0)', offset: 0 }),
                        animations.style({ opacity: 1, offset: 0.2 }),
                        animations.style({ transform: 'scale(1.2,1.2)', offset: 0.4 }),
                        animations.style({ transform: 'scale(.9,.9)', offset: 0.6 }),
                        animations.style({ transform: 'scale(1,1)', offset: 1 }),
                    ])),
                ]),
                animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLoadingButton, [{
        type: core.Component,
        args: [{
                selector: 'button[clrLoading]',
                template: "\n        <ng-container [ngSwitch]=\"state\">\n            <span *ngSwitchCase=\"buttonState.LOADING\">\n                <span @spinner class=\"spinner spinner-inline\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.SUCCESS\">\n                <span @validated (@validated.done)=\"this.loadingStateChange(this.buttonState.DEFAULT)\" class=\"spinner spinner-inline spinner-check\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.DEFAULT\" @defaultButton>\n                <ng-content></ng-content>\n            </span>\n        </ng-container>\n    ",
                providers: [{ provide: LoadingListener, useExisting: ClrLoadingButton_1 }],
                animations: [
                    animations.trigger('defaultButton', [
                        animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                        // TODO: see if we can get leave animation to work before spinner's enter animation
                        animations.transition(':leave', [animations.style({ opacity: 0 })]),
                    ]),
                    animations.trigger('spinner', [
                        animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                        animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
                    ]),
                    animations.trigger('validated', [
                        animations.transition(':enter', [
                            animations.animate('600ms', animations.keyframes([
                                animations.style({ transform: 'scale(0,0)', offset: 0 }),
                                animations.style({ opacity: 1, offset: 0.2 }),
                                animations.style({ transform: 'scale(1.2,1.2)', offset: 0.4 }),
                                animations.style({ transform: 'scale(.9,.9)', offset: 0.6 }),
                                animations.style({ transform: 'scale(1,1)', offset: 1 }),
                            ])),
                        ]),
                        animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
                    ]),
                ],
                host: { '[attr.disabled]': "disabled? '' : null" }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { clrLoadingChange: [{
            type: core.Output,
            args: ['clrLoadingChange']
        }], disabled: [{
            type: core.Input,
            args: ['disabled']
        }] }); })();
        return ClrLoadingButton;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
    var ClrLoadingButtonModule = /** @class */ (function () {
        function ClrLoadingButtonModule() {
        }
ClrLoadingButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrLoadingButtonModule });
ClrLoadingButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrLoadingButtonModule_Factory(t) { return new (t || ClrLoadingButtonModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrLoadingButtonModule, { declarations: [ClrLoadingButton], imports: [ɵngcc1.CommonModule], exports: [ClrLoadingButton] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLoadingButtonModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
                exports: [CLR_LOADING_BUTTON_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrLoadingButtonModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrButtonModule = /** @class */ (function () {
        function ClrButtonModule() {
        }
ClrButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrButtonModule });
ClrButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrButtonModule_Factory(t) { return new (t || ClrButtonModule)(); }, imports: [ClrLoadingButtonModule,
        ClrButtonGroupModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrButtonModule, { exports: [ClrLoadingButtonModule,
        ClrButtonGroupModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrButtonModule, [{
        type: core.NgModule,
        args: [{
                exports: [ClrLoadingButtonModule, ClrButtonGroupModule]
            }]
    }], function () { return []; }, null); })();
        return ClrButtonModule;
    }());

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var EmptyAnchor = /** @class */ (function () {
        function EmptyAnchor() {
        }
EmptyAnchor.ɵfac = function EmptyAnchor_Factory(t) { return new (t || EmptyAnchor)(); };
EmptyAnchor.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EmptyAnchor, selectors: [["ng-component"]], decls: 0, vars: 0, template: function EmptyAnchor_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmptyAnchor, [{
        type: core.Component,
        args: [{
                template: ''
            }]
    }], function () { return []; }, null); })();
        return EmptyAnchor;
    }());

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Internal module, please do not export!
     */
    var ClrHostWrappingModule = /** @class */ (function () {
        function ClrHostWrappingModule() {
        }
ClrHostWrappingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrHostWrappingModule });
ClrHostWrappingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrHostWrappingModule_Factory(t) { return new (t || ClrHostWrappingModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrHostWrappingModule, { declarations: [EmptyAnchor], exports: [EmptyAnchor] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrHostWrappingModule, [{
        type: core.NgModule,
        args: [{ declarations: [EmptyAnchor], exports: [EmptyAnchor], entryComponents: [EmptyAnchor] }]
    }], function () { return []; }, null); })();
        return ClrHostWrappingModule;
    }());

    var counter = 0;
    var ControlIdService = /** @class */ (function () {
        function ControlIdService() {
            this._id = 'clr-form-control-' + ++counter;
            this._idChange = new rxjs.BehaviorSubject(this._id);
        }
        Object.defineProperty(ControlIdService.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
                this._idChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControlIdService.prototype, "idChange", {
            get: function () {
                return this._idChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
ControlIdService.ɵfac = function ControlIdService_Factory(t) { return new (t || ControlIdService)(); };
ControlIdService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ControlIdService, factory: function (t) { return ControlIdService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ControlIdService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ControlIdService;
    }());


    (function (ClrAriaLivePoliteness) {
        ClrAriaLivePoliteness["off"] = "off";
        ClrAriaLivePoliteness["polite"] = "polite";
        ClrAriaLivePoliteness["assertive"] = "assertive";
    })(exports.ClrAriaLivePoliteness || (exports.ClrAriaLivePoliteness = {}));
    /**
     * Time in milliseconds before inserting the content into the container
     */
    var ARIA_LIVE_TICK = 100;
    /**
     * This service handle `aria-live` accessibility attribute. The issue is that you need
     * to have the DOM Element with attribute `aria-live` before you could insert content
     * and SR (Screen Reader) pick the change and announce it.
     *
     * ```typescript
     * import { ClrAriaLiveService } from 'src/clr-angular/utils/a11y/aria-live.service';
     *
     * @Component({
     * selector: 'clr-demo-component',
     * providers: [ClrAriaLiveService],
     * template: `
     *   <ng-content></ng-content>
     * `,
     * })
     * export class DemoComponent {
     *  constructor(ariaLiveService: ClrAriaLiveService) {}
     *
     *  public actionThatWillTriggerChange() {
     *    this.ariaLiveService.announce('message that I want to announce to SR');
     *  }
     * }
     * ```
     *
     */
    var ClrAriaLiveService = /** @class */ (function () {
        function ClrAriaLiveService(ngZone, _document, platformId) {
            this.ngZone = ngZone;
            this.platformId = platformId;
            this._id = "clr-aria-live-element-" + uniqueIdFactory();
            this.document = _document;
        }
        Object.defineProperty(ClrAriaLiveService.prototype, "id", {
            /**
             * get access to the internal HTML `id` that gonna be used for the AriaLive container.
             * @return ID of the DOM Element as string.
             */
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Append text content inside the AriaLive Container. This method will check if the
         * DOM Element is existing if not it will create one for us and the will apply the text.
         *
         * ```typescript
         * this.ariaLiveService.announce(this.el.nativeElement);
         * // or
         * this.ariaLiveService.announce('Message to announce to SR');
         * ```
         *
         * @remark
         * When second argument is `AriaLivePoliteness.off` we won't create aria container or update it.
         * The reason for that is that we don't want to do additional work if the SR will ignore it.
         *
         * @param message - This could be simple string or HTMLElement
         * @param politeness - 'polite', 'assertive' or 'off'
         */
        ClrAriaLiveService.prototype.announce = function (message, politeness) {
            var _this = this;
            if (politeness === void 0) { politeness = exports.ClrAriaLivePoliteness.polite; }
            if (politeness === exports.ClrAriaLivePoliteness.off) {
                return;
            }
            if (!this.ariaLiveElement && common.isPlatformBrowser(this.platformId)) {
                this.ariaLiveElement = this.createContainer();
            }
            message = typeof message !== 'string' && common.isPlatformBrowser(this.platformId) ? message.textContent : message;
            // when there is no message do NOTHING!
            if (!message) {
                return;
            }
            this.ariaLiveElement.setAttribute('aria-live', politeness);
            // This 100ms timeout is necessary for some browser + screen-reader combinations:
            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
            //   second time without clearing and then using a non-zero delay.
            // (using JAWS 17 at time of this writing).
            this.ngZone.runOutsideAngular(function () {
                // This clearTimeout will stop all older messages from announcing
                // in the case where the messages are comming too fast we gonna try to append only
                // the last one. That's what the SR will try to do anyway.
                clearTimeout(_this.previousTimeout);
                _this.previousTimeout = setTimeout(function () {
                    _this.ariaLiveElement.textContent = message;
                }, ARIA_LIVE_TICK);
            });
        };
        /**
         * onDestroy life cycle - must stop all active setTimeouts and remove the AriaLive
         * container from the document.
         */
        ClrAriaLiveService.prototype.ngOnDestroy = function () {
            clearTimeout(this.previousTimeout);
            if (common.isPlatformBrowser(this.platformId) && this.ariaLiveElement) {
                this.document.body.removeChild(this.ariaLiveElement);
                this.ariaLiveElement = null;
            }
        };
        /**
         * Create AriaLive DOM element as a last child of the document.
         * After the element is created, we gonna apply Clarity class to hide it from
         * the screen and set the `aria-live` politness.
         *
         * `clr-sr-only` is the CSS class that is used to hide the element from the screen.
         *
         * @remark
         * Calling this method multiple times will create multiple DOM Elements, that
         * won't be tracked and will be GC after the service is destroyed.
         *
         * @return AriaLive container as HTMLElement
         *
         */
        ClrAriaLiveService.prototype.createContainer = function () {
            var ariaLiveElement = this.document.createElement('div');
            ariaLiveElement.setAttribute('id', this.id);
            // Use clarity screen reader class to hide the dom element
            // and fix the scrollbar shake
            ariaLiveElement.classList.add('clr-sr-only');
            ariaLiveElement.setAttribute('aria-atomic', 'true');
            ariaLiveElement.setAttribute('aria-live', exports.ClrAriaLivePoliteness.polite);
            this.document.body.appendChild(ariaLiveElement);
            return ariaLiveElement;
        };
        ClrAriaLiveService.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        ClrAriaLiveService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function ClrAriaLiveService_Factory() { return new ClrAriaLiveService(core["ɵɵinject"](core.NgZone), core["ɵɵinject"](common.DOCUMENT), core["ɵɵinject"](core.PLATFORM_ID)); }, token: ClrAriaLiveService, providedIn: "root" });
        ClrAriaLiveService = __decorate([ __param(1, core.Inject(common.DOCUMENT)),
            __param(2, core.Inject(core.PLATFORM_ID))
        ], ClrAriaLiveService);
ClrAriaLiveService.ɵfac = function ClrAriaLiveService_Factory(t) { return new (t || ClrAriaLiveService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(common.DOCUMENT), ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAriaLiveService, [{
        type: core.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return ClrAriaLiveService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var Layouts;
    (function (Layouts) {
        Layouts["VERTICAL"] = "vertical";
        Layouts["HORIZONTAL"] = "horizontal";
        Layouts["COMPACT"] = "compact";
    })(Layouts || (Layouts = {}));
    var LayoutService = /** @class */ (function () {
        function LayoutService() {
            this.minLabelSize = 1;
            this.maxLabelSize = 12;
            this.layout = Layouts.HORIZONTAL;
            // This is basically a replacement for Object.values(), which IE11 and Node <9 don't support :(
            // String enums cannot be reverse-mapped, meaning Layouts['COMPACT'] does not return 'compact' so
            // this exists to deal with this little caveat to get the list of the values as an array.
            this.layoutValues = Object.keys(Layouts).map(function (key) { return Layouts[key]; });
            this._labelSize = 2;
        }
        Object.defineProperty(LayoutService.prototype, "labelSize", {
            get: function () {
                return this._labelSize;
            },
            set: function (size) {
                if (this.labelSizeIsValid(size)) {
                    this._labelSize = size;
                }
            },
            enumerable: true,
            configurable: true
        });
        LayoutService.prototype.isVertical = function () {
            return this.layout === Layouts.VERTICAL;
        };
        LayoutService.prototype.isHorizontal = function () {
            return this.layout === Layouts.HORIZONTAL;
        };
        LayoutService.prototype.isCompact = function () {
            return this.layout === Layouts.COMPACT;
        };
        Object.defineProperty(LayoutService.prototype, "layoutClass", {
            get: function () {
                return "clr-form-" + this.layout;
            },
            enumerable: true,
            configurable: true
        });
        LayoutService.prototype.isValid = function (layout) {
            return this.layoutValues.indexOf(layout) > -1;
        };
        LayoutService.prototype.labelSizeIsValid = function (labelSize) {
            return Number.isInteger(labelSize) && labelSize >= this.minLabelSize && labelSize <= this.maxLabelSize;
        };
LayoutService.ɵfac = function LayoutService_Factory(t) { return new (t || LayoutService)(); };
LayoutService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LayoutService, factory: function (t) { return LayoutService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LayoutService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return LayoutService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ControlClassService = /** @class */ (function () {
        function ControlClassService(layoutService) {
            this.layoutService = layoutService;
            this.className = '';
        }
        ControlClassService.prototype.controlClass = function (invalid, grid, additional) {
            if (invalid === void 0) { invalid = false; }
            if (grid === void 0) { grid = false; }
            if (additional === void 0) { additional = ''; }
            var controlClasses = [this.className, additional];
            if (invalid) {
                controlClasses.push('clr-error');
            }
            if (grid && this.layoutService && this.className.indexOf('clr-col') === -1) {
                controlClasses.push("clr-col-md-" + (this.layoutService.maxLabelSize - this.layoutService.labelSize) + " clr-col-12");
            }
            return controlClasses.join(' ').trim();
        };
        // We want to remove the column classes from the input up to the container
        ControlClassService.prototype.initControlClass = function (renderer, element) {
            if (element && element.className) {
                this.className = element.className;
                var klasses = element.className.split(' ');
                klasses.forEach(function (klass) {
                    if (klass.startsWith('clr-col')) {
                        renderer.removeClass(element, klass);
                    }
                });
            }
        };
        ControlClassService.ctorParameters = function () { return [
            { type: LayoutService, decorators: [{ type: core.Optional }] }
        ]; };
        ControlClassService = __decorate([ __param(0, core.Optional())
        ], ControlClassService);
ControlClassService.ɵfac = function ControlClassService_Factory(t) { return new (t || ControlClassService)(ɵngcc0.ɵɵinject(LayoutService, 8)); };
ControlClassService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ControlClassService, factory: function (t) { return ControlClassService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ControlClassService, [{
        type: core.Injectable
    }], function () { return [{ type: LayoutService, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return ControlClassService;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrControlError = /** @class */ (function () {
        function ClrControlError(controlIdService, controlClassService, ariaLiveService, el) {
            this.controlIdService = controlIdService;
            this.controlClassService = controlClassService;
            this.ariaLiveService = ariaLiveService;
            this.el = el;
        }
        /** @deprecated since 3.0, remove in 4.0 - ariaLiveService */
        ClrControlError.prototype.ngAfterViewInit = function () {
            /**
             * The way we render elements inside the `clr-control-container make this
             * component announce itself without been visible on the screen.
             *
             * The check below try to guess is clr-controll-error used in some of the
             * cases mention above and prevent us from announcing without the need of that.
             *
             * This change won't create breaking change - but will make aria live announcment
             * work only when the component is used outside forms or some of the components.
             *
             * This is temporary solution - until better is found.
             *
             */
            if (this.controlClassService === null) {
                this.ariaLiveService.announce(this.el.nativeElement);
            }
        };
        ClrControlError.ctorParameters = function () { return [
            { type: ControlIdService, decorators: [{ type: core.Optional }] },
            { type: ControlClassService, decorators: [{ type: core.Optional }] },
            { type: ClrAriaLiveService },
            { type: core.ElementRef }
        ]; };
        ClrControlError = __decorate([ __param(0, core.Optional()),
            __param(1, core.Optional())
        ], ClrControlError);
ClrControlError.ɵfac = function ClrControlError_Factory(t) { return new (t || ClrControlError)(ɵngcc0.ɵɵdirectiveInject(ControlIdService, 8), ɵngcc0.ɵɵdirectiveInject(ControlClassService, 8), ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrControlError.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrControlError, selectors: [["clr-control-error"]], hostVars: 3, hostBindings: function ClrControlError_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", (ctx.controlIdService == null ? null : ctx.controlIdService.id) + "-error");
        ɵngcc0.ɵɵclassProp("clr-subtext", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ClrAriaLiveService])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrControlError_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrControlError, [{
        type: core.Component,
        args: [{
                providers: [ClrAriaLiveService],
                selector: 'clr-control-error',
                template: "\n    <ng-content></ng-content>\n    ",
                host: {
                    '[class.clr-subtext]': 'true',
                    '[id]': 'controlIdService?.id + "-error"'
                }
            }]
    }], function () { return [{ type: ControlIdService, decorators: [{
                type: core.Optional
            }] }, { type: ControlClassService, decorators: [{
                type: core.Optional
            }] }, { type: ClrAriaLiveService }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrControlError;
    }());

    /**
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrControlHelper = /** @class */ (function () {
        function ClrControlHelper(controlIdService) {
            this.controlIdService = controlIdService;
        }
        ClrControlHelper.ctorParameters = function () { return [
            { type: ControlIdService, decorators: [{ type: core.Optional }] }
        ]; };
        ClrControlHelper = __decorate([ __param(0, core.Optional())
        ], ClrControlHelper);
ClrControlHelper.ɵfac = function ClrControlHelper_Factory(t) { return new (t || ClrControlHelper)(ɵngcc0.ɵɵdirectiveInject(ControlIdService, 8)); };
ClrControlHelper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrControlHelper, selectors: [["clr-control-helper"]], hostVars: 3, hostBindings: function ClrControlHelper_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", (ctx.controlIdService == null ? null : ctx.controlIdService.id) + "-helper");
        ɵngcc0.ɵɵclassProp("clr-subtext", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrControlHelper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrControlHelper, [{
        type: core.Component,
        args: [{
                selector: 'clr-control-helper',
                template: "\n    <ng-content></ng-content>\n    ",
                host: {
                    '[class.clr-subtext]': 'true',
                    '[id]': 'controlIdService?.id + "-helper"'
                }
            }]
    }], function () { return [{ type: ControlIdService, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return ClrControlHelper;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var NgControlService = /** @class */ (function () {
        function NgControlService() {
            // Observable to subscribe to the control, since its not available immediately for projected content
            this._controlChanges = new rxjs.Subject();
        }
        Object.defineProperty(NgControlService.prototype, "controlChanges", {
            get: function () {
                return this._controlChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        NgControlService.prototype.setControl = function (control) {
            this._controlChanges.next(control);
        };
NgControlService.ɵfac = function NgControlService_Factory(t) { return new (t || NgControlService)(); };
NgControlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgControlService, factory: function (t) { return NgControlService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgControlService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return NgControlService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var IfErrorService = /** @class */ (function () {
        function IfErrorService(ngControlService) {
            var _this = this;
            this.ngControlService = ngControlService;
            // Implement our own status changes observable, since Angular controls don't
            // fire on events like blur, and we want to return the boolean state instead of a string
            this._statusChanges = new rxjs.Subject();
            this.subscriptions = [];
            // Wait for the control to be available
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                if (control) {
                    _this.control = control;
                    _this.listenForChanges();
                }
            }));
        }
        Object.defineProperty(IfErrorService.prototype, "statusChanges", {
            get: function () {
                return this._statusChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        // Subscribe to the status change events, only after touched and emit the control
        IfErrorService.prototype.listenForChanges = function () {
            var _this = this;
            this.subscriptions.push(this.control.statusChanges.subscribe(function () {
                _this.sendValidity();
            }));
        };
        IfErrorService.prototype.sendValidity = function () {
            if (this.control.touched && this.control.invalid) {
                this._statusChanges.next(true);
            }
            else {
                this._statusChanges.next(false);
            }
        };
        // Allows a control to push a status check upstream, such as on blur
        IfErrorService.prototype.triggerStatusChange = function () {
            if (this.control) {
                this.sendValidity();
            }
        };
        // Clean up subscriptions
        IfErrorService.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        IfErrorService.ctorParameters = function () { return [
            { type: NgControlService }
        ]; };
IfErrorService.ɵfac = function IfErrorService_Factory(t) { return new (t || IfErrorService)(ɵngcc0.ɵɵinject(NgControlService)); };
IfErrorService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IfErrorService, factory: function (t) { return IfErrorService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IfErrorService, [{
        type: core.Injectable
    }], function () { return [{ type: NgControlService }]; }, null); })();
        return IfErrorService;
    }());

    var ClrIfError = /** @class */ (function () {
        function ClrIfError(ifErrorService, ngControlService, template, container) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.ngControlService = ngControlService;
            this.template = template;
            this.container = container;
            this.subscriptions = [];
            this.displayed = false;
            if (!this.ifErrorService) {
                throw new Error('clrIfError can only be used within a form control container element like clr-input-container');
            }
            else {
                this.displayError(false);
            }
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                // If there is a specific error to track, check it, otherwise check overall validity
                if (_this.error && _this.control) {
                    _this.displayError(_this.control.hasError(_this.error));
                }
                else {
                    _this.displayError(invalid);
                }
            }));
        }
        ClrIfError.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrIfError.prototype.displayError = function (invalid) {
            if (invalid && !this.displayed) {
                this.container.createEmbeddedView(this.template, { error: this.control.getError(this.error) });
                this.displayed = true;
            }
            else if (!invalid) {
                this.container.clear();
                this.displayed = false;
            }
        };
        ClrIfError.ctorParameters = function () { return [
            { type: IfErrorService, decorators: [{ type: core.Optional }] },
            { type: NgControlService, decorators: [{ type: core.Optional }] },
            { type: core.TemplateRef },
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.Input('clrIfError')
        ], ClrIfError.prototype, "error", void 0);
        ClrIfError = __decorate([ __param(0, core.Optional()),
            __param(1, core.Optional())
        ], ClrIfError);
ClrIfError.ɵfac = function ClrIfError_Factory(t) { return new (t || ClrIfError)(ɵngcc0.ɵɵdirectiveInject(IfErrorService, 8), ɵngcc0.ɵɵdirectiveInject(NgControlService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ClrIfError.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIfError, selectors: [["", "clrIfError", ""]], inputs: { error: ["clrIfError", "error"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIfError, [{
        type: core.Directive,
        args: [{ selector: '[clrIfError]' }]
    }], function () { return [{ type: IfErrorService, decorators: [{
                type: core.Optional
            }] }, { type: NgControlService, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { error: [{
            type: core.Input,
            args: ['clrIfError']
        }] }); })();
        return ClrIfError;
    }());

    var ClrLabel = /** @class */ (function () {
        function ClrLabel(controlIdService, layoutService, ngControlService, renderer, el) {
            this.controlIdService = controlIdService;
            this.layoutService = layoutService;
            this.ngControlService = ngControlService;
            this.renderer = renderer;
            this.el = el;
            this.subscriptions = [];
            this.enableGrid = true;
        }
        Object.defineProperty(ClrLabel.prototype, "labelText", {
            get: function () {
                return this.el.nativeElement && this.el.nativeElement.textContent;
            },
            enumerable: true,
            configurable: true
        });
        ClrLabel.prototype.ngOnInit = function () {
            var _this = this;
            // Only add the clr-control-label if it is inside a control container
            if (this.controlIdService || this.ngControlService) {
                this.renderer.addClass(this.el.nativeElement, 'clr-control-label');
            }
            // Only set the grid column classes if we are in the right context and if they aren't already set
            if (this.enableGrid &&
                this.layoutService &&
                !this.layoutService.isVertical() &&
                this.el.nativeElement &&
                this.el.nativeElement.className.indexOf('clr-col') < 0) {
                this.renderer.addClass(this.el.nativeElement, 'clr-col-12');
                this.renderer.addClass(this.el.nativeElement, "clr-col-md-" + this.layoutService.labelSize);
            }
            if (this.controlIdService && !this.forAttr) {
                this.subscriptions.push(this.controlIdService.idChange.subscribe(function (id) { return (_this.forAttr = id); }));
            }
        };
        ClrLabel.prototype.disableGrid = function () {
            this.enableGrid = false;
        };
        ClrLabel.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrLabel.ctorParameters = function () { return [
            { type: ControlIdService, decorators: [{ type: core.Optional }] },
            { type: LayoutService, decorators: [{ type: core.Optional }] },
            { type: NgControlService, decorators: [{ type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding('attr.for'),
            core.Input('for')
        ], ClrLabel.prototype, "forAttr", void 0);
        ClrLabel = __decorate([ __param(0, core.Optional()),
            __param(1, core.Optional()),
            __param(2, core.Optional())
        ], ClrLabel);
ClrLabel.ɵfac = function ClrLabel_Factory(t) { return new (t || ClrLabel)(ɵngcc0.ɵɵdirectiveInject(ControlIdService, 8), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(NgControlService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrLabel.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrLabel, selectors: [["label"]], hostVars: 1, hostBindings: function ClrLabel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("for", ctx.forAttr);
    } }, inputs: { forAttr: ["for", "forAttr"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLabel, [{
        type: core.Directive,
        args: [{ selector: 'label' }]
    }], function () { return [{ type: ControlIdService, decorators: [{
                type: core.Optional
            }] }, { type: LayoutService, decorators: [{
                type: core.Optional
            }] }, { type: NgControlService, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { forAttr: [{
            type: core.HostBinding,
            args: ['attr.for']
        }, {
            type: core.Input,
            args: ['for']
        }] }); })();
        return ClrLabel;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var MarkControlService = /** @class */ (function () {
        function MarkControlService() {
            this._touched = new rxjs.Subject();
        }
        Object.defineProperty(MarkControlService.prototype, "touchedChange", {
            get: function () {
                return this._touched.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        MarkControlService.prototype.markAsTouched = function () {
            this._touched.next();
        };
MarkControlService.ɵfac = function MarkControlService_Factory(t) { return new (t || MarkControlService)(); };
MarkControlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MarkControlService, factory: function (t) { return MarkControlService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MarkControlService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return MarkControlService;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrForm = /** @class */ (function () {
        function ClrForm(layoutService, markControlService, platformId, el, commonStrings, ariaLiveService) {
            this.layoutService = layoutService;
            this.markControlService = markControlService;
            this.platformId = platformId;
            this.el = el;
            this.commonStrings = commonStrings;
            this.ariaLiveService = ariaLiveService;
            this.invalidControls = [];
        }
        Object.defineProperty(ClrForm.prototype, "labelSize", {
            set: function (size) {
                this.layoutService.labelSize = size;
            },
            enumerable: true,
            configurable: true
        });
        /** @deprecated since 2.0 */
        ClrForm.prototype.markAsDirty = function (updateAriaLiveText) {
            this.markAsTouched((updateAriaLiveText = true));
        };
        // Trying to avoid adding an input and keep this backwards compatible at the same time
        ClrForm.prototype.markAsTouched = function (updateAriaLiveText) {
            this.markControlService.markAsTouched();
            // I don't think consumers will call this with undefined, null or other values but
            // want to make sure this only guards against when this is called with false
            if (updateAriaLiveText !== false && common.isPlatformBrowser(this.platformId)) {
                this.invalidControls = Array.from(this.el.nativeElement.querySelectorAll('.ng-invalid'));
                if (this.invalidControls.length > 0) {
                    this.invalidControls[0].focus();
                    this.updateAriaLive();
                }
            }
        };
        ClrForm.prototype.onFormSubmit = function () {
            this.markAsTouched();
        };
        /** @deprecated since 3.0, remove in 4.0 */
        ClrForm.prototype.updateAriaLive = function () {
            var _this = this;
            if (this.invalidControls.length === 0) {
                return;
            }
            var errorList = this.labels.filter(function (label) { return _this.invalidControls.find(function (control) { return label.forAttr === control.id; }); });
            this.ariaLiveService.announce(this.commonStrings.parse(this.commonStrings.keys.formErrorSummary, { ERROR_NUMBER: errorList.length.toString() }));
        };
        ClrForm.ctorParameters = function () { return [
            { type: LayoutService },
            { type: MarkControlService },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: core.ElementRef },
            { type: ClrCommonStringsService },
            { type: ClrAriaLiveService }
        ]; };
        __decorate([
            core.Input('clrLabelSize')
        ], ClrForm.prototype, "labelSize", null);
        __decorate([
            core.ContentChildren(ClrLabel, { descendants: true })
        ], ClrForm.prototype, "labels", void 0);
        __decorate([
            core.HostListener('submit')
        ], ClrForm.prototype, "onFormSubmit", null);
        ClrForm = __decorate([ __param(2, core.Inject(core.PLATFORM_ID))
        ], ClrForm);
ClrForm.ɵfac = function ClrForm_Factory(t) { return new (t || ClrForm)(ɵngcc0.ɵɵdirectiveInject(LayoutService), ɵngcc0.ɵɵdirectiveInject(MarkControlService), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService)); };
ClrForm.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrForm, selectors: [["", "clrForm", ""]], contentQueries: function ClrForm_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labels = _t);
    } }, hostVars: 6, hostBindings: function ClrForm_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("submit", function ClrForm_submit_HostBindingHandler() { return ctx.onFormSubmit(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form", true)("clr-form-horizontal", ctx.layoutService.isHorizontal())("clr-form-compact", ctx.layoutService.isCompact());
    } }, inputs: { labelSize: ["clrLabelSize", "labelSize"] }, features: [ɵngcc0.ɵɵProvidersFeature([LayoutService, MarkControlService, ClrAriaLiveService])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrForm, [{
        type: core.Directive,
        args: [{
                selector: '[clrForm]',
                providers: [LayoutService, MarkControlService, ClrAriaLiveService],
                host: {
                    '[class.clr-form]': 'true',
                    '[class.clr-form-horizontal]': 'layoutService.isHorizontal()',
                    '[class.clr-form-compact]': 'layoutService.isCompact()'
                }
            }]
    }], function () { return [{ type: LayoutService }, { type: MarkControlService }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: ClrCommonStringsService }, { type: ClrAriaLiveService }]; }, { labelSize: [{
            type: core.Input,
            args: ['clrLabelSize']
        }], onFormSubmit: [{
            type: core.HostListener,
            args: ['submit']
        }], labels: [{
            type: core.ContentChildren,
            args: [ClrLabel, { descendants: true }]
        }] }); })();
        return ClrForm;
    }());

    /**
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrLayout = /** @class */ (function () {
        function ClrLayout(layoutService) {
            this.layoutService = layoutService;
        }
        ClrLayout.prototype.ngOnInit = function () {
            // Only set the layout if it is a valid option
            if (this.layout && this.layoutService.isValid(this.layout)) {
                this.layoutService.layout = this.layout;
            }
        };
        ClrLayout.ctorParameters = function () { return [
            { type: LayoutService }
        ]; };
        __decorate([
            core.Input('clrLayout')
        ], ClrLayout.prototype, "layout", void 0);
ClrLayout.ɵfac = function ClrLayout_Factory(t) { return new (t || ClrLayout)(ɵngcc0.ɵɵdirectiveInject(LayoutService)); };
ClrLayout.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrLayout, selectors: [["", "clrForm", "", "clrLayout", ""]], inputs: { layout: ["clrLayout", "layout"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLayout, [{
        type: core.Directive,
        args: [{
                selector: '[clrForm][clrLayout]'
            }]
    }], function () { return [{ type: LayoutService }]; }, { layout: [{
            type: core.Input,
            args: ['clrLayout']
        }] }); })();
        return ClrLayout;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAbstractContainer = /** @class */ (function () {
        function ClrAbstractContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        ClrAbstractContainer.prototype.controlClass = function () {
            return this.controlClassService.controlClass(this.invalid, this.addGrid());
        };
        ClrAbstractContainer.prototype.addGrid = function () {
            return this.layoutService && !this.layoutService.isVertical();
        };
        ClrAbstractContainer.prototype.ngOnDestroy = function () {
            this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
        };
        ClrAbstractContainer.ctorParameters = function () { return [
            { type: IfErrorService },
            { type: LayoutService, decorators: [{ type: core.Optional }] },
            { type: ControlClassService },
            { type: NgControlService }
        ]; };
        __decorate([
            core.ContentChild(ClrLabel, { static: false })
        ], ClrAbstractContainer.prototype, "label", void 0);
        ClrAbstractContainer = __decorate([ __param(1, core.Optional())
        ], ClrAbstractContainer);
ClrAbstractContainer.ɵfac = function ClrAbstractContainer_Factory(t) { return new (t || ClrAbstractContainer)(ɵngcc0.ɵɵdirectiveInject(IfErrorService), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(ControlClassService), ɵngcc0.ɵɵdirectiveInject(NgControlService)); };
ClrAbstractContainer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrAbstractContainer, contentQueries: function ClrAbstractContainer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAbstractContainer, [{
        type: core.Directive
    }], function () { return [{ type: IfErrorService }, { type: LayoutService, decorators: [{
                type: core.Optional
            }] }, { type: ControlClassService }, { type: NgControlService }]; }, { label: [{
            type: core.ContentChild,
            args: [ClrLabel, { static: false }]
        }] }); })();
        return ClrAbstractContainer;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrControlContainer = /** @class */ (function (_super) {
        __extends(ClrControlContainer, _super);
        function ClrControlContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
ClrControlContainer.ɵfac = function ClrControlContainer_Factory(t) { return ɵClrControlContainer_BaseFactory(t || ClrControlContainer); };
ClrControlContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrControlContainer, selectors: [["clr-control-container"]], hostVars: 6, hostBindings: function ClrControlContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, features: [ɵngcc0.ɵɵProvidersFeature([IfErrorService, NgControlService, ControlIdService, ControlClassService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c4, decls: 8, vars: 5, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrControlContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c3);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrControlContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrControlContainer_clr_icon_5_Template, 1, 0, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ClrControlContainer_6_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(7, ClrControlContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
var ɵClrControlContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ClrControlContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrControlContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-control-container',
                template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-input-wrapper\">\n                <ng-content></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }]
    }], null, null); })();
        return ClrControlContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
     * still undefined.
     * TODO - make sure these comment annotations do not break ng-packgr.
     */
    var HostWrapper = /** @class */ (function () {
        function HostWrapper(containerType, vcr, index) {
            if (index === void 0) { index = 0; }
            this.injector = vcr.injector;
            // If the host is already wrapped, we don't do anything
            if (!this.injector.get(containerType, null)) {
                var cfr = this.injector.get(core.ComponentFactoryResolver);
                var el = this.injector.get(core.ElementRef);
                // We need a new anchor, since we're projecting the current one.
                vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
                var factory = cfr.resolveComponentFactory(containerType);
                // Craft the element array based on what slot to use. Angular only uses the index to determine
                // which ng-content to project into, so if you have more than one ng-content you'll need to set
                // the index in the constructor appropriately
                var element = [];
                element[index] = [el.nativeElement];
                // We're assuming only one projection slot, but in more complex cases we might want to provide
                // a different array of projected elements.
                var containerRef = vcr.createComponent(factory, undefined, undefined, element);
                // We can now remove the useless anchor
                vcr.remove(0);
                // We note that the container was dynamically created
                containerRef.instance._dynamic = true;
                // We keep the wrapper's injector to access the dependencies that weren't available before.
                this.injector = containerRef.injector;
            }
        }
        HostWrapper.prototype.get = function (token, notFoundValue) {
            return this.injector.get(token, notFoundValue);
        };
        return HostWrapper;
    }());

    var WrappedFormControl = /** @class */ (function () {
        // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
        // I'm giving up. So we have to inject these two manually for now.
        function WrappedFormControl(vcr, wrapperType, injector, ngControl, renderer, el) {
            var _this = this;
            this.vcr = vcr;
            this.wrapperType = wrapperType;
            this.ngControl = ngControl;
            this.subscriptions = [];
            this.index = 0;
            this.renderer = renderer;
            this.el = el;
            try {
                this.ngControlService = injector.get(NgControlService);
                this.ifErrorService = injector.get(IfErrorService);
                this.controlClassService = injector.get(ControlClassService);
                this.markControlService = injector.get(MarkControlService);
            }
            catch (e) { }
            if (this.controlClassService) {
                this.controlClassService.initControlClass(renderer, el.nativeElement);
            }
            if (this.markControlService) {
                this.subscriptions.push(this.markControlService.touchedChange.subscribe(function () {
                    _this.ngControl.control.markAsTouched();
                    _this.ngControl.control.updateValueAndValidity();
                }));
            }
        }
        Object.defineProperty(WrappedFormControl.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
                if (this.controlIdService) {
                    this.controlIdService.id = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        WrappedFormControl.prototype.triggerValidation = function () {
            if (this.ifErrorService) {
                this.ifErrorService.triggerStatusChange();
            }
        };
        // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
        // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
        // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
        // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
        WrappedFormControl.prototype.getProviderFromContainer = function (token, notFoundValue) {
            try {
                return this._containerInjector.get(token, notFoundValue);
            }
            catch (e) {
                return notFoundValue;
            }
        };
        WrappedFormControl.prototype.ngOnInit = function () {
            this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
            this.controlIdService = this._containerInjector.get(ControlIdService);
            if (this._id) {
                this.controlIdService.id = this._id;
            }
            else {
                this._id = this.controlIdService.id;
            }
            if (this.ngControlService) {
                this.ngControlService.setControl(this.ngControl);
            }
            this.listenForErrorStateChanges();
        };
        WrappedFormControl.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        WrappedFormControl.prototype.listenForErrorStateChanges = function () {
            var _this = this;
            if (this.ifErrorService) {
                this.subscriptions.push(this.ifErrorService.statusChanges
                    .pipe(operators.startWith(false), operators.filter(function () { return _this.renderer && !!_this.el; }), operators.distinctUntilChanged())
                    .subscribe(function (error) { return _this.setAriaDescribedBy(error); }));
            }
        };
        WrappedFormControl.prototype.setAriaDescribedBy = function (error) {
            this.renderer.setAttribute(this.el.nativeElement, 'aria-describedby', this.getAriaDescribedById(error));
        };
        WrappedFormControl.prototype.getAriaDescribedById = function (error) {
            return this.controlIdService.id.concat(error ? '-error' : '-helper');
        };
        WrappedFormControl.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Type },
            { type: core.Injector },
            { type: forms.NgControl },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding(),
            core.Input()
        ], WrappedFormControl.prototype, "id", null);
        __decorate([
            core.HostListener('blur')
        ], WrappedFormControl.prototype, "triggerValidation", null);
WrappedFormControl.ɵfac = function WrappedFormControl_Factory(t) { return new (t || WrappedFormControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Type), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
WrappedFormControl.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: WrappedFormControl, hostVars: 1, hostBindings: function WrappedFormControl_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("blur", function WrappedFormControl_blur_HostBindingHandler() { return ctx.triggerValidation(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
    } }, inputs: { id: "id" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WrappedFormControl, [{
        type: core.Directive
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Type }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { id: [{
            type: core.HostBinding
        }, {
            type: core.Input
        }], triggerValidation: [{
            type: core.HostListener,
            args: ['blur']
        }] }); })();
        return WrappedFormControl;
    }());

    var ClrControl = /** @class */ (function (_super) {
        __extends(ClrControl, _super);
        function ClrControl(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrControlContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrControl.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        ClrControl = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional())
        ], ClrControl);
ClrControl.ɵfac = function ClrControl_Factory(t) { return new (t || ClrControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrControl.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrControl, selectors: [["", "clrControl", ""]], hostVars: 2, hostBindings: function ClrControl_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-input", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrControl, [{
        type: core.Directive,
        args: [{ selector: '[clrControl]', host: { '[class.clr-input]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrControl;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrCommonFormsModule = /** @class */ (function () {
        function ClrCommonFormsModule() {
        }
ClrCommonFormsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrCommonFormsModule });
ClrCommonFormsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrCommonFormsModule_Factory(t) { return new (t || ClrCommonFormsModule)(); }, imports: [[common.CommonModule, ClrIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrCommonFormsModule, { declarations: [ClrLabel,
        ClrControlError,
        ClrControlHelper,
        ClrIfError,
        ClrForm,
        ClrLayout,
        ClrControlContainer,
        ClrControl], imports: [ɵngcc1.CommonModule, ClrIconModule], exports: [ClrLabel,
        ClrControlError,
        ClrControlHelper,
        ClrIfError,
        ClrForm,
        ClrLayout,
        ClrControlContainer,
        ClrControl] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCommonFormsModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule],
                declarations: [
                    ClrLabel,
                    ClrControlError,
                    ClrControlHelper,
                    ClrIfError,
                    ClrForm,
                    ClrLayout,
                    ClrControlContainer,
                    ClrControl,
                ],
                exports: [
                    ClrLabel,
                    ClrControlError,
                    ClrControlHelper,
                    ClrIfError,
                    ClrForm,
                    ClrLayout,
                    ClrControlContainer,
                    ClrControl,
                ],
                entryComponents: [ClrControlContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrCommonFormsModule;
    }());

    /**
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var IS_TOGGLE = new core.InjectionToken('IS_TOGGLE');
    function isToggleFactory() {
        return new rxjs.BehaviorSubject(false);
    }
    var IS_TOGGLE_PROVIDER = { provide: IS_TOGGLE, useFactory: isToggleFactory };
    var ClrCheckboxWrapper = /** @class */ (function () {
        function ClrCheckboxWrapper(toggleService) {
            var _this = this;
            // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
            // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
            // but we'd still need to insert a label
            this._dynamic = false;
            this.toggle = false;
            this.subscriptions = [];
            this.subscriptions.push(toggleService.subscribe(function (state) {
                _this.toggle = state;
            }));
        }
        ClrCheckboxWrapper.prototype.ngOnInit = function () {
            if (this.label) {
                this.label.disableGrid();
            }
        };
        ClrCheckboxWrapper.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrCheckboxWrapper.ctorParameters = function () { return [
            { type: rxjs.BehaviorSubject, decorators: [{ type: core.Inject, args: [IS_TOGGLE,] }] }
        ]; };
        __decorate([
            core.ContentChild(ClrLabel, { static: true })
        ], ClrCheckboxWrapper.prototype, "label", void 0);
        ClrCheckboxWrapper = __decorate([ __param(0, core.Inject(IS_TOGGLE))
        ], ClrCheckboxWrapper);
ClrCheckboxWrapper.ɵfac = function ClrCheckboxWrapper_Factory(t) { return new (t || ClrCheckboxWrapper)(ɵngcc0.ɵɵdirectiveInject(IS_TOGGLE)); };
ClrCheckboxWrapper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrCheckboxWrapper, selectors: [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]], contentQueries: function ClrCheckboxWrapper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
    } }, hostVars: 4, hostBindings: function ClrCheckboxWrapper_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-checkbox-wrapper", !ctx.toggle)("clr-toggle-wrapper", ctx.toggle);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ControlIdService, IS_TOGGLE_PROVIDER])], ngContentSelectors: _c6, decls: 3, vars: 1, consts: [[4, "ngIf"]], template: function ClrCheckboxWrapper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵtemplate(2, ClrCheckboxWrapper_label_2_Template, 1, 0, "label", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label);
    } }, directives: [ɵngcc1.NgIf, ClrLabel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCheckboxWrapper, [{
        type: core.Component,
        args: [{
                selector: 'clr-checkbox-wrapper,clr-toggle-wrapper',
                template: "\n    <ng-content select=\"[clrCheckbox],[clrToggle]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                host: {
                    '[class.clr-checkbox-wrapper]': '!toggle',
                    '[class.clr-toggle-wrapper]': 'toggle'
                },
                providers: [ControlIdService, IS_TOGGLE_PROVIDER]
            }]
    }], function () { return [{ type: ɵngcc3.BehaviorSubject, decorators: [{
                type: core.Inject,
                args: [IS_TOGGLE]
            }] }]; }, { label: [{
            type: core.ContentChild,
            args: [ClrLabel, { static: true }]
        }] }); })();
        return ClrCheckboxWrapper;
    }());

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This implements both the clrCheckbox and clrToggle functionality, since they are both just checkboxes with different
     * visual styling. The challenge is that the container needs to know which selector was used, which the @Attribute
     * decorator gets for us to determine if the toggle is used, and emits a value to the wrapper container to tell it
     * there is a toggle switch instead.
     */
    var ClrCheckbox = /** @class */ (function (_super) {
        __extends(ClrCheckbox, _super);
        function ClrCheckbox(vcr, injector, control, renderer, el, toggle) {
            var _this = _super.call(this, vcr, ClrCheckboxWrapper, injector, control, renderer, el) || this;
            _this.toggle = toggle;
            return _this;
        }
        ClrCheckbox.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            var toggleService = this.getProviderFromContainer(IS_TOGGLE, null);
            if (toggleService && this.toggle !== null) {
                toggleService.next(true);
            }
        };
        ClrCheckbox.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: String, decorators: [{ type: core.Attribute, args: ['clrToggle',] }] }
        ]; };
        ClrCheckbox = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional()),
            __param(5, core.Attribute('clrToggle'))
        ], ClrCheckbox);
ClrCheckbox.ɵfac = function ClrCheckbox_Factory(t) { return new (t || ClrCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('clrToggle')); };
ClrCheckbox.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrCheckbox, selectors: [["", "clrCheckbox", ""], ["", "clrToggle", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCheckbox, [{
        type: core.Directive,
        args: [{ selector: '[clrCheckbox],[clrToggle]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: core.Attribute,
                args: ['clrToggle']
            }] }]; }, null); })();
        return ClrCheckbox;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrCheckboxContainer = /** @class */ (function (_super) {
        __extends(ClrCheckboxContainer, _super);
        function ClrCheckboxContainer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.inline = false;
            return _this;
        }
        Object.defineProperty(ClrCheckboxContainer.prototype, "clrInline", {
            get: function () {
                return this.inline;
            },
            // private formGroup: AbstractControl;
            /*
             * Here we want to support the following cases
             * clrInline - true by presence
             * clrInline="true|false" - unless it is explicitly false, strings are considered true
             * [clrInline]="true|false" - expect a boolean
             */
            set: function (value) {
                if (typeof value === 'string') {
                    this.inline = value === 'false' ? false : true;
                }
                else {
                    this.inline = !!value;
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input()
        ], ClrCheckboxContainer.prototype, "clrInline", null);
ClrCheckboxContainer.ɵfac = function ClrCheckboxContainer_Factory(t) { return ɵClrCheckboxContainer_BaseFactory(t || ClrCheckboxContainer); };
ClrCheckboxContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrCheckboxContainer, selectors: [["clr-checkbox-container"], ["clr-toggle-container"]], hostVars: 6, hostBindings: function ClrCheckboxContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, inputs: { clrInline: "clrInline" }, features: [ɵngcc0.ɵɵProvidersFeature([NgControlService, ControlClassService, IfErrorService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 8, vars: 7, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-subtext-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrCheckboxContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrCheckboxContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵtemplate(5, ClrCheckboxContainer_5_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(6, ClrCheckboxContainer_clr_icon_6_Template, 1, 0, "clr-icon", 3);
        ɵngcc0.ɵɵtemplate(7, ClrCheckboxContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("clr-control-inline", ctx.clrInline);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
var ɵClrCheckboxContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ClrCheckboxContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCheckboxContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-checkbox-container,clr-toggle-container',
                template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-checkbox-wrapper,clr-toggle-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n  ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [NgControlService, ControlClassService, IfErrorService]
            }]
    }], null, { clrInline: [{
            type: core.Input
        }] }); })();
        return ClrCheckboxContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrCheckboxModule = /** @class */ (function () {
        function ClrCheckboxModule() {
        }
ClrCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrCheckboxModule });
ClrCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrCheckboxModule_Factory(t) { return new (t || ClrCheckboxModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrCheckboxModule, { declarations: [ClrCheckbox,
        ClrCheckboxContainer,
        ClrCheckboxWrapper], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrCommonFormsModule,
        ClrHostWrappingModule], exports: [ClrCommonFormsModule,
        ClrCheckbox,
        ClrCheckboxContainer,
        ClrCheckboxWrapper] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCheckboxModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
                declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                entryComponents: [ClrCheckboxWrapper]
            }]
    }], function () { return []; }, null); })();
        return ClrCheckboxModule;
    }());

    var activeCounter = 0;
    var IF_ACTIVE_ID = new core.InjectionToken('IF_ACTIVE_ID');
    function tokenFactory() {
        return ++activeCounter;
    }
    var IF_ACTIVE_ID_PROVIDER = {
        provide: IF_ACTIVE_ID,
        useFactory: tokenFactory,
    };
    var IfActiveService = /** @class */ (function () {
        /*********
         * @class IfActiveService
         *
         * @description
         * An injectable service used by IfActive structural directives and the components that implement IfActive in their
         * templates. It holds the value of the current state and provides an Observable that both the directive and the
         * implementing component can subscribe to in order to take action on current value changes.
         *
         */
        function IfActiveService() {
            /********
             * @property _currentChange
             *
             * @description
             * A RXJS Subject that updates and provides subscriptions to for the current current state of a component template
             * implemting the IfActive structural directive.
             *
             */
            this._currentChange = new rxjs.Subject();
        }
        Object.defineProperty(IfActiveService.prototype, "currentChange", {
            /*********
             *
             * @description
             * A getter function that provides an observable for the _current Subject.
             *
             */
            get: function () {
                return this._currentChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IfActiveService.prototype, "current", {
            /*********
             *
             * @description
             * A getter that returns the current value of this IfActive instance.
             * @returns
             */
            get: function () {
                return this._current;
            },
            /*********
             *
             * @description
             * A setter function that updates the current state of _current for this instance of IfActive structural directive.
             * And, broadcasts the new value to all subscribers.
             *
             * @param value
             */
            set: function (value) {
                if (this._current !== value) {
                    this._current = value;
                    this._currentChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
IfActiveService.ɵfac = function IfActiveService_Factory(t) { return new (t || IfActiveService)(); };
IfActiveService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IfActiveService, factory: function (t) { return IfActiveService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IfActiveService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return IfActiveService;
    }());

    var ClrIfActive = /** @class */ (function () {
        function ClrIfActive(ifActiveService, id, template, container) {
            var _this = this;
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.template = template;
            this.container = container;
            this.wasActive = false;
            /**********
             * @property activeChange
             *
             * @description
             * An event emitter that emits when the active property is set to allow for 2way binding when the directive is
             * used with de-structured / de-sugared syntax.
             *
             */
            this.activeChange = new core.EventEmitter(false);
            this.checkAndUpdateView(ifActiveService.current);
            this.subscription = this.ifActiveService.currentChange.subscribe(function (newCurrentId) {
                _this.checkAndUpdateView(newCurrentId);
            });
        }
        ClrIfActive.prototype.checkAndUpdateView = function (currentId) {
            var isNowActive = currentId === this.id;
            // only emit if the new active state is changed since last time.
            if (isNowActive !== this.wasActive) {
                this.updateView(isNowActive);
                this.activeChange.emit(isNowActive);
                this.wasActive = isNowActive;
            }
        };
        Object.defineProperty(ClrIfActive.prototype, "active", {
            /********
             *
             * @description
             * A getter that returns the current IfActiveService.active value.
             */
            get: function () {
                return this.ifActiveService.current === this.id;
            },
            /*********
             *
             * @description
             * A setter that updates IfActiveService.active with value.
             *
             * @param value
             */
            set: function (value) {
                if (value) {
                    this.ifActiveService.current = this.id;
                }
            },
            enumerable: true,
            configurable: true
        });
        /*********
         *
         * @description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param value
         */
        ClrIfActive.prototype.updateView = function (value) {
            if (value) {
                this.container.createEmbeddedView(this.template);
            }
            else {
                this.container.clear();
            }
        };
        ClrIfActive.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        ClrIfActive.ctorParameters = function () { return [
            { type: IfActiveService },
            { type: Number, decorators: [{ type: core.Inject, args: [IF_ACTIVE_ID,] }] },
            { type: core.TemplateRef },
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.Input('clrIfActive')
        ], ClrIfActive.prototype, "active", null);
        __decorate([
            core.Output('clrIfActiveChange')
        ], ClrIfActive.prototype, "activeChange", void 0);
        ClrIfActive = __decorate([ __param(1, core.Inject(IF_ACTIVE_ID))
        ], ClrIfActive);
ClrIfActive.ɵfac = function ClrIfActive_Factory(t) { return new (t || ClrIfActive)(ɵngcc0.ɵɵdirectiveInject(IfActiveService), ɵngcc0.ɵɵdirectiveInject(IF_ACTIVE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ClrIfActive.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIfActive, selectors: [["", "clrIfActive", ""]], inputs: { active: ["clrIfActive", "active"] }, outputs: { activeChange: "clrIfActiveChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIfActive, [{
        type: core.Directive,
        args: [{ selector: '[clrIfActive]' }]
    }], function () { return [{ type: IfActiveService }, { type: Number, decorators: [{
                type: core.Inject,
                args: [IF_ACTIVE_ID]
            }] }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { activeChange: [{
            type: core.Output,
            args: ['clrIfActiveChange']
        }], active: [{
            type: core.Input,
            args: ['clrIfActive']
        }] }); })();
        return ClrIfActive;
    }());

    var ClrIfOpen = /** @class */ (function () {
        function ClrIfOpen(toggleService, template, container) {
            var _this = this;
            this.toggleService = toggleService;
            this.template = template;
            this.container = container;
            /**********
             * @property openChange
             *
             * @description
             * An event emitter that emits when the open property is set to allow for 2way binding when the directive is
             * used with de-structured / de-sugared syntax.
             */
            this.openChange = new core.EventEmitter(false);
            this.subscription = this.toggleService.openChange.subscribe(function (change) {
                _this.updateView(change);
                _this.openChange.emit(change);
            });
        }
        Object.defineProperty(ClrIfOpen.prototype, "open", {
            /********
             *
             * @description
             * A getter that returns the current ClrPopoverToggleService.open value.
             *
             */
            get: function () {
                return this.toggleService.open;
            },
            /*********
             *
             * @description
             * A setter that updates ClrPopoverToggleService.open with value.
             *
             * @param value
             */
            set: function (value) {
                this.toggleService.open = value;
            },
            enumerable: true,
            configurable: true
        });
        /*********
         *
         * @description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param value
         */
        ClrIfOpen.prototype.updateView = function (value) {
            if (value) {
                this.container.createEmbeddedView(this.template);
            }
            else {
                this.container.clear();
            }
        };
        ClrIfOpen.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        ClrIfOpen.ctorParameters = function () { return [
            { type: ClrPopoverToggleService },
            { type: core.TemplateRef },
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.Input('clrIfOpen')
        ], ClrIfOpen.prototype, "open", null);
        __decorate([
            core.Output('clrIfOpenChange')
        ], ClrIfOpen.prototype, "openChange", void 0);
ClrIfOpen.ɵfac = function ClrIfOpen_Factory(t) { return new (t || ClrIfOpen)(ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ClrIfOpen.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIfOpen, selectors: [["", "clrIfOpen", ""]], inputs: { open: ["clrIfOpen", "open"] }, outputs: { openChange: "clrIfOpenChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIfOpen, [{
        type: core.Directive,
        args: [{ selector: '[clrIfOpen]' }]
    }], function () { return [{ type: ClrPopoverToggleService }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { openChange: [{
            type: core.Output,
            args: ['clrIfOpenChange']
        }], open: [{
            type: core.Input,
            args: ['clrIfOpen']
        }] }); })();
        return ClrIfOpen;
    }());

    var IfExpandService = /** @class */ (function () {
        function IfExpandService() {
            this.expandable = 0;
            this._loading = false;
            this._expanded = false;
            this._expandChange = new rxjs.Subject();
        }
        Object.defineProperty(IfExpandService.prototype, "loading", {
            get: function () {
                return this._loading;
            },
            set: function (value) {
                value = !!value;
                if (value !== this._loading) {
                    this._loading = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IfExpandService.prototype, "expanded", {
            get: function () {
                return this._expanded;
            },
            set: function (value) {
                value = !!value;
                if (value !== this._expanded) {
                    this._expanded = value;
                    this._expandChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        IfExpandService.prototype.toggle = function () {
            this.expanded = !this._expanded;
        };
        Object.defineProperty(IfExpandService.prototype, "expandChange", {
            get: function () {
                return this._expandChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        IfExpandService.prototype.loadingStateChange = function (state) {
            switch (state) {
                case exports.ClrLoadingState.LOADING:
                    this.loading = true;
                    break;
                default:
                    this.loading = false;
                    break;
            }
        };
IfExpandService.ɵfac = function IfExpandService_Factory(t) { return new (t || IfExpandService)(); };
IfExpandService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IfExpandService, factory: function (t) { return IfExpandService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IfExpandService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return IfExpandService;
    }());

    var ClrIfExpanded = /** @class */ (function () {
        function ClrIfExpanded(template, container, el, renderer, expand) {
            var _this = this;
            this.template = template;
            this.container = container;
            this.el = el;
            this.renderer = renderer;
            this.expand = expand;
            this._expanded = false;
            this.expandedChange = new core.EventEmitter(true);
            /**
             * Subscriptions to all the services and queries changes
             */
            this._subscriptions = [];
            expand.expandable++;
            this._subscriptions.push(expand.expandChange.subscribe(function () {
                _this.updateView();
                _this.expandedChange.emit(_this.expand.expanded);
            }));
        }
        Object.defineProperty(ClrIfExpanded.prototype, "expanded", {
            get: function () {
                return this._expanded;
            },
            set: function (value) {
                if (typeof value === 'boolean') {
                    this.expand.expanded = value;
                    this._expanded = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrIfExpanded.prototype.updateView = function () {
            if (this.expand.expanded && this.container.length !== 0) {
                return;
            }
            if (this.template) {
                if (this.expand.expanded) {
                    // Should we pass a context? I don't see anything useful to pass right now,
                    // but we can come back to it in the future as a solution for additional features.
                    this.container.createEmbeddedView(this.template);
                }
                else {
                    // TODO: Move when we move the animation logic to Datagrid Row Expand
                    // We clear before the animation is over. Not ideal, but doing better would involve a much heavier
                    // process for very little gain. Once Angular animations are dynamic enough, we should be able to
                    // get the optimal behavior.
                    this.container.clear();
                }
            }
            else {
                try {
                    // If we don't have a template ref, we fallback to a crude display: none for now.
                    if (this.expand.expanded) {
                        this.renderer.setStyle(this.el.nativeElement, 'display', null);
                    }
                    else {
                        this.renderer.setStyle(this.el.nativeElement, 'display', 'none');
                    }
                }
                catch (e) {
                    // We catch the case where clrIfExpanded was put on a non-DOM element, and we just do nothing
                }
            }
        };
        ClrIfExpanded.prototype.ngOnInit = function () {
            this.updateView();
        };
        ClrIfExpanded.prototype.ngOnDestroy = function () {
            this.expand.expandable--;
            this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrIfExpanded.ctorParameters = function () { return [
            { type: core.TemplateRef, decorators: [{ type: core.Optional }] },
            { type: core.ViewContainerRef },
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: IfExpandService }
        ]; };
        __decorate([
            core.Input('clrIfExpanded')
        ], ClrIfExpanded.prototype, "expanded", null);
        __decorate([
            core.Output('clrIfExpandedChange')
        ], ClrIfExpanded.prototype, "expandedChange", void 0);
        ClrIfExpanded = __decorate([ __param(0, core.Optional())
        ], ClrIfExpanded);
ClrIfExpanded.ɵfac = function ClrIfExpanded_Factory(t) { return new (t || ClrIfExpanded)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IfExpandService)); };
ClrIfExpanded.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIfExpanded, selectors: [["", "clrIfExpanded", ""]], inputs: { expanded: ["clrIfExpanded", "expanded"] }, outputs: { expandedChange: "clrIfExpandedChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIfExpanded, [{
        type: core.Directive,
        args: [{ selector: '[clrIfExpanded]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: IfExpandService }]; }, { expandedChange: [{
            type: core.Output,
            args: ['clrIfExpandedChange']
        }], expanded: [{
            type: core.Input,
            args: ['clrIfExpanded']
        }] }); })();
        return ClrIfExpanded;
    }());

    var CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen, ClrIfExpanded];
    var ClrConditionalModule = /** @class */ (function () {
        function ClrConditionalModule() {
        }
ClrConditionalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrConditionalModule });
ClrConditionalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrConditionalModule_Factory(t) { return new (t || ClrConditionalModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrConditionalModule, { declarations: [ClrIfActive,
        ClrIfOpen,
        ClrIfExpanded], imports: [ɵngcc1.CommonModule], exports: [ClrIfActive,
        ClrIfOpen,
        ClrIfExpanded] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrConditionalModule, [{
        type: core.NgModule,
        args: [{ imports: [common.CommonModule], declarations: [CONDITIONAL_DIRECTIVES], exports: [CONDITIONAL_DIRECTIVES] }]
    }], function () { return []; }, null); })();
        return ClrConditionalModule;
    }());

    var FocusTrapTracker = /** @class */ (function () {
        function FocusTrapTracker() {
            this._previousFocusTraps = [];
        }
        Object.defineProperty(FocusTrapTracker.prototype, "current", {
            get: function () {
                return this._current;
            },
            set: function (value) {
                this._previousFocusTraps.push(this._current);
                this._current = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusTrapTracker.prototype, "nbFocusTrappers", {
            get: function () {
                return this._previousFocusTraps.length;
            },
            enumerable: true,
            configurable: true
        });
        FocusTrapTracker.prototype.activatePreviousTrapper = function () {
            this._current = this._previousFocusTraps.pop();
        };
        FocusTrapTracker.ɵprov = core["ɵɵdefineInjectable"]({ factory: function FocusTrapTracker_Factory() { return new FocusTrapTracker(); }, token: FocusTrapTracker, providedIn: "root" });
FocusTrapTracker.ɵfac = function FocusTrapTracker_Factory(t) { return new (t || FocusTrapTracker)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusTrapTracker, [{
        type: core.Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
        return FocusTrapTracker;
    }());

    var FocusTrapDirective = /** @class */ (function () {
        function FocusTrapDirective(el, injector, focusTrapsTracker, renderer, platformId) {
            this.el = el;
            this.injector = injector;
            this.focusTrapsTracker = focusTrapsTracker;
            this.renderer = renderer;
            this.platformId = platformId;
            this.localFocusEscaped = false;
            this._config = {
                strict: true,
            };
            this.document = this.injector.get(common.DOCUMENT);
            this.focusTrapsTracker.current = this;
            this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
        }
        Object.defineProperty(FocusTrapDirective.prototype, "config", {
            set: function (config) {
                this._config = Object.assign(this._config, config);
            },
            enumerable: true,
            configurable: true
        });
        FocusTrapDirective.prototype.onFocusIn = function (event) {
            if (this.focusTrapsTracker.current !== this || !common.isPlatformBrowser(this.platformId) || this.localFocusEscaped) {
                return;
            }
            var nativeElement = this.el.nativeElement;
            if (this._config.strict && event.target && !nativeElement.contains(event.target)) {
                // When the focus trap is global, always steal focus back if it goes outside
                nativeElement.focus();
            }
            else if (event.target === this.bottomReboundEl && nativeElement.contains(this.previousTrappedActiveElement)) {
                // When the focus trap is local, if the user navigates via keyboard to the end element from within the trap, move to top
                nativeElement.focus();
            }
            else if (event.target === this.topReboundEl) {
                // When the focus trap is local, if the user navigates via keyboard back to start element from within the trap, move to bottom
                // @TODO implement an acceptable solution to SHIFT+TAB navigation
            }
            else if (event.target !== nativeElement && !nativeElement.contains(event.target)) {
                // If a user has escaped the trap using the mouse
                // relax, don't do it, when you want to go to it, living those dreams, scheme those schemes, hit me with those laser beams
                this.localFocusEscaped = true;
            }
            // Track the last focused item, so we can check
            this.previousTrappedActiveElement = event.target;
        };
        FocusTrapDirective.prototype.createFocusableOffScreenEl = function () {
            // Not using Renderer2's createElement method because that leads to DOM leakage.
            // https://github.com/angular/angular/issues/26954
            var offScreenSpan = this.document.createElement('span');
            this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
            this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
            return offScreenSpan;
        };
        FocusTrapDirective.prototype.addReboundEls = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.topReboundEl = this.createFocusableOffScreenEl();
                this.bottomReboundEl = this.createFocusableOffScreenEl();
                var hostElement = this.el.nativeElement;
                // Add reboundBeforeTrapEl right outside of host element
                this.renderer.insertBefore(hostElement.parentElement, this.topReboundEl, hostElement);
                // Add reboundAfterTrapEl right after host element
                if (hostElement.nextSibling) {
                    this.renderer.insertBefore(hostElement.parentNode, this.bottomReboundEl, hostElement.nextSibling);
                }
                else {
                    this.renderer.appendChild(hostElement.parentNode, this.bottomReboundEl);
                }
            }
        };
        FocusTrapDirective.prototype.removeReboundEls = function () {
            if (common.isPlatformBrowser(this.platformId) && this.topReboundEl && this.bottomReboundEl) {
                this.parentElement.removeChild(this.topReboundEl);
                this.parentElement.removeChild(this.bottomReboundEl);
                // These are here to to make sure that
                // we completely delete all traces of the removed DOM objects.
                delete this.topReboundEl;
                delete this.bottomReboundEl;
            }
        };
        FocusTrapDirective.prototype.setPreviousFocus = function () {
            if (this.previousActiveElement && this.previousActiveElement.focus) {
                this.previousActiveElement.focus();
            }
        };
        FocusTrapDirective.prototype.ngAfterViewInit = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.previousActiveElement = this.document.activeElement;
                this.parentElement = this.el.nativeElement.parentElement;
            }
            this.addReboundEls();
        };
        FocusTrapDirective.prototype.ngOnDestroy = function () {
            this.removeReboundEls();
            this.setPreviousFocus();
            this.focusTrapsTracker.activatePreviousTrapper();
        };
        FocusTrapDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Injector },
            { type: FocusTrapTracker },
            { type: core.Renderer2 },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        __decorate([
            core.Input('clrFocusTrap')
        ], FocusTrapDirective.prototype, "config", null);
        __decorate([
            core.HostListener('document:focusin', ['$event'])
        ], FocusTrapDirective.prototype, "onFocusIn", null);
        FocusTrapDirective = __decorate([ __param(4, core.Inject(core.PLATFORM_ID))
        ], FocusTrapDirective);
FocusTrapDirective.ɵfac = function FocusTrapDirective_Factory(t) { return new (t || FocusTrapDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(FocusTrapTracker), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
FocusTrapDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FocusTrapDirective, selectors: [["", "clrFocusTrap", ""]], hostBindings: function FocusTrapDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function FocusTrapDirective_focusin_HostBindingHandler($event) { return ctx.onFocusIn($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { config: ["clrFocusTrap", "config"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusTrapDirective, [{
        type: core.Directive,
        args: [{ selector: '[clrFocusTrap]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Injector }, { type: FocusTrapTracker }, { type: ɵngcc0.Renderer2 }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { config: [{
            type: core.Input,
            args: ['clrFocusTrap']
        }], onFocusIn: [{
            type: core.HostListener,
            args: ['document:focusin', ['$event']]
        }] }); })();
        return FocusTrapDirective;
    }());

    var FOCUS_TRAP_DIRECTIVES = [FocusTrapDirective];
    var ClrFocusTrapModule = /** @class */ (function () {
        function ClrFocusTrapModule() {
        }
ClrFocusTrapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrFocusTrapModule });
ClrFocusTrapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrFocusTrapModule_Factory(t) { return new (t || ClrFocusTrapModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrFocusTrapModule, { declarations: [FocusTrapDirective], imports: [ɵngcc1.CommonModule], exports: [FocusTrapDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrFocusTrapModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [FOCUS_TRAP_DIRECTIVES],
                exports: [FOCUS_TRAP_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrFocusTrapModule;
    }());

    /*
     * Copyright (c) 2017 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var UP_ARROW = 38;
    var DOWN_ARROW = 40;
    var RIGHT_ARROW = 39;
    var LEFT_ARROW = 37;
    var ENTER = 13;
    var SPACE = 32;
    var TAB = 9;
    var ESC = 27;

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This is the en-001 short locale date format. Setting as default.
     */
    var DEFAULT_LOCALE_FORMAT = 'dd/MM/y';
    // https://en.wikipedia.org/wiki/Date_format_by_country
    var LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
    var MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
    // No need for BIG_ENDIAN_REGEX because anything that doesn't satisfy the above 2
    // is automatically BIG_ENDIAN
    var DELIMITER_REGEX = /d+|m+|y+/i;
    var USER_INPUT_REGEX = /\d+/g;
    var MOBILE_USERAGENT_REGEX = /Mobi/i;
    var RTL_REGEX = /\u200f/g;
    var YEAR = 'YYYY';
    var MONTH = 'MM';
    var DATE = 'DD';
    var LITTLE_ENDIAN = {
        name: 'LITTLE_ENDIAN',
        format: [DATE, MONTH, YEAR],
    };
    var MIDDLE_ENDIAN = {
        name: 'MIDDLE_ENDIAN',
        format: [MONTH, DATE, YEAR],
    };
    var BIG_ENDIAN = {
        name: 'BIG_ENDIAN',
        format: [YEAR, MONTH, DATE],
    };
    var NO_OF_DAYS_IN_A_WEEK = 7;
    var NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
    var TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Returns the number of days in a month.
     */
    function getNumberOfDaysInTheMonth(year, month) {
        // If we go to the next month, but use a day of 0, it returns the last day from the previous month
        return new Date(year, month + 1, 0).getDate();
    }
    /**
     * Returns the day for the corresponding date where 0 represents Sunday.
     */
    function getDay(year, month, date) {
        return new Date(year, month, date).getDay();
    }
    /**
     * Takes in a year and if it is a 2 digit year, returns the corresponding 4 digit year.
     * Window of 80 years before and 20 years after the present year.
     * Credit: https://github.com/globalizejs/globalize/blob/e1b31cd6a4f1cff75b185b68b7a32220aac5196f/src/date/parse.js
     */
    function parseToFourDigitYear(year) {
        if (year > 9999 || (year > 100 && year < 999) || year < 10) {
            return -1;
        }
        if (year > 999) {
            return year;
        }
        var currYear = new Date().getFullYear();
        var century = Math.floor(currYear / 100) * 100;
        var result = year + century;
        if (result > currYear + 20) {
            result = result - 100;
        }
        return result;
    }
    function datesAreEqual(date1, date2) {
        if (date1 instanceof Date && date2 instanceof Date) {
            return (date1.getFullYear() === date2.getFullYear() &&
                date1.getMonth() === date2.getMonth() &&
                date1.getDate() === date2.getDate());
        }
        else {
            return false;
        }
    }

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DayViewModel = /** @class */ (function () {
        function DayViewModel(dayModel, isTodaysDate, isExcluded, isDisabled, isSelected, isFocusable) {
            if (isTodaysDate === void 0) { isTodaysDate = false; }
            if (isExcluded === void 0) { isExcluded = false; }
            if (isDisabled === void 0) { isDisabled = false; }
            if (isSelected === void 0) { isSelected = false; }
            if (isFocusable === void 0) { isFocusable = false; }
            this.dayModel = dayModel;
            this.isTodaysDate = isTodaysDate;
            this.isExcluded = isExcluded;
            this.isDisabled = isDisabled;
            this.isSelected = isSelected;
            this.isFocusable = isFocusable;
        }
        Object.defineProperty(DayViewModel.prototype, "tabIndex", {
            /**
             * Gets the tab index based on the isFocusable flag.
             */
            get: function () {
                return this.isFocusable ? 0 : -1;
            },
            enumerable: true,
            configurable: true
        });
        return DayViewModel;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DayModel = /** @class */ (function () {
        function DayModel(year, month, date) {
            this.year = year;
            this.month = month;
            this.date = date;
        }
        /**
         * Checks if the passed CalendarDate is equal to itself.
         */
        DayModel.prototype.isEqual = function (day) {
            if (day) {
                return this.year === day.year && this.month === day.month && this.date === day.date;
            }
            return false;
        };
        DayModel.prototype.toDate = function () {
            return new Date(this.year, this.month, this.date);
        };
        /**
         * Returns a new DayModel which is incremented based on the value passed.
         */
        DayModel.prototype.incrementBy = function (value) {
            // Creating new Javascript Date object to increment because
            // it will automatically take care of switching to next or previous
            // months & years without we having to worry about it.
            var date = new Date(this.year, this.month, this.date + value);
            return new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
        };
        /**
         * Clones the current day model.
         */
        DayModel.prototype.clone = function () {
            return new DayModel(this.year, this.month, this.date);
        };
        DayModel.prototype.toComparisonString = function () {
            return "" + this.year + this.pad(this.month) + this.pad(this.date);
        };
        DayModel.prototype.pad = function (num) {
            return num < 10 ? "0" + num : "" + num;
        };
        DayModel.prototype.toDateString = function () {
            return this.toDate().toLocaleDateString();
        };
        return DayModel;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CalendarViewModel = /** @class */ (function () {
        function CalendarViewModel(calendar, selectedDay, focusableDay, today, firstDayOfWeek, excludedDates) {
            this.calendar = calendar;
            this.selectedDay = selectedDay;
            this.focusableDay = focusableDay;
            this.today = today;
            this.firstDayOfWeek = firstDayOfWeek;
            this.excludedDates = excludedDates;
            this.currMonthDayViews = [];
            this.initializeCalendarView();
        }
        Object.defineProperty(CalendarViewModel.prototype, "calendarView", {
            /**
             * DayViewModel matrix. Size 6x7
             */
            get: function () {
                return this._calendarView;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         */
        CalendarViewModel.prototype.initializeCalendarView = function () {
            // Generate prev and next month calendar models.
            var prevMonthCalendar = this.calendar.previousMonth();
            var nextMonthCalendar = this.calendar.nextMonth();
            // Get no of days from prev and next months.
            var daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
            var daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
            // Generate prev, curr and next day view models
            var prevMonthDayViews = [];
            var nextMonthDayViews = [];
            if (daysFromPrevMonthInCalView > 0) {
                prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
            }
            this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
            if (daysFromNextMonthInCalView > 0) {
                nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
            }
            // Generate calendar view and initialize flags
            this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
            this.initializeSelectedDay();
            this.initializeFocusableDay();
        };
        CalendarViewModel.prototype.isDateExcluded = function (date) {
            var _a = this.excludedDates, minDate = _a.minDate, maxDate = _a.maxDate;
            var from = minDate.toComparisonString();
            var to = maxDate.toComparisonString();
            var today = date.toComparisonString();
            return !(today >= from && today <= to);
        };
        /**
         * Generates a DayViewModel array based on the DayModel passed
         */
        CalendarViewModel.prototype.generateDayViewModels = function (days, isExcluded, isCurrentCalendar) {
            var _this = this;
            var dayViews = days.map(function (day) {
                return new DayViewModel(day, false, isExcluded, _this.isDateExcluded(day), false, false);
            });
            if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
                dayViews[this.today.date - 1].isTodaysDate = true;
            }
            return dayViews;
        };
        /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         */
        CalendarViewModel.prototype.numDaysFromPrevMonthInCalView = function (currentYear, currentMonth) {
            var firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
            if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
                return firstDayOfCurrMonth - this.firstDayOfWeek;
            }
            else {
                return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
            }
        };
        /**
         * Checks if the Day passed is in the CalendarView.
         */
        CalendarViewModel.prototype.isDayInCalendarView = function (day) {
            if (!this.calendar.isDayInCalendar(day)) {
                return false;
            }
            return true;
        };
        /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         */
        CalendarViewModel.prototype.generateCalendarView = function (prev, curr, next) {
            var combinationArr = __spread(prev, curr, next);
            var calendarView = [];
            for (var i = 0; i < NO_OF_ROWS_IN_CALENDAR_VIEW; i++) {
                calendarView[i] = combinationArr.slice(i * NO_OF_DAYS_IN_A_WEEK, (i + 1) * NO_OF_DAYS_IN_A_WEEK);
            }
            return calendarView;
        };
        /**
         * Initialize the selected day if the day is in the calendar.
         */
        CalendarViewModel.prototype.initializeSelectedDay = function () {
            if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
                this.currMonthDayViews[this.selectedDay.date - 1].isSelected = true;
            }
        };
        /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         */
        CalendarViewModel.prototype.initializeFocusableDay = function () {
            if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
                this.setFocusableFlag(this.focusableDay, true);
            }
            else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
                this.setFocusableFlag(this.selectedDay, true);
                this.focusableDay = this.selectedDay.clone();
            }
            else if (this.isDayInCalendarView(this.today)) {
                this.setFocusableFlag(this.today, true);
                this.focusableDay = this.today.clone();
            }
            else {
                this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
                this.setFocusableFlag(this.focusableDay, true);
            }
        };
        CalendarViewModel.prototype.setFocusableFlag = function (day, flag) {
            if (day) {
                this.currMonthDayViews[day.date - 1].isFocusable = flag;
            }
        };
        /**
         * Updates the focusable day in the calendar.
         */
        CalendarViewModel.prototype.updateFocusableDay = function (day) {
            this.setFocusableFlag(this.focusableDay, false);
            this.setFocusableFlag(day, true);
            this.focusableDay = day;
        };
        return CalendarViewModel;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CalendarModel = /** @class */ (function () {
        function CalendarModel(year, month) {
            this.year = year;
            this.month = month;
            this.initializeDaysInCalendar();
        }
        /**
         * Populates the days array with the DayModels in the current Calendar.
         */
        CalendarModel.prototype.initializeDaysInCalendar = function () {
            var _this = this;
            var noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
            this.days = Array(noOfDaysInCalendar)
                .fill(null)
                .map(function (date, index) {
                return new DayModel(_this.year, _this.month, index + 1);
            });
        };
        /**
         * Checks if the calendar passed is equal to the current calendar.
         */
        CalendarModel.prototype.isEqual = function (calendar) {
            if (calendar) {
                return this.year === calendar.year && this.month === calendar.month;
            }
            return false;
        };
        /**
         * Checks if a DayModel is in the Calendar
         */
        CalendarModel.prototype.isDayInCalendar = function (day) {
            if (day) {
                return this.year === day.year && this.month === day.month;
            }
            return false;
        };
        /**
         * Returns CalendarModel of the previous month.
         */
        CalendarModel.prototype.previousMonth = function () {
            if (this.month === 0) {
                return new CalendarModel(this.year - 1, 11);
            }
            else {
                return new CalendarModel(this.year, this.month - 1);
            }
        };
        /**
         * Returns CalendarModel of the next month.
         */
        CalendarModel.prototype.nextMonth = function () {
            if (this.month === 11) {
                return new CalendarModel(this.year + 1, 0);
            }
            else {
                return new CalendarModel(this.year, this.month + 1);
            }
        };
        return CalendarModel;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This service is responsible for:
     * 1. Initializing the displayed calendar.
     * 2. Moving the calendar to the next, previous or current months
     * 3. Managing the focused and selected day models.
     */
    var DateNavigationService = /** @class */ (function () {
        function DateNavigationService() {
            /**
             * Variable to store today's date.
             */
            this._todaysFullDate = new Date();
            this._selectedDayChange = new rxjs.Subject();
            this._displayedCalendarChange = new rxjs.Subject();
            this._focusOnCalendarChange = new rxjs.Subject();
            this._focusedDayChange = new rxjs.Subject();
        }
        Object.defineProperty(DateNavigationService.prototype, "displayedCalendar", {
            get: function () {
                return this._displayedCalendar;
            },
            enumerable: true,
            configurable: true
        });
        // not a setter because i want this to remain private
        DateNavigationService.prototype.setDisplayedCalendar = function (value) {
            if (!this._displayedCalendar.isEqual(value)) {
                this._displayedCalendar = value;
                this._displayedCalendarChange.next();
            }
        };
        DateNavigationService.prototype.initializeTodaysDate = function () {
            this._todaysFullDate = new Date();
            this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
        };
        Object.defineProperty(DateNavigationService.prototype, "today", {
            get: function () {
                return this._today;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "selectedDayChange", {
            get: function () {
                return this._selectedDayChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         */
        DateNavigationService.prototype.notifySelectedDayChanged = function (dayModel) {
            this.selectedDay = dayModel;
            this._selectedDayChange.next(dayModel);
        };
        /**
         * Initializes the calendar based on the selected day.
         */
        DateNavigationService.prototype.initializeCalendar = function () {
            this.focusedDay = null; // Can be removed later on the store focus
            this.initializeTodaysDate();
            if (this.selectedDay) {
                this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
            }
            else {
                this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
            }
        };
        DateNavigationService.prototype.changeMonth = function (month) {
            this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
        };
        DateNavigationService.prototype.changeYear = function (year) {
            this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
        };
        /**
         * Moves the displayed calendar to the next month.
         */
        DateNavigationService.prototype.moveToNextMonth = function () {
            this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
        };
        /**
         * Moves the displayed calendar to the previous month.
         */
        DateNavigationService.prototype.moveToPreviousMonth = function () {
            this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
        };
        /**
         * Moves the displayed calendar to the current month and year.
         */
        DateNavigationService.prototype.moveToCurrentMonth = function () {
            if (!this.displayedCalendar.isDayInCalendar(this.today)) {
                this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
            }
            this._focusOnCalendarChange.next();
        };
        DateNavigationService.prototype.incrementFocusDay = function (value) {
            this.focusedDay = this.focusedDay.incrementBy(value);
            if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
                this._focusedDayChange.next(this.focusedDay);
            }
            else {
                this.setDisplayedCalendar(new CalendarModel(this.focusedDay.year, this.focusedDay.month));
            }
            this._focusOnCalendarChange.next();
        };
        Object.defineProperty(DateNavigationService.prototype, "displayedCalendarChange", {
            /**
             * This observable lets the subscriber know that the displayed calendar has changed.
             */
            get: function () {
                return this._displayedCalendarChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "focusOnCalendarChange", {
            /**
             * This observable lets the subscriber know that the focus should be applied on the calendar.
             */
            get: function () {
                return this._focusOnCalendarChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "focusedDayChange", {
            /**
             * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
             */
            get: function () {
                return this._focusedDayChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
DateNavigationService.ɵfac = function DateNavigationService_Factory(t) { return new (t || DateNavigationService)(); };
DateNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DateNavigationService, factory: function (t) { return DateNavigationService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateNavigationService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DateNavigationService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This service focuses the day that is focusable in the calendar.
     */
    var DatepickerFocusService = /** @class */ (function () {
        function DatepickerFocusService(_ngZone, platformId) {
            this._ngZone = _ngZone;
            this.platformId = platformId;
        }
        DatepickerFocusService.prototype.focusCell = function (elRef) {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this.ngZoneIsStableInBrowser().subscribe(function () {
                    var focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
                    if (focusEl) {
                        focusEl.focus();
                    }
                });
            });
        };
        DatepickerFocusService.prototype.focusInput = function (element) {
            var _this = this;
            this._ngZone.runOutsideAngular(function () { return _this.ngZoneIsStableInBrowser().subscribe(function () { return element.focus(); }); });
        };
        DatepickerFocusService.prototype.elementIsFocused = function (element) {
            return common.isPlatformBrowser(this.platformId) && document.activeElement === element;
        };
        DatepickerFocusService.prototype.ngZoneIsStableInBrowser = function () {
            var _this = this;
            // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
            return this._ngZone.onStable.asObservable().pipe(operators.first(), operators.filter(function () { return common.isPlatformBrowser(_this.platformId); }));
        };
        DatepickerFocusService.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        DatepickerFocusService = __decorate([ __param(1, core.Inject(core.PLATFORM_ID))
        ], DatepickerFocusService);
DatepickerFocusService.ɵfac = function DatepickerFocusService_Factory(t) { return new (t || DatepickerFocusService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
DatepickerFocusService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DatepickerFocusService, factory: function (t) { return DatepickerFocusService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatepickerFocusService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return DatepickerFocusService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This service extracts the Angular CLDR data needed by the datepicker.
     */
    var LocaleHelperService = /** @class */ (function () {
        function LocaleHelperService(locale) {
            this.locale = locale;
            this._firstDayOfWeek = 0;
            this.initializeLocaleData();
        }
        Object.defineProperty(LocaleHelperService.prototype, "firstDayOfWeek", {
            get: function () {
                return this._firstDayOfWeek;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDays", {
            get: function () {
                return this._localeDays;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDaysNarrow", {
            // leave for backward compatibility
            get: function () {
                return this._localeDays.map(function (day) { return day.narrow; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeMonthsAbbreviated", {
            get: function () {
                return this._localeMonthsAbbreviated;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeMonthsWide", {
            get: function () {
                return this._localeMonthsWide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDateFormat", {
            get: function () {
                return this._localeDateFormat;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the locale data.
         */
        LocaleHelperService.prototype.initializeLocaleData = function () {
            // Order in which these functions is called is very important.
            this.initializeFirstDayOfWeek();
            this.initializeLocaleDateFormat();
            this.initializeLocaleMonthsAbbreviated();
            this.initializeLocaleMonthsWide();
            this.initializeLocaleDays();
        };
        /**
         * Initialize day names based on the locale.
         * eg: [{day: Sunday, narrow: S}, {day: Monday, narrow: M}...] for en-US.
         */
        LocaleHelperService.prototype.initializeLocaleDays = function () {
            // Get locale day names starting with Sunday
            var tempArr = [];
            var tempWideArr = common.getLocaleDayNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Wide).slice();
            var tempNarrowArr = common.getLocaleDayNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Narrow).slice();
            // Get first day of the week based on the locale
            var firstDayOfWeek = this.firstDayOfWeek;
            for (var i = 0; i < 7; i++) {
                tempArr.push({ day: tempWideArr[i], narrow: tempNarrowArr[i] });
            }
            // Rearrange the tempArr to start with the first day of the week based on the locale.
            if (firstDayOfWeek > 0) {
                var prevDays = tempArr.splice(0, firstDayOfWeek);
                tempArr.push.apply(tempArr, __spread(prevDays));
            }
            this._localeDays = tempArr;
        };
        /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         */
        LocaleHelperService.prototype.initializeLocaleMonthsAbbreviated = function () {
            this._localeMonthsAbbreviated = common.getLocaleMonthNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Abbreviated).slice();
        };
        /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         */
        LocaleHelperService.prototype.initializeLocaleMonthsWide = function () {
            this._localeMonthsWide = common.getLocaleMonthNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Wide).slice();
        };
        /**
         * Initializes the first day of the week based on the locale.
         */
        LocaleHelperService.prototype.initializeFirstDayOfWeek = function () {
            this._firstDayOfWeek = common.getLocaleFirstDayOfWeek(this.locale);
        };
        LocaleHelperService.prototype.initializeLocaleDateFormat = function () {
            this._localeDateFormat = common.getLocaleDateFormat(this.locale, common.FormatWidth.Short);
        };
        LocaleHelperService.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [core.LOCALE_ID,] }] }
        ]; };
        LocaleHelperService = __decorate([ __param(0, core.Inject(core.LOCALE_ID))
        ], LocaleHelperService);
LocaleHelperService.ɵfac = function LocaleHelperService_Factory(t) { return new (t || LocaleHelperService)(ɵngcc0.ɵɵinject(core.LOCALE_ID)); };
LocaleHelperService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LocaleHelperService, factory: function (t) { return LocaleHelperService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocaleHelperService, [{
        type: core.Injectable
    }], function () { return [{ type: String, decorators: [{
                type: core.Inject,
                args: [core.LOCALE_ID]
            }] }]; }, null); })();
        return LocaleHelperService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DateIOService = /** @class */ (function () {
        function DateIOService(_localeHelperService) {
            this._localeHelperService = _localeHelperService;
            this.disabledDates = {
                // This is the default range. It approximates the beginning of time to the end of time.
                // Unless a minDate or maxDate is set with the native HTML5 api the range is all dates
                // TODO: turn this into an Array of min/max ranges that allow configuration of multiple ranges.
                minDate: new DayModel(0, 0, 1),
                maxDate: new DayModel(9999, 11, 31),
            };
            this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
            this.localeDisplayFormat = LITTLE_ENDIAN;
            this.delimiters = ['/', '/'];
            this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
            this.initializeLocaleDisplayFormat();
        }
        DateIOService.prototype.setMinDate = function (date) {
            // NOTE: I'm expecting consumers to pass one of four things here:
            //       A proper date string(2019-11-11), null, undefined or empty string ('')
            if (!date) {
                // attribute binding was removed, reset back to the beginning of time
                this.disabledDates.minDate = new DayModel(0, 0, 1);
            }
            else {
                var _a = __read(date.split('-').map(function (n) { return parseInt(n, 10); }), 3), year = _a[0], month = _a[1], day = _a[2];
                this.disabledDates.minDate = new DayModel(year, month - 1, day);
            }
        };
        DateIOService.prototype.setMaxDate = function (date) {
            // NOTE: I'm expecting consumers to pass one of four things here:
            //       A proper date string(2019-11-11), null, undefined or empty string ('')
            if (!date) {
                // attribute binding was removed, reset forward to the end of time
                this.disabledDates.maxDate = new DayModel(9999, 11, 31);
            }
            else {
                var _a = __read(date.split('-').map(function (n) { return parseInt(n, 10); }), 3), year = _a[0], month = _a[1], day = _a[2];
                this.disabledDates.maxDate = new DayModel(year, month - 1, day);
            }
        };
        DateIOService.prototype.initializeLocaleDisplayFormat = function () {
            var format = this.cldrLocaleDateFormat.toLocaleLowerCase();
            if (LITTLE_ENDIAN_REGEX.test(format)) {
                this.localeDisplayFormat = LITTLE_ENDIAN;
            }
            else if (MIDDLE_ENDIAN_REGEX.test(format)) {
                this.localeDisplayFormat = MIDDLE_ENDIAN;
            }
            else {
                // everything else is set to BIG-ENDIAN FORMAT
                this.localeDisplayFormat = BIG_ENDIAN;
            }
            this.extractDelimiters();
        };
        DateIOService.prototype.extractDelimiters = function () {
            if (this.cldrLocaleDateFormat) {
                // Sanitize Date Format. Remove RTL characters.
                // FIXME: When we support RTL, remove this and handle it correctly.
                var localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, '');
                var delimiters = localeFormat.split(DELIMITER_REGEX);
                // NOTE: The split from the CLDR date format should always result
                // in an arary with 4 elements. The 1st and the 2nd values are the delimiters
                // we will use in order.
                // Eg: "dd/MM/y".split(/d+|m+|y+/i) results in ["", "/", "/", ""]
                if (delimiters && delimiters.length === 4) {
                    this.delimiters = [delimiters[1], delimiters[2]];
                }
                else {
                    console.error('Unexpected date format received. Delimiters extracted: ', delimiters);
                }
            }
        };
        DateIOService.prototype.toLocaleDisplayFormatString = function (date) {
            if (date) {
                if (isNaN(date.getTime())) {
                    return '';
                }
                var dateNo = date.getDate();
                var monthNo = date.getMonth() + 1;
                var dateStr = dateNo > 9 ? dateNo.toString() : '0' + dateNo;
                var monthStr = monthNo > 9 ? monthNo.toString() : '0' + monthNo;
                if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                    return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
                }
                else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                    return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
                }
                else {
                    return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
                }
            }
            return '';
        };
        Object.defineProperty(DateIOService.prototype, "placeholderText", {
            get: function () {
                var format = this.localeDisplayFormat.format;
                return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         */
        DateIOService.prototype.isValidMonth = function (month) {
            return month > -1 && month < 12;
        };
        /**
         * Checks if the date is valid depending on the year and month provided.
         */
        DateIOService.prototype.isValidDate = function (year, month, date) {
            return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
        };
        /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         */
        DateIOService.prototype.validateAndGetDate = function (year, month, date) {
            // I don't know whats wrong with the TS compiler. It throws an error if I write
            // the below if statement. The error is:
            // Operator '!==' cannot be applied to types '2' and '4'
            // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
            /*
                if (year.length !== 2 || year.length !== 4) {
                    return null;
                }
                */
            // Instead I have to write the logic like this x-(
            var y = +year;
            var m = +month - 1; // month is 0 based
            var d = +date;
            if (!this.isValidMonth(m) || !this.isValidDate(y, m, d)) {
                return null;
            }
            var result = parseToFourDigitYear(y);
            return result !== -1 ? new Date(result, m, d) : null;
        };
        DateIOService.prototype.getDateValueFromDateString = function (date) {
            if (!date) {
                return null;
            }
            var dateParts = date.match(USER_INPUT_REGEX);
            if (!dateParts || dateParts.length !== 3) {
                return null;
            }
            var _a = __read(dateParts, 3), firstPart = _a[0], secondPart = _a[1], thirdPart = _a[2];
            if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                // secondPart is month && firstPart is date
                return this.validateAndGetDate(thirdPart, secondPart, firstPart);
            }
            else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                // firstPart is month && secondPart is date
                return this.validateAndGetDate(thirdPart, firstPart, secondPart);
            }
            else {
                // secondPart is month && thirdPart is date
                return this.validateAndGetDate(firstPart, secondPart, thirdPart);
            }
        };
        DateIOService.ctorParameters = function () { return [
            { type: LocaleHelperService }
        ]; };
DateIOService.ɵfac = function DateIOService_Factory(t) { return new (t || DateIOService)(ɵngcc0.ɵɵinject(LocaleHelperService)); };
DateIOService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DateIOService, factory: function (t) { return DateIOService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateIOService, [{
        type: core.Injectable
    }], function () { return [{ type: LocaleHelperService }]; }, null); })();
        return DateIOService;
    }());

    var ClrCalendar = /** @class */ (function () {
        function ClrCalendar(_localeHelperService, _dateNavigationService, _datepickerFocusService, _dateIOService, _elRef) {
            this._localeHelperService = _localeHelperService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerFocusService = _datepickerFocusService;
            this._dateIOService = _dateIOService;
            this._elRef = _elRef;
            this._subs = [];
            this.generateCalendarView();
            this.initializeSubscriptions();
        }
        Object.defineProperty(ClrCalendar.prototype, "localeDays", {
            /**
             * Gets the locale days according to the TranslationWidth.Narrow format.
             */
            get: function () {
                return this._localeHelperService.localeDays;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "calendar", {
            get: function () {
                return this._dateNavigationService.displayedCalendar;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "selectedDay", {
            get: function () {
                return this._dateNavigationService.selectedDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "focusedDay", {
            get: function () {
                return this._dateNavigationService.focusedDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "today", {
            get: function () {
                return this._dateNavigationService.today;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         */
        ClrCalendar.prototype.initializeSubscriptions = function () {
            var _this = this;
            this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(function () {
                _this.generateCalendarView();
            }));
            this._subs.push(this._dateNavigationService.focusedDayChange.subscribe(function (focusedDay) {
                _this.calendarViewModel.updateFocusableDay(focusedDay);
            }));
            this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(function () {
                _this._datepickerFocusService.focusCell(_this._elRef);
            }));
        };
        /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         */
        ClrCalendar.prototype.generateCalendarView = function () {
            this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek, this._dateIOService.disabledDates);
        };
        /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         */
        ClrCalendar.prototype.onKeyDown = function (event) {
            if (event && this.focusedDay) {
                switch (event.keyCode) {
                    case UP_ARROW:
                        event.preventDefault();
                        this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
                        break;
                    case DOWN_ARROW:
                        event.preventDefault();
                        this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
                        break;
                    case LEFT_ARROW:
                        event.preventDefault();
                        this._dateNavigationService.incrementFocusDay(-1);
                        break;
                    case RIGHT_ARROW:
                        event.preventDefault();
                        this._dateNavigationService.incrementFocusDay(1);
                        break;
                    default:
                        break; // No default case. TSLint x-(
                }
            }
        };
        /**
         * Focuses on the focusable day when the Calendar View is initialized.
         */
        ClrCalendar.prototype.ngAfterViewInit = function () {
            this._datepickerFocusService.focusCell(this._elRef);
        };
        /**
         * Unsubscribe from subscriptions.
         */
        ClrCalendar.prototype.ngOnDestroy = function () {
            this._subs.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrCalendar.ctorParameters = function () { return [
            { type: LocaleHelperService },
            { type: DateNavigationService },
            { type: DatepickerFocusService },
            { type: DateIOService },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], ClrCalendar.prototype, "onKeyDown", null);
ClrCalendar.ɵfac = function ClrCalendar_Factory(t) { return new (t || ClrCalendar)(ɵngcc0.ɵɵdirectiveInject(LocaleHelperService), ɵngcc0.ɵɵdirectiveInject(DateNavigationService), ɵngcc0.ɵɵdirectiveInject(DatepickerFocusService), ɵngcc0.ɵɵdirectiveInject(DateIOService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrCalendar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrCalendar, selectors: [["clr-calendar"]], hostBindings: function ClrCalendar_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ClrCalendar_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } }, decls: 4, vars: 2, consts: [[1, "calendar-table"], [1, "calendar-row", "weekdays"], ["class", "calendar-cell weekday", "role", "heading", 4, "ngFor", "ngForOf"], ["class", "calendar-row", 4, "ngFor", "ngForOf"], ["role", "heading", 1, "calendar-cell", "weekday"], [1, "calendar-row"], ["class", "calendar-cell", 4, "ngFor", "ngForOf"], [1, "calendar-cell"], [3, "clrDayView"]], template: function ClrCalendar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵelementStart(1, "tr", 1);
        ɵngcc0.ɵɵtemplate(2, ClrCalendar_td_2_Template, 2, 2, "td", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ClrCalendar_tr_3_Template, 2, 1, "tr", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.localeDays);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.calendarViewModel.calendarView);
    } }, directives: function () { return [ɵngcc1.NgForOf, ClrDay]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCalendar, [{
        type: core.Component,
        args: [{ selector: 'clr-calendar', template: "<table class=\"calendar-table\">\n    <tr class=\"calendar-row weekdays\">\n        <td *ngFor=\"let day of localeDays\" class=\"calendar-cell weekday\" role=\"heading\" [attr.aria-label]=\"day.day\">\n            {{day.narrow}}\n        </td>\n    </tr>\n    <tr class=\"calendar-row\" *ngFor=\"let row of calendarViewModel.calendarView\">\n        <td *ngFor=\"let dayView of row\" class=\"calendar-cell\">\n            <clr-day [clrDayView]=\"dayView\"></clr-day>\n        </td>\n    </tr>\n</table>\n" }]
    }], function () { return [{ type: LocaleHelperService }, { type: DateNavigationService }, { type: DatepickerFocusService }, { type: DateIOService }, { type: ɵngcc0.ElementRef }]; }, { onKeyDown: [{
            type: core.HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
        return ClrCalendar;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var FocusService = /** @class */ (function () {
        function FocusService() {
            this._focused = new rxjs.BehaviorSubject(false);
        }
        Object.defineProperty(FocusService.prototype, "focusChange", {
            get: function () {
                return this._focused.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusService.prototype, "focused", {
            set: function (state) {
                this._focused.next(state);
            },
            enumerable: true,
            configurable: true
        });
FocusService.ɵfac = function FocusService_Factory(t) { return new (t || FocusService)(); };
FocusService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FocusService, factory: function (t) { return FocusService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return FocusService;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DateFormControlService = /** @class */ (function () {
        function DateFormControlService() {
            this._touchedChange = new rxjs.Subject();
            this._dirtyChange = new rxjs.Subject();
        }
        Object.defineProperty(DateFormControlService.prototype, "touchedChange", {
            get: function () {
                return this._touchedChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateFormControlService.prototype, "dirtyChange", {
            get: function () {
                return this._dirtyChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DateFormControlService.prototype.markAsTouched = function () {
            this._touchedChange.next();
        };
        DateFormControlService.prototype.markAsDirty = function () {
            this._dirtyChange.next();
        };
        // friendly wrapper
        DateFormControlService.prototype.setDisabled = function (state) {
            this.disabled = state;
        };
DateFormControlService.ɵfac = function DateFormControlService_Factory(t) { return new (t || DateFormControlService)(); };
DateFormControlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DateFormControlService, factory: function (t) { return DateFormControlService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateFormControlService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DateFormControlService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // iPad mini screen width
    // http://stephen.io/mediaqueries/#iPadMini
    var DATEPICKER_ENABLE_BREAKPOINT = 768;

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatepickerEnabledService = /** @class */ (function () {
        function DatepickerEnabledService(_document) {
            this._document = _document;
            this._isUserAgentMobile = false;
            if (this._document) {
                this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
                this._innerWidth = _document.defaultView.innerWidth;
            }
        }
        Object.defineProperty(DatepickerEnabledService.prototype, "isEnabled", {
            /**
             * Returns if the calendar should be active or not.
             * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
             * then the calendar is inactive.
             */
            get: function () {
                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
                // What they recommend is:
                //"In summary, we recommend looking for the string 'Mobi'
                // anywhere in the User Agent to detect a mobile device."
                if (this._document) {
                    if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
                        return false;
                    }
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        DatepickerEnabledService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        DatepickerEnabledService = __decorate([ __param(0, core.Inject(common.DOCUMENT))
        ], DatepickerEnabledService);
DatepickerEnabledService.ɵfac = function DatepickerEnabledService_Factory(t) { return new (t || DatepickerEnabledService)(ɵngcc0.ɵɵinject(common.DOCUMENT)); };
DatepickerEnabledService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DatepickerEnabledService, factory: function (t) { return DatepickerEnabledService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatepickerEnabledService, [{
        type: core.Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }]; }, null); })();
        return DatepickerEnabledService;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This service manages which view is visible in the datepicker popover.
     */
    var ViewManagerService = /** @class */ (function () {
        function ViewManagerService() {
            this._currentView = "DAYVIEW" /* DAYVIEW */;
            this.position = ClrPopoverPositions['bottom-left'];
        }
        Object.defineProperty(ViewManagerService.prototype, "isDayView", {
            get: function () {
                return this._currentView === "DAYVIEW" /* DAYVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewManagerService.prototype, "isYearView", {
            get: function () {
                return this._currentView === "YEARVIEW" /* YEARVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewManagerService.prototype, "isMonthView", {
            get: function () {
                return this._currentView === "MONTHVIEW" /* MONTHVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        ViewManagerService.prototype.changeToMonthView = function () {
            this._currentView = "MONTHVIEW" /* MONTHVIEW */;
        };
        ViewManagerService.prototype.changeToYearView = function () {
            this._currentView = "YEARVIEW" /* YEARVIEW */;
        };
        ViewManagerService.prototype.changeToDayView = function () {
            this._currentView = "DAYVIEW" /* DAYVIEW */;
        };
ViewManagerService.ɵfac = function ViewManagerService_Factory(t) { return new (t || ViewManagerService)(); };
ViewManagerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ViewManagerService, factory: function (t) { return ViewManagerService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ViewManagerService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ViewManagerService;
    }());

    var ClrDateContainer = /** @class */ (function () {
        function ClrDateContainer(toggleService, dateNavigationService, datepickerEnabledService, dateFormControlService, commonStrings, ifErrorService, focusService, viewManagerService, controlClassService, layoutService, ngControlService) {
            var _this = this;
            this.toggleService = toggleService;
            this.dateNavigationService = dateNavigationService;
            this.datepickerEnabledService = datepickerEnabledService;
            this.dateFormControlService = dateFormControlService;
            this.commonStrings = commonStrings;
            this.ifErrorService = ifErrorService;
            this.focusService = focusService;
            this.viewManagerService = viewManagerService;
            this.controlClassService = controlClassService;
            this.layoutService = layoutService;
            this.ngControlService = ngControlService;
            this._dynamic = false;
            this.invalid = false;
            this.focus = false;
            this.subscriptions = [];
            this.subscriptions.push(this.focusService.focusChange.subscribe(function (state) {
                _this.focus = state;
            }), this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }), this.toggleService.openChange.subscribe(function (state) {
                _this.dateFormControlService.markAsTouched();
            }));
        }
        Object.defineProperty(ClrDateContainer.prototype, "clrPosition", {
            set: function (position) {
                if (position && ClrPopoverPositions[position]) {
                    this.viewManagerService.position = ClrPopoverPositions[position];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateContainer.prototype, "popoverPosition", {
            get: function () {
                return this.viewManagerService.position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateContainer.prototype, "open", {
            get: function () {
                return this.toggleService.open;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateContainer.prototype, "actionButton", {
            set: function (button) {
                this.toggleButton = button;
            },
            enumerable: true,
            configurable: true
        });
        ClrDateContainer.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
                _this.invalid = invalid;
            }));
        };
        ClrDateContainer.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.subscriptions.push(this.toggleService.openChange.subscribe(function (open) {
                if (open) {
                    _this.initializeCalendar();
                }
                else {
                    _this.toggleButton.nativeElement.focus();
                }
            }));
        };
        /**
         * Returns the classes to apply to the control
         */
        ClrDateContainer.prototype.controlClass = function () {
            return this.controlClassService.controlClass(this.invalid, this.addGrid());
        };
        /**
         * Determines if the control needs to add grid classes
         */
        ClrDateContainer.prototype.addGrid = function () {
            return this.layoutService && !this.layoutService.isVertical();
        };
        Object.defineProperty(ClrDateContainer.prototype, "isEnabled", {
            /**
             * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
             */
            get: function () {
                return this.datepickerEnabledService.isEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateContainer.prototype, "isInputDateDisabled", {
            /**
             * Return if Datepicker is diabled or not as Form Control
             */
            get: function () {
                /* clrForm wrapper or without clrForm */
                return ((this.control && this.control.disabled) || (this.dateFormControlService && this.dateFormControlService.disabled));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         */
        ClrDateContainer.prototype.initializeCalendar = function () {
            this.dateNavigationService.initializeCalendar();
        };
        /**
         * Unsubscribe from subscriptions.
         */
        ClrDateContainer.prototype.ngOnDestroy = function () {
            this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
        };
        ClrDateContainer.ctorParameters = function () { return [
            { type: ClrPopoverToggleService },
            { type: DateNavigationService },
            { type: DatepickerEnabledService },
            { type: DateFormControlService },
            { type: ClrCommonStringsService },
            { type: IfErrorService },
            { type: FocusService },
            { type: ViewManagerService },
            { type: ControlClassService },
            { type: LayoutService, decorators: [{ type: core.Optional }] },
            { type: NgControlService }
        ]; };
        __decorate([
            core.ContentChild(ClrLabel)
        ], ClrDateContainer.prototype, "label", void 0);
        __decorate([
            core.Input('clrPosition')
        ], ClrDateContainer.prototype, "clrPosition", null);
        __decorate([
            core.ViewChild('actionButton')
        ], ClrDateContainer.prototype, "actionButton", null);
        ClrDateContainer = __decorate([ __param(9, core.Optional())
        ], ClrDateContainer);
ClrDateContainer.ɵfac = function ClrDateContainer_Factory(t) { return new (t || ClrDateContainer)(ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(DateNavigationService), ɵngcc0.ɵɵdirectiveInject(DatepickerEnabledService), ɵngcc0.ɵɵdirectiveInject(DateFormControlService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(IfErrorService), ɵngcc0.ɵɵdirectiveInject(FocusService), ɵngcc0.ɵɵdirectiveInject(ViewManagerService), ɵngcc0.ɵɵdirectiveInject(ControlClassService), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(NgControlService)); };
ClrDateContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDateContainer, selectors: [["clr-date-container"]], contentQueries: function ClrDateContainer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
    } }, viewQuery: function ClrDateContainer_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.actionButton = _t.first);
    } }, hostVars: 6, hostBindings: function ClrDateContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control-disabled", ctx.isInputDateDisabled)("clr-form-control", true)("clr-row", ctx.addGrid());
    } }, inputs: { clrPosition: "clrPosition" }, features: [ɵngcc0.ɵɵProvidersFeature([
            ControlIdService,
            ClrPopoverToggleService,
            ClrPopoverEventsService,
            ClrPopoverPositionService,
            LocaleHelperService,
            IfErrorService,
            ControlClassService,
            FocusService,
            NgControlService,
            DateIOService,
            DateNavigationService,
            DatepickerEnabledService,
            DateFormControlService,
            ViewManagerService,
        ])], ngContentSelectors: _c11, decls: 11, vars: 11, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["clrPopoverAnchor", "", 1, "clr-input-wrapper"], [1, "clr-input-group"], ["type", "button", "clrPopoverOpenCloseButton", "", "class", "clr-input-group-icon-action", 3, "disabled", 4, "ngIf"], ["clrFocusTrap", "", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["shape", "exclamation-circle", 1, "clr-validate-icon"], ["type", "button", "clrPopoverOpenCloseButton", "", 1, "clr-input-group-icon-action", 3, "disabled"], ["actionButton", ""], ["shape", "calendar"], ["clrFocusTrap", ""]], template: function ClrDateContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c10);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrDateContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵtemplate(6, ClrDateContainer_button_6_Template, 3, 3, "button", 4);
        ɵngcc0.ɵɵtemplate(7, ClrDateContainer_clr_datepicker_view_manager_7_Template, 1, 0, "clr-datepicker-view-manager", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(8, "clr-icon", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, ClrDateContainer_9_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(10, ClrDateContainer_10_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("clr-focus", ctx.focus);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.popoverPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrPopoverAnchor,
        ClrPopoverContent,
        ClrIconCustomTag,
        ClrLabel,
        ClrPopoverOpenCloseButton,
        ClrDatepickerViewManager,
        FocusTrapDirective]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDateContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-date-container',
                template: "\n      <ng-content select=\"label\"></ng-content>\n      <label *ngIf=\"!label && addGrid()\"></label>\n      <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n        <div class=\"clr-input-wrapper\" clrPopoverAnchor>\n          <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n            <ng-content select=\"[clrDate]\"></ng-content>\n            <button #actionButton\n                    type=\"button\"\n                    clrPopoverOpenCloseButton\n                    class=\"clr-input-group-icon-action\"\n                    [attr.title]=\"commonStrings.keys.datepickerToggle\"\n                    [attr.aria-label]=\"commonStrings.keys.datepickerToggle\"\n                    [disabled]=\"isInputDateDisabled\"\n                    *ngIf=\"isEnabled\">\n              <clr-icon shape=\"calendar\"></clr-icon>\n            </button>\n            <clr-datepicker-view-manager *clrPopoverContent=\"open at popoverPosition; outsideClickToClose: true; scrollToClose: true\" clrFocusTrap></clr-datepicker-view-manager>\n          </div>\n          <clr-icon class=\"clr-validate-icon\" shape=\"exclamation-circle\"></clr-icon>\n        </div>\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    ",
                providers: [
                    ControlIdService,
                    ClrPopoverToggleService,
                    ClrPopoverEventsService,
                    ClrPopoverPositionService,
                    LocaleHelperService,
                    IfErrorService,
                    ControlClassService,
                    FocusService,
                    NgControlService,
                    DateIOService,
                    DateNavigationService,
                    DatepickerEnabledService,
                    DateFormControlService,
                    ViewManagerService,
                ],
                host: {
                    '[class.clr-form-control-disabled]': 'isInputDateDisabled',
                    '[class.clr-form-control]': 'true',
                    '[class.clr-row]': 'addGrid()'
                }
            }]
    }], function () { return [{ type: ClrPopoverToggleService }, { type: DateNavigationService }, { type: DatepickerEnabledService }, { type: DateFormControlService }, { type: ClrCommonStringsService }, { type: IfErrorService }, { type: FocusService }, { type: ViewManagerService }, { type: ControlClassService }, { type: LayoutService, decorators: [{
                type: core.Optional
            }] }, { type: NgControlService }]; }, { clrPosition: [{
            type: core.Input,
            args: ['clrPosition']
        }], actionButton: [{
            type: core.ViewChild,
            args: ['actionButton']
        }], label: [{
            type: core.ContentChild,
            args: [ClrLabel]
        }] }); })();
        return ClrDateContainer;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function isBooleanAttributeSet(value) {
        // for null just return false no need to check anything
        if (value === null) {
            return false;
        }
        if (typeof value === 'string') {
            // Empty string is valid, 'true' as string is also valid
            return value.length >= 0;
        }
        // Boolean value will be read as it is, everything else is false
        return typeof value === 'boolean' ? value : false;
    }

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // There are four ways the datepicker value is set
    // 1. Value set by user typing into text input as a string ex: '01/28/2015'
    // 2. Value set explicitly by Angular Forms APIs as a string ex: '01/28/2015'
    // 3. Value set by user via datepicker UI as a Date Object
    // 4. Value set via `clrDate` input as a Date Object
    var ClrDateInput = /** @class */ (function (_super) {
        __extends(ClrDateInput, _super);
        function ClrDateInput(viewContainerRef, injector, el, renderer, control, container, dateIOService, dateNavigationService, datepickerEnabledService, dateFormControlService, platformId, focusService, datepickerFocusService) {
            var _this = _super.call(this, viewContainerRef, ClrDateContainer, injector, control, renderer, el) || this;
            _this.el = el;
            _this.renderer = renderer;
            _this.control = control;
            _this.container = container;
            _this.dateIOService = dateIOService;
            _this.dateNavigationService = dateNavigationService;
            _this.datepickerEnabledService = datepickerEnabledService;
            _this.dateFormControlService = dateFormControlService;
            _this.platformId = platformId;
            _this.focusService = focusService;
            _this.datepickerFocusService = datepickerFocusService;
            _this.dateChange = new core.EventEmitter(false);
            _this.index = 1;
            return _this;
        }
        Object.defineProperty(ClrDateInput.prototype, "date", {
            set: function (date) {
                if (this.previousDateChange !== date) {
                    this.updateDate(this.getValidDateValueFromDate(date));
                }
                if (!this.initialClrDateInputValue) {
                    this.initialClrDateInputValue = date;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateInput.prototype, "min", {
            set: function (dateString) {
                this.dateIOService.setMinDate(dateString);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateInput.prototype, "max", {
            set: function (dateString) {
                this.dateIOService.setMaxDate(dateString);
            },
            enumerable: true,
            configurable: true
        });
        ClrDateInput.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.populateServicesFromContainerComponent();
            this.subscriptions.push(this.listenForUserSelectedDayChanges(), this.listenForControlValueChanges(), this.listenForTouchChanges(), this.listenForDirtyChanges(), this.listenForInputRefocus());
        };
        ClrDateInput.prototype.ngAfterViewInit = function () {
            // I don't know why I have to do this but after using the new HostWrapping Module I have to delay the processing
            // of the initial Input set by the user to here. If I do not 2 issues occur:
            // 1. The Input setter is called before ngOnInit. ngOnInit initializes the services without which the setter fails.
            // 2. The Renderer doesn't work before ngAfterViewInit (It used to before the new HostWrapping Module for some reason).
            // I need the renderer to set the value property on the input to make sure that if the user has supplied a Date
            // input object, we reflect it with the right date on the input field using the IO service. I am not sure if
            // these are major issues or not but just noting them down here.
            this.processInitialInputs();
        };
        ClrDateInput.prototype.setFocusStates = function () {
            this.setFocus(true);
        };
        ClrDateInput.prototype.triggerValidation = function () {
            _super.prototype.triggerValidation.call(this);
            this.setFocus(false);
        };
        Object.defineProperty(ClrDateInput.prototype, "placeholderText", {
            get: function () {
                return this.placeholder ? this.placeholder : this.dateIOService.placeholderText;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateInput.prototype, "inputType", {
            get: function () {
                return common.isPlatformBrowser(this.platformId) && this.usingNativeDatepicker() ? 'date' : 'text';
            },
            enumerable: true,
            configurable: true
        });
        ClrDateInput.prototype.onValueChange = function (target) {
            var validDateValue = this.dateIOService.getDateValueFromDateString(target.value);
            if (this.usingClarityDatepicker() && validDateValue) {
                this.updateDate(validDateValue, true);
            }
            else if (this.usingNativeDatepicker()) {
                var _a = __read(target.value.split('-'), 3), year = _a[0], month = _a[1], day = _a[2];
                this.updateDate(new Date(+year, +month - 1, +day), true);
            }
            else {
                this.emitDateOutput(null);
            }
        };
        Object.defineProperty(ClrDateInput.prototype, "disabled", {
            get: function () {
                if (this.dateFormControlService) {
                    return this.dateFormControlService.disabled;
                }
                return null;
            },
            set: function (value) {
                if (this.dateFormControlService) {
                    this.dateFormControlService.setDisabled(isBooleanAttributeSet(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDateInput.prototype.usingClarityDatepicker = function () {
            return this.datepickerEnabledService.isEnabled;
        };
        ClrDateInput.prototype.usingNativeDatepicker = function () {
            return !this.datepickerEnabledService.isEnabled;
        };
        ClrDateInput.prototype.setFocus = function (focus) {
            if (this.focusService) {
                this.focusService.focused = focus;
            }
        };
        ClrDateInput.prototype.populateServicesFromContainerComponent = function () {
            if (!this.container) {
                this.dateIOService = this.getProviderFromContainer(DateIOService);
                this.dateNavigationService = this.getProviderFromContainer(DateNavigationService);
                this.datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
                this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
            }
        };
        ClrDateInput.prototype.processInitialInputs = function () {
            if (this.datepickerHasFormControl()) {
                this.updateDate(this.dateIOService.getDateValueFromDateString(this.control.value));
            }
            else {
                this.updateDate(this.initialClrDateInputValue);
            }
        };
        ClrDateInput.prototype.updateDate = function (value, setByUserInteraction) {
            if (setByUserInteraction === void 0) { setByUserInteraction = false; }
            var date = this.getValidDateValueFromDate(value);
            if (setByUserInteraction) {
                this.emitDateOutput(date);
            }
            else {
                this.previousDateChange = date;
            }
            if (this.dateNavigationService) {
                this.dateNavigationService.selectedDay = date
                    ? new DayModel(date.getFullYear(), date.getMonth(), date.getDate())
                    : null;
            }
            this.updateInput(date);
        };
        ClrDateInput.prototype.updateInput = function (date) {
            if (date) {
                var dateString = this.dateIOService.toLocaleDisplayFormatString(date);
                if (this.usingNativeDatepicker()) {
                    // valueAsDate expects UTC, date from input is time-zoned
                    date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
                    this.renderer.setProperty(this.el.nativeElement, 'valueAsDate', date);
                }
                else if (this.datepickerHasFormControl() && dateString !== this.control.value) {
                    this.control.control.setValue(dateString);
                }
                else {
                    this.renderer.setProperty(this.el.nativeElement, 'value', dateString);
                }
            }
            else {
                this.renderer.setProperty(this.el.nativeElement, 'value', '');
            }
        };
        ClrDateInput.prototype.getValidDateValueFromDate = function (date) {
            if (this.dateIOService) {
                var dateString = this.dateIOService.toLocaleDisplayFormatString(date);
                return this.dateIOService.getDateValueFromDateString(dateString);
            }
            else {
                return null;
            }
        };
        ClrDateInput.prototype.emitDateOutput = function (date) {
            if (!datesAreEqual(date, this.previousDateChange)) {
                this.dateChange.emit(date);
                this.previousDateChange = date;
            }
            else if (!date && this.previousDateChange) {
                this.dateChange.emit(null);
                this.previousDateChange = null;
            }
        };
        ClrDateInput.prototype.datepickerHasFormControl = function () {
            return !!this.control;
        };
        ClrDateInput.prototype.listenForControlValueChanges = function () {
            var _this = this;
            return rxjs.of(this.datepickerHasFormControl())
                .pipe(operators.filter(function (hasControl) { return hasControl; }), operators.switchMap(function () { return _this.control.valueChanges; }), 
            // only update date value if not being set by user
            operators.filter(function () { return !_this.datepickerFocusService.elementIsFocused(_this.el.nativeElement); }))
                .subscribe(function (value) { return _this.updateDate(_this.dateIOService.getDateValueFromDateString(value)); });
        };
        ClrDateInput.prototype.listenForUserSelectedDayChanges = function () {
            var _this = this;
            return this.dateNavigationService.selectedDayChange.subscribe(function (dayModel) { return _this.updateDate(dayModel.toDate(), true); });
        };
        ClrDateInput.prototype.listenForTouchChanges = function () {
            var _this = this;
            return this.dateFormControlService.touchedChange
                .pipe(operators.filter(function () { return _this.datepickerHasFormControl(); }))
                .subscribe(function () { return _this.control.control.markAsTouched(); });
        };
        ClrDateInput.prototype.listenForDirtyChanges = function () {
            var _this = this;
            return this.dateFormControlService.dirtyChange
                .pipe(operators.filter(function () { return _this.datepickerHasFormControl(); }))
                .subscribe(function () { return _this.control.control.markAsDirty(); });
        };
        ClrDateInput.prototype.listenForInputRefocus = function () {
            var _this = this;
            return this.dateNavigationService.selectedDayChange
                .pipe(operators.filter(function (date) { return !!date; }))
                .subscribe(function (v) { return _this.datepickerFocusService.focusInput(_this.el.nativeElement); });
        };
        ClrDateInput.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: ClrDateContainer, decorators: [{ type: core.Optional }] },
            { type: DateIOService, decorators: [{ type: core.Optional }] },
            { type: DateNavigationService, decorators: [{ type: core.Optional }] },
            { type: DatepickerEnabledService, decorators: [{ type: core.Optional }] },
            { type: DateFormControlService, decorators: [{ type: core.Optional }] },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: FocusService, decorators: [{ type: core.Optional }] },
            { type: DatepickerFocusService }
        ]; };
        __decorate([
            core.Input()
        ], ClrDateInput.prototype, "placeholder", void 0);
        __decorate([
            core.Output('clrDateChange')
        ], ClrDateInput.prototype, "dateChange", void 0);
        __decorate([
            core.Input('clrDate')
        ], ClrDateInput.prototype, "date", null);
        __decorate([
            core.Input()
        ], ClrDateInput.prototype, "min", null);
        __decorate([
            core.Input()
        ], ClrDateInput.prototype, "max", null);
        __decorate([
            core.HostListener('focus')
        ], ClrDateInput.prototype, "setFocusStates", null);
        __decorate([
            core.HostListener('blur')
        ], ClrDateInput.prototype, "triggerValidation", null);
        __decorate([
            core.HostBinding('attr.placeholder')
        ], ClrDateInput.prototype, "placeholderText", null);
        __decorate([
            core.HostBinding('attr.type')
        ], ClrDateInput.prototype, "inputType", null);
        __decorate([
            core.HostListener('change', ['$event.target'])
        ], ClrDateInput.prototype, "onValueChange", null);
        __decorate([
            core.HostBinding('disabled'),
            core.Input('disabled')
        ], ClrDateInput.prototype, "disabled", null);
        ClrDateInput = __decorate([ __param(4, core.Self()),
            __param(4, core.Optional()),
            __param(5, core.Optional()),
            __param(6, core.Optional()),
            __param(7, core.Optional()),
            __param(8, core.Optional()),
            __param(9, core.Optional()),
            __param(10, core.Inject(core.PLATFORM_ID)),
            __param(11, core.Optional())
        ], ClrDateInput);
ClrDateInput.ɵfac = function ClrDateInput_Factory(t) { return new (t || ClrDateInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ClrDateContainer, 8), ɵngcc0.ɵɵdirectiveInject(DateIOService, 8), ɵngcc0.ɵɵdirectiveInject(DateNavigationService, 8), ɵngcc0.ɵɵdirectiveInject(DatepickerEnabledService, 8), ɵngcc0.ɵɵdirectiveInject(DateFormControlService, 8), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(FocusService, 8), ɵngcc0.ɵɵdirectiveInject(DatepickerFocusService)); };
ClrDateInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDateInput, selectors: [["", "clrDate", ""]], hostVars: 5, hostBindings: function ClrDateInput_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function ClrDateInput_focus_HostBindingHandler() { return ctx.setFocusStates(); })("blur", function ClrDateInput_blur_HostBindingHandler() { return ctx.triggerValidation(); })("change", function ClrDateInput_change_HostBindingHandler($event) { return ctx.onValueChange($event.target); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholderText)("type", ctx.inputType);
        ɵngcc0.ɵɵclassProp("clr-input", true);
    } }, inputs: { date: ["clrDate", "date"], min: "min", max: "max", disabled: "disabled", placeholder: "placeholder" }, outputs: { dateChange: "clrDateChange" }, features: [ɵngcc0.ɵɵProvidersFeature([DatepickerFocusService]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDateInput, [{
        type: core.Directive,
        args: [{
                selector: '[clrDate]',
                host: {
                    '[class.clr-input]': 'true'
                },
                providers: [DatepickerFocusService]
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ClrDateContainer, decorators: [{
                type: core.Optional
            }] }, { type: DateIOService, decorators: [{
                type: core.Optional
            }] }, { type: DateNavigationService, decorators: [{
                type: core.Optional
            }] }, { type: DatepickerEnabledService, decorators: [{
                type: core.Optional
            }] }, { type: DateFormControlService, decorators: [{
                type: core.Optional
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: FocusService, decorators: [{
                type: core.Optional
            }] }, { type: DatepickerFocusService }]; }, { date: [{
            type: core.Input,
            args: ['clrDate']
        }], min: [{
            type: core.Input
        }], max: [{
            type: core.Input
        }], setFocusStates: [{
            type: core.HostListener,
            args: ['focus']
        }], triggerValidation: [{
            type: core.HostListener,
            args: ['blur']
        }], placeholderText: [{
            type: core.HostBinding,
            args: ['attr.placeholder']
        }], inputType: [{
            type: core.HostBinding,
            args: ['attr.type']
        }], onValueChange: [{
            type: core.HostListener,
            args: ['change', ['$event.target']]
        }], disabled: [{
            type: core.HostBinding,
            args: ['disabled']
        }, {
            type: core.Input,
            args: ['disabled']
        }], placeholder: [{
            type: core.Input
        }], dateChange: [{
            type: core.Output,
            args: ['clrDateChange']
        }] }); })();
        return ClrDateInput;
    }(WrappedFormControl));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDatepickerViewManager = /** @class */ (function () {
        function ClrDatepickerViewManager(viewManagerService) {
            this.viewManagerService = viewManagerService;
        }
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isMonthView", {
            /**
             * Returns if the current view is the monthpicker.
             */
            get: function () {
                return this.viewManagerService.isMonthView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isYearView", {
            /**
             * Returns if the current view is the yearpicker.
             */
            get: function () {
                return this.viewManagerService.isYearView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isDayView", {
            /**
             * Returns if the current view is the daypicker.
             */
            get: function () {
                return this.viewManagerService.isDayView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatepickerViewManager.ctorParameters = function () { return [
            { type: ViewManagerService }
        ]; };
ClrDatepickerViewManager.ɵfac = function ClrDatepickerViewManager_Factory(t) { return new (t || ClrDatepickerViewManager)(ɵngcc0.ɵɵdirectiveInject(ViewManagerService)); };
ClrDatepickerViewManager.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatepickerViewManager, selectors: [["clr-datepicker-view-manager"]], hostVars: 3, hostBindings: function ClrDatepickerViewManager_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-modal", true);
        ɵngcc0.ɵɵclassProp("datepicker", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([DatepickerFocusService])], decls: 3, vars: 3, consts: [[4, "ngIf"]], template: function ClrDatepickerViewManager_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ClrDatepickerViewManager_clr_monthpicker_0_Template, 1, 0, "clr-monthpicker", 0);
        ɵngcc0.ɵɵtemplate(1, ClrDatepickerViewManager_clr_yearpicker_1_Template, 1, 0, "clr-yearpicker", 0);
        ɵngcc0.ɵɵtemplate(2, ClrDatepickerViewManager_clr_daypicker_2_Template, 1, 0, "clr-daypicker", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isMonthView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isYearView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDayView);
    } }, directives: function () { return [ɵngcc1.NgIf, ClrMonthpicker,
        ClrYearpicker,
        ClrDaypicker]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatepickerViewManager, [{
        type: core.Component,
        args: [{
                selector: 'clr-datepicker-view-manager',
                template: "<!--\n* Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n* This software is released under MIT license.\n* The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf=\"isMonthView\"></clr-monthpicker>\n<clr-yearpicker *ngIf=\"isYearView\"></clr-yearpicker>\n<clr-daypicker *ngIf=\"isDayView\"></clr-daypicker>\n",
                providers: [DatepickerFocusService],
                host: {
                    '[class.datepicker]': 'true',
                    '[attr.aria-modal]': 'true'
                }
            }]
    }], function () { return [{ type: ViewManagerService }]; }, null); })();
        return ClrDatepickerViewManager;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDay = /** @class */ (function () {
        function ClrDay(_dateNavigationService, _toggleService, dateFormControlService) {
            this._dateNavigationService = _dateNavigationService;
            this._toggleService = _toggleService;
            this.dateFormControlService = dateFormControlService;
        }
        Object.defineProperty(ClrDay.prototype, "dayView", {
            get: function () {
                return this._dayView;
            },
            /**
             * DayViewModel input which is used to build the Day View.
             */
            set: function (day) {
                this._dayView = day;
                this.dayString = this._dayView.dayModel.toDateString();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         */
        ClrDay.prototype.onDayViewFocus = function () {
            this._dateNavigationService.focusedDay = this.dayView.dayModel;
        };
        /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         */
        ClrDay.prototype.selectDay = function () {
            var day = this.dayView.dayModel;
            this._dateNavigationService.notifySelectedDayChanged(day);
            this.dateFormControlService.markAsDirty();
            this._toggleService.open = false;
        };
        ClrDay.ctorParameters = function () { return [
            { type: DateNavigationService },
            { type: ClrPopoverToggleService },
            { type: DateFormControlService }
        ]; };
        __decorate([
            core.Input('clrDayView')
        ], ClrDay.prototype, "dayView", null);
ClrDay.ɵfac = function ClrDay_Factory(t) { return new (t || ClrDay)(ɵngcc0.ɵɵdirectiveInject(DateNavigationService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(DateFormControlService)); };
ClrDay.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDay, selectors: [["clr-day"]], hostVars: 2, hostBindings: function ClrDay_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("day", true);
    } }, inputs: { dayView: ["clrDayView", "dayView"] }, decls: 2, vars: 11, consts: [["type", "button", 1, "day-btn", 3, "click", "focus"]], template: function ClrDay_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ClrDay_Template_button_click_0_listener() { return ctx.selectDay(); })("focus", function ClrDay_Template_button_focus_0_listener() { return ctx.onDayViewFocus(); });
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("is-today", ctx.dayView.isTodaysDate)("is-excluded", ctx.dayView.isExcluded)("is-disabled", ctx.dayView.isDisabled)("is-selected", ctx.dayView.isSelected);
        ɵngcc0.ɵɵattribute("tabindex", ctx.dayView.tabIndex)("aria-label", ctx.dayString);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.dayView.dayModel.date, " ");
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDay, [{
        type: core.Component,
        args: [{
                selector: 'clr-day',
                template: "\n        <button\n            class=\"day-btn\"\n            type=\"button\"\n            [class.is-today]=\"dayView.isTodaysDate\"\n            [class.is-excluded]=\"dayView.isExcluded\"\n            [class.is-disabled]=\"dayView.isDisabled\"\n            [class.is-selected]=\"dayView.isSelected\"\n            [attr.tabindex]=\"dayView.tabIndex\"\n            (click)=\"selectDay()\"\n            (focus)=\"onDayViewFocus()\"\n            [attr.aria-label]=\"dayString\">\n            {{dayView.dayModel.date}}\n        </button>\n    ",
                host: { '[class.day]': 'true' }
            }]
    }], function () { return [{ type: DateNavigationService }, { type: ClrPopoverToggleService }, { type: DateFormControlService }]; }, { dayView: [{
            type: core.Input,
            args: ['clrDayView']
        }] }); })();
        return ClrDay;
    }());

    var ClrDaypicker = /** @class */ (function () {
        function ClrDaypicker(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings, ariaLiveService) {
            this._viewManagerService = _viewManagerService;
            this._dateNavigationService = _dateNavigationService;
            this._localeHelperService = _localeHelperService;
            this.commonStrings = commonStrings;
            this.ariaLiveService = ariaLiveService;
        }
        ClrDaypicker.prototype.ngAfterViewInit = function () {
            /** @deprecated since 3.0, remove in 4.0 */
            this.ariaLiveService.announce(this.ariaLiveMonth + " " + this.updateAriaLiveYear);
        };
        Object.defineProperty(ClrDaypicker.prototype, "monthAttrString", {
            get: function () {
                return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectMonthText, {
                    CALENDAR_MONTH: this.calendarMonth,
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "yearAttrString", {
            get: function () {
                return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectYearText, {
                    CALENDAR_YEAR: this.calendarYear.toString(),
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "ariaLiveMonth", {
            get: function () {
                return this.commonStrings.parse(this.commonStrings.keys.daypickerSRCurrentMonthPhrase, {
                    CURRENT_MONTH: this.calendarMonth,
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "updateAriaLiveYear", {
            get: function () {
                return this.commonStrings.parse(this.commonStrings.keys.daypickerSRCurrentYearPhrase, {
                    CURRENT_YEAR: this.calendarYear.toString(),
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the ViewManagerService to change to the monthpicker view.
         */
        ClrDaypicker.prototype.changeToMonthView = function () {
            this._viewManagerService.changeToMonthView();
        };
        /**
         * Calls the ViewManagerService to change to the yearpicker view.
         */
        ClrDaypicker.prototype.changeToYearView = function () {
            this._viewManagerService.changeToYearView();
        };
        Object.defineProperty(ClrDaypicker.prototype, "calendarMonth", {
            /**
             * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
             */
            get: function () {
                return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "calendarYear", {
            /**
             * Returns the year value of the calendar.
             */
            get: function () {
                return this._dateNavigationService.displayedCalendar.year;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the DateNavigationService to move to the next month.
         */
        ClrDaypicker.prototype.nextMonth = function () {
            this._dateNavigationService.moveToNextMonth();
        };
        /**
         * Calls the DateNavigationService to move to the previous month.
         */
        ClrDaypicker.prototype.previousMonth = function () {
            this._dateNavigationService.moveToPreviousMonth();
        };
        /**
         * Calls the DateNavigationService to move to the current month.
         */
        ClrDaypicker.prototype.currentMonth = function () {
            this._dateNavigationService.moveToCurrentMonth();
        };
        ClrDaypicker.ctorParameters = function () { return [
            { type: ViewManagerService },
            { type: DateNavigationService },
            { type: LocaleHelperService },
            { type: ClrCommonStringsService },
            { type: ClrAriaLiveService }
        ]; };
ClrDaypicker.ɵfac = function ClrDaypicker_Factory(t) { return new (t || ClrDaypicker)(ɵngcc0.ɵɵdirectiveInject(ViewManagerService), ɵngcc0.ɵɵdirectiveInject(DateNavigationService), ɵngcc0.ɵɵdirectiveInject(LocaleHelperService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService)); };
ClrDaypicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDaypicker, selectors: [["clr-daypicker"]], hostVars: 2, hostBindings: function ClrDaypicker_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("daypicker", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ClrAriaLiveService])], decls: 18, vars: 14, consts: [[1, "clr-sr-only"], [1, "calendar-header"], [1, "calendar-pickers"], ["type", "button", 1, "calendar-btn", "monthpicker-trigger", 3, "click"], ["type", "button", 1, "calendar-btn", "yearpicker-trigger", 3, "click"], [1, "calendar-switchers"], ["type", "button", 1, "calendar-btn", "switcher", 3, "click"], ["shape", "angle", "dir", "left"], ["shape", "event"], ["shape", "angle", "dir", "right"]], template: function ClrDaypicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "button", 3);
        ɵngcc0.ɵɵlistener("click", function ClrDaypicker_Template_button_click_4_listener() { return ctx.changeToMonthView(); });
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "button", 4);
        ɵngcc0.ɵɵlistener("click", function ClrDaypicker_Template_button_click_6_listener() { return ctx.changeToYearView(); });
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 5);
        ɵngcc0.ɵɵelementStart(9, "button", 6);
        ɵngcc0.ɵɵlistener("click", function ClrDaypicker_Template_button_click_9_listener() { return ctx.previousMonth(); });
        ɵngcc0.ɵɵelement(10, "clr-icon", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "button", 6);
        ɵngcc0.ɵɵlistener("click", function ClrDaypicker_Template_button_click_11_listener() { return ctx.currentMonth(); });
        ɵngcc0.ɵɵelement(12, "clr-icon", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "button", 6);
        ɵngcc0.ɵɵlistener("click", function ClrDaypicker_Template_button_click_13_listener() { return ctx.nextMonth(); });
        ɵngcc0.ɵɵelement(14, "clr-icon", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(15, "clr-calendar");
        ɵngcc0.ɵɵelementStart(16, "div", 0);
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.commonStrings.keys.modalContentStart);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-label", ctx.monthAttrString)("title", ctx.monthAttrString);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.calendarMonth, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.yearAttrString)("title", ctx.yearAttrString);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.calendarYear, " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerPreviousMonth);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.datepickerPreviousMonth);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerCurrentMonth);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.datepickerCurrentMonth);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerNextMonth);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.datepickerNextMonth);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.commonStrings.keys.modalContentEnd);
    } }, directives: [ClrIconCustomTag,
        ClrCalendar], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDaypicker, [{
        type: core.Component,
        args: [{
                selector: 'clr-daypicker',
                providers: [ClrAriaLiveService],
                template: "<div class=\"clr-sr-only\">{{commonStrings.keys.modalContentStart}}</div>\n<div class=\"calendar-header\">\n    <div class=\"calendar-pickers\">\n        <button\n                class=\"calendar-btn monthpicker-trigger\"\n                type=\"button\" (click)=\"changeToMonthView()\"\n                [attr.aria-label]=\"monthAttrString\"\n                [attr.title]=\"monthAttrString\">\n                {{calendarMonth}}\n        </button>\n        <button\n                class=\"calendar-btn yearpicker-trigger\"\n                type=\"button\"\n                (click)=\"changeToYearView()\"\n                [attr.aria-label]=\"yearAttrString\"\n                [attr.title]=\"yearAttrString\">\n            {{calendarYear}}\n        </button>\n    </div>\n    <div class=\"calendar-switchers\">\n        <button\n            class=\"calendar-btn switcher\"\n            type=\"button\"\n            (click)=\"previousMonth()\"\n            [attr.aria-label]=\"commonStrings.keys.datepickerPreviousMonth\">\n            <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.keys.datepickerPreviousMonth\"></clr-icon>\n        </button>\n        <button\n            class=\"calendar-btn switcher\"\n            type=\"button\"\n            (click)=\"currentMonth()\"\n            [attr.aria-label]=\"commonStrings.keys.datepickerCurrentMonth\">\n            <clr-icon shape=\"event\" [attr.title]=\"commonStrings.keys.datepickerCurrentMonth\"></clr-icon>\n        </button>\n        <button\n            class=\"calendar-btn switcher\"\n            type=\"button\"\n            (click)=\"nextMonth()\"\n            [attr.aria-label]=\"commonStrings.keys.datepickerNextMonth\">\n            <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.keys.datepickerNextMonth\"></clr-icon>\n        </button>\n    </div>\n</div>\n<clr-calendar></clr-calendar>\n<div class=\"clr-sr-only\">{{commonStrings.keys.modalContentEnd}}</div>\n",
                host: { '[class.daypicker]': 'true' }
            }]
    }], function () { return [{ type: ViewManagerService }, { type: DateNavigationService }, { type: LocaleHelperService }, { type: ClrCommonStringsService }, { type: ClrAriaLiveService }]; }, null); })();
        return ClrDaypicker;
    }());

    var ClrMonthpicker = /** @class */ (function () {
        function ClrMonthpicker(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
            this._viewManagerService = _viewManagerService;
            this._localeHelperService = _localeHelperService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this._focusedMonthIndex = this.calendarMonthIndex;
        }
        Object.defineProperty(ClrMonthpicker.prototype, "monthNames", {
            /**
             * Gets the months array which is used to rendered the monthpicker view.
             * Months are in the TranslationWidth.Wide format.
             */
            get: function () {
                return this._localeHelperService.localeMonthsWide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrMonthpicker.prototype, "calendarMonthIndex", {
            /**
             * Gets the month value of the Calendar.
             */
            get: function () {
                return this._dateNavigationService.displayedCalendar.month;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         */
        ClrMonthpicker.prototype.changeMonth = function (monthIndex) {
            this._dateNavigationService.changeMonth(monthIndex);
            this._viewManagerService.changeToDayView();
        };
        /**
         * Compares the month passed to the focused month and returns the tab index.
         */
        ClrMonthpicker.prototype.getTabIndex = function (monthIndex) {
            return monthIndex === this._focusedMonthIndex ? 0 : -1;
        };
        /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         */
        ClrMonthpicker.prototype.onKeyDown = function (event) {
            // NOTE: Didn't move this to the date navigation service because
            // the logic is fairly simple and it didn't make sense for me
            // to create extra observables just to move this logic to the service.
            if (event) {
                var keyCode = event.keyCode;
                if (keyCode === UP_ARROW && this._focusedMonthIndex > 0) {
                    event.preventDefault();
                    this._focusedMonthIndex--;
                    this._datepickerFocusService.focusCell(this._elRef);
                }
                else if (keyCode === DOWN_ARROW && this._focusedMonthIndex < 11) {
                    event.preventDefault();
                    this._focusedMonthIndex++;
                    this._datepickerFocusService.focusCell(this._elRef);
                }
                else if (keyCode === RIGHT_ARROW && this._focusedMonthIndex < 6) {
                    event.preventDefault();
                    this._focusedMonthIndex = this._focusedMonthIndex + 6;
                    this._datepickerFocusService.focusCell(this._elRef);
                }
                else if (keyCode === LEFT_ARROW && this._focusedMonthIndex > 5) {
                    event.preventDefault();
                    this._focusedMonthIndex = this._focusedMonthIndex - 6;
                    this._datepickerFocusService.focusCell(this._elRef);
                }
            }
        };
        /**
         * Focuses on the current calendar month when the View is initialized.
         */
        ClrMonthpicker.prototype.ngAfterViewInit = function () {
            this._datepickerFocusService.focusCell(this._elRef);
        };
        ClrMonthpicker.ctorParameters = function () { return [
            { type: ViewManagerService },
            { type: LocaleHelperService },
            { type: DateNavigationService },
            { type: DatepickerFocusService },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], ClrMonthpicker.prototype, "onKeyDown", null);
ClrMonthpicker.ɵfac = function ClrMonthpicker_Factory(t) { return new (t || ClrMonthpicker)(ɵngcc0.ɵɵdirectiveInject(ViewManagerService), ɵngcc0.ɵɵdirectiveInject(LocaleHelperService), ɵngcc0.ɵɵdirectiveInject(DateNavigationService), ɵngcc0.ɵɵdirectiveInject(DatepickerFocusService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrMonthpicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrMonthpicker, selectors: [["clr-monthpicker"]], hostVars: 2, hostBindings: function ClrMonthpicker_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ClrMonthpicker_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("monthpicker", true);
    } }, decls: 1, vars: 1, consts: [["type", "button", "class", "calendar-btn month", 3, "is-selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "calendar-btn", "month", 3, "click"]], template: function ClrMonthpicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ClrMonthpicker_button_0_Template, 2, 4, "button", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.monthNames);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrMonthpicker, [{
        type: core.Component,
        args: [{
                selector: 'clr-monthpicker',
                template: "\n        <button\n            type=\"button\"\n            class=\"calendar-btn month\"\n            *ngFor=\"let month of monthNames; let monthIndex = index\"\n            (click)=\"changeMonth(monthIndex)\"\n            [class.is-selected]=\"monthIndex === calendarMonthIndex\"\n            [attr.tabindex]=\"getTabIndex(monthIndex)\">\n            {{month}}\n        </button>\n    ",
                host: {
                    '[class.monthpicker]': 'true'
                }
            }]
    }], function () { return [{ type: ViewManagerService }, { type: LocaleHelperService }, { type: DateNavigationService }, { type: DatepickerFocusService }, { type: ɵngcc0.ElementRef }]; }, { onKeyDown: [{
            type: core.HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
        return ClrMonthpicker;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var YEARS_TO_DISPLAY = 10;
    var YearRangeModel = /** @class */ (function () {
        function YearRangeModel(year) {
            this.year = year;
            this.yearRange = [];
            this.generateYearRange();
        }
        Object.defineProperty(YearRangeModel.prototype, "middleYear", {
            /**
             * Gets the number in the middle of the range.
             */
            get: function () {
                return this.yearRange[Math.floor(this.yearRange.length / 2)];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         */
        YearRangeModel.prototype.generateYearRange = function () {
            var remainder = this.year % YEARS_TO_DISPLAY;
            var floor = this.year - remainder;
            var ceil = floor + YEARS_TO_DISPLAY;
            this.yearRange = this.generateRange(floor, ceil);
        };
        /**
         * Function which generate a range of numbers from floor to ceil.
         */
        YearRangeModel.prototype.generateRange = function (floor, ceil) {
            return Array.from({ length: ceil - floor }, function (v, k) { return k + floor; });
        };
        /**
         * Generates the YearRangeModel for the next decade.
         */
        YearRangeModel.prototype.nextDecade = function () {
            return new YearRangeModel(this.year + 10);
        };
        /**
         * Generates the YearRangeModel for the previous decade.
         */
        YearRangeModel.prototype.previousDecade = function () {
            return new YearRangeModel(this.year - 10);
        };
        /**
         * Generates the YearRangeModel for the current decade.
         */
        YearRangeModel.prototype.currentDecade = function () {
            return new YearRangeModel(new Date().getFullYear());
        };
        /**
         * Checks if the value is in the YearRangeModel.
         */
        YearRangeModel.prototype.inRange = function (value) {
            return this.yearRange.indexOf(value) > -1;
        };
        return YearRangeModel;
    }());

    var ClrYearpicker = /** @class */ (function () {
        function ClrYearpicker(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings, ariaLiveService) {
            this._dateNavigationService = _dateNavigationService;
            this._viewManagerService = _viewManagerService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this.commonStrings = commonStrings;
            this.ariaLiveService = ariaLiveService;
            this.yearRangeModel = new YearRangeModel(this.calendarYear);
            this._focusedYear = this.calendarYear;
            this.updateRange(this.yearRangeModel);
        }
        Object.defineProperty(ClrYearpicker.prototype, "ariaLiveDecadeText", {
            /** @deprecated since 3.0, remove in 4.0 */
            get: function () {
                return this.commonStrings.parse(this.commonStrings.keys.daypickerSRCurrentDecadePhrase, {
                    DECADE_RANGE: this.decadeRange,
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrYearpicker.prototype, "calendarYear", {
            /**
             * Gets the year which the user is currently on.
             */
            get: function () {
                return this._dateNavigationService.displayedCalendar.year;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         */
        ClrYearpicker.prototype.incrementFocusYearBy = function (value) {
            this._focusedYear = this._focusedYear + value;
            if (!this.yearRangeModel.inRange(this._focusedYear)) {
                if (value > 0) {
                    this.yearRangeModel = this.yearRangeModel.nextDecade();
                }
                else {
                    this.yearRangeModel = this.yearRangeModel.previousDecade();
                }
            }
            this._datepickerFocusService.focusCell(this._elRef);
        };
        /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         */
        ClrYearpicker.prototype.changeYear = function (year) {
            this._dateNavigationService.changeYear(year);
            this._viewManagerService.changeToDayView();
        };
        /**
         * Updates the YearRangeModel to the previous decade.
         */
        ClrYearpicker.prototype.previousDecade = function () {
            this.yearRangeModel = this.yearRangeModel.previousDecade();
            this.updateRange(this.yearRangeModel);
            // Year in the yearpicker is not focused because while navigating to a different decade,
            // you want the focus to remain on the decade switcher arrows.
        };
        /**
         * Updates the YearRangeModel to the current decade.
         */
        ClrYearpicker.prototype.currentDecade = function () {
            if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
                this.yearRangeModel = this.yearRangeModel.currentDecade();
            }
            this._datepickerFocusService.focusCell(this._elRef);
            this.updateRange(this.yearRangeModel);
        };
        /**
         * Updates the YearRangeModel to the next decade.
         */
        ClrYearpicker.prototype.nextDecade = function () {
            this.yearRangeModel = this.yearRangeModel.nextDecade();
            this.updateRange(this.yearRangeModel);
            // Year in the yearpicker is not focused because while navigating to a different decade,
            // you want the focus to remain on the decade switcher arrows.
        };
        /**
         * Compares the year passed to the focused year and returns the tab index.
         */
        ClrYearpicker.prototype.getTabIndex = function (year) {
            if (!this.yearRangeModel.inRange(this._focusedYear)) {
                if (this.yearRangeModel.inRange(this.calendarYear)) {
                    this._focusedYear = this.calendarYear;
                }
                else {
                    this._focusedYear = this.yearRangeModel.middleYear;
                }
            }
            return this._focusedYear === year ? 0 : -1;
        };
        /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         */
        ClrYearpicker.prototype.onKeyDown = function (event) {
            // NOTE: Didn't move this to the date navigation service because
            // the logic is fairly simple and it didn't make sense for me
            // to create extra observables just to move this logic to the service.
            if (event) {
                var keyCode = event.keyCode;
                if (keyCode === UP_ARROW) {
                    event.preventDefault();
                    this.incrementFocusYearBy(-1);
                }
                else if (keyCode === DOWN_ARROW) {
                    event.preventDefault();
                    this.incrementFocusYearBy(1);
                }
                else if (keyCode === RIGHT_ARROW) {
                    event.preventDefault();
                    this.incrementFocusYearBy(5);
                }
                else if (keyCode === LEFT_ARROW) {
                    event.preventDefault();
                    this.incrementFocusYearBy(-5);
                }
            }
        };
        ClrYearpicker.prototype.updateRange = function (yrm) {
            var floor = yrm.yearRange[0];
            var ceil = yrm.yearRange[yrm.yearRange.length - 1];
            this.decadeRange = floor + " to " + ceil;
            /** @deprecated since 3.0, remove in 4.0 */
            this.ariaLiveService.announce(this.ariaLiveDecadeText);
        };
        /**
         * Focuses on the current calendar year when the View is initialized.
         */
        ClrYearpicker.prototype.ngAfterViewInit = function () {
            this._datepickerFocusService.focusCell(this._elRef);
            /** @deprecated since 3.0, remove in 4.0 */
            this.ariaLiveService.announce(this.ariaLiveDecadeText);
        };
        ClrYearpicker.ctorParameters = function () { return [
            { type: DateNavigationService },
            { type: ViewManagerService },
            { type: DatepickerFocusService },
            { type: core.ElementRef },
            { type: ClrCommonStringsService },
            { type: ClrAriaLiveService }
        ]; };
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], ClrYearpicker.prototype, "onKeyDown", null);
ClrYearpicker.ɵfac = function ClrYearpicker_Factory(t) { return new (t || ClrYearpicker)(ɵngcc0.ɵɵdirectiveInject(DateNavigationService), ɵngcc0.ɵɵdirectiveInject(ViewManagerService), ɵngcc0.ɵɵdirectiveInject(DatepickerFocusService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService)); };
ClrYearpicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrYearpicker, selectors: [["clr-yearpicker"]], hostVars: 2, hostBindings: function ClrYearpicker_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ClrYearpicker_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("yearpicker", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ClrAriaLiveService])], decls: 9, vars: 7, consts: [[1, "year-switchers"], ["type", "button", 1, "calendar-btn", "switcher", 3, "click"], ["shape", "angle", "dir", "left"], ["shape", "event"], ["shape", "angle", "dir", "right"], [1, "years"], ["type", "button", "class", "calendar-btn year", 3, "is-selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "calendar-btn", "year", 3, "click"]], template: function ClrYearpicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function ClrYearpicker_Template_button_click_1_listener() { return ctx.previousDecade(); });
        ɵngcc0.ɵɵelement(2, "clr-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 1);
        ɵngcc0.ɵɵlistener("click", function ClrYearpicker_Template_button_click_3_listener() { return ctx.currentDecade(); });
        ɵngcc0.ɵɵelement(4, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "button", 1);
        ɵngcc0.ɵɵlistener("click", function ClrYearpicker_Template_button_click_5_listener() { return ctx.nextDecade(); });
        ɵngcc0.ɵɵelement(6, "clr-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 5);
        ɵngcc0.ɵɵtemplate(8, ClrYearpicker_button_8_Template, 2, 4, "button", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerPreviousDecade);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.datepickerPreviousDecade);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerCurrentDecade);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.datepickerCurrentDecade);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerNextDecade);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.datepickerNextDecade);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.yearRangeModel.yearRange);
    } }, directives: [ClrIconCustomTag, ɵngcc1.NgForOf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrYearpicker, [{
        type: core.Component,
        args: [{
                selector: 'clr-yearpicker',
                providers: [ClrAriaLiveService],
                template: "\n        <div class=\"year-switchers\">\n          <button\n              class=\"calendar-btn switcher\"\n              type=\"button\"\n              (click)=\"previousDecade()\"\n              [attr.aria-label]=\"commonStrings.keys.datepickerPreviousDecade\">\n              <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.keys.datepickerPreviousDecade\"></clr-icon>\n          </button>\n          <button\n              class=\"calendar-btn switcher\"\n              type=\"button\"\n              (click)=\"currentDecade()\"\n              [attr.aria-label]=\"commonStrings.keys.datepickerCurrentDecade\">\n              <clr-icon shape=\"event\" [attr.title]=\"commonStrings.keys.datepickerCurrentDecade\"></clr-icon>\n          </button>\n          <button\n              class=\"calendar-btn switcher\"\n              type=\"button\"\n              (click)=\"nextDecade()\"\n              [attr.aria-label]=\"commonStrings.keys.datepickerNextDecade\">\n              <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.keys.datepickerNextDecade\"></clr-icon>\n          </button>\n        </div>\n        <div class=\"years\">\n            <button\n                *ngFor=\"let year of yearRangeModel.yearRange\"\n                type=\"button\"\n                class=\"calendar-btn year\"\n                [attr.tabindex]=\"getTabIndex(year)\"\n                [class.is-selected]=\"year === calendarYear\"\n                (click)=\"changeYear(year)\">\n                {{year}}\n            </button>\n        </div>\n    ",
                host: {
                    '[class.yearpicker]': 'true'
                }
            }]
    }], function () { return [{ type: DateNavigationService }, { type: ViewManagerService }, { type: DatepickerFocusService }, { type: ɵngcc0.ElementRef }, { type: ClrCommonStringsService }, { type: ClrAriaLiveService }]; }, { onKeyDown: [{
            type: core.HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
        return ClrYearpicker;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_DATEPICKER_DIRECTIVES = [
        ClrDay,
        ClrDateContainer,
        ClrDateInput,
        ClrDatepickerViewManager,
        ClrMonthpicker,
        ClrYearpicker,
        ClrDaypicker,
        ClrCalendar,
    ];
    var ClrDatepickerModule = /** @class */ (function () {
        function ClrDatepickerModule() {
        }
ClrDatepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrDatepickerModule });
ClrDatepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrDatepickerModule_Factory(t) { return new (t || ClrDatepickerModule)(); }, imports: [[
            common.CommonModule,
            ClrHostWrappingModule,
            ClrConditionalModule,
            ClrPopoverModuleNext,
            ClrIconModule,
            ClrFocusTrapModule,
            ClrCommonFormsModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrDatepickerModule, { declarations: [ClrDay,
        ClrDateContainer,
        ClrDateInput,
        ClrDatepickerViewManager,
        ClrMonthpicker,
        ClrYearpicker,
        ClrDaypicker,
        ClrCalendar], imports: [ɵngcc1.CommonModule, ClrHostWrappingModule,
        ClrConditionalModule,
        ClrPopoverModuleNext,
        ClrIconModule,
        ClrFocusTrapModule,
        ClrCommonFormsModule], exports: [ClrDay,
        ClrDateContainer,
        ClrDateInput,
        ClrDatepickerViewManager,
        ClrMonthpicker,
        ClrYearpicker,
        ClrDaypicker,
        ClrCalendar] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatepickerModule, [{
        type: core.NgModule,
        args: [{
                imports: [
                    common.CommonModule,
                    ClrHostWrappingModule,
                    ClrConditionalModule,
                    ClrPopoverModuleNext,
                    ClrIconModule,
                    ClrFocusTrapModule,
                    ClrCommonFormsModule,
                ],
                declarations: [CLR_DATEPICKER_DIRECTIVES],
                exports: [CLR_DATEPICKER_DIRECTIVES],
                entryComponents: [ClrDateContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrDatepickerModule;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrInputContainer = /** @class */ (function (_super) {
        __extends(ClrInputContainer, _super);
        function ClrInputContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
ClrInputContainer.ɵfac = function ClrInputContainer_Factory(t) { return ɵClrInputContainer_BaseFactory(t || ClrInputContainer); };
ClrInputContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrInputContainer, selectors: [["clr-input-container"]], hostVars: 6, hostBindings: function ClrInputContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, features: [ɵngcc0.ɵɵProvidersFeature([IfErrorService, NgControlService, ControlIdService, ControlClassService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c13, decls: 8, vars: 5, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrInputContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c12);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrInputContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrInputContainer_clr_icon_5_Template, 1, 0, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ClrInputContainer_6_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(7, ClrInputContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
var ɵClrInputContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ClrInputContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrInputContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-input-container',
                template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-input-wrapper\">\n                <ng-content select=\"[clrInput]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }]
    }], null, null); })();
        return ClrInputContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrInput = /** @class */ (function (_super) {
        __extends(ClrInput, _super);
        function ClrInput(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrInputContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrInput.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        ClrInput = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional())
        ], ClrInput);
ClrInput.ɵfac = function ClrInput_Factory(t) { return new (t || ClrInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrInput, selectors: [["", "clrInput", ""]], hostVars: 2, hostBindings: function ClrInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-input", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrInput, [{
        type: core.Directive,
        args: [{ selector: '[clrInput]', host: { '[class.clr-input]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrInput;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrInputModule = /** @class */ (function () {
        function ClrInputModule() {
        }
ClrInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrInputModule });
ClrInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrInputModule_Factory(t) { return new (t || ClrInputModule)(); }, imports: [[common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrInputModule, { declarations: [ClrInput,
        ClrInputContainer], imports: [ɵngcc1.CommonModule, ɵngcc2.FormsModule, ClrIconModule,
        ClrCommonFormsModule], exports: [ClrCommonFormsModule,
        ClrInput,
        ClrInputContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrInputModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrInput, ClrInputContainer],
                exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer],
                entryComponents: [ClrInputContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrInputModule;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var TOGGLE_SERVICE = new core.InjectionToken(undefined);
    function ToggleServiceFactory() {
        return new rxjs.BehaviorSubject(false);
    }
    var TOGGLE_SERVICE_PROVIDER = { provide: TOGGLE_SERVICE, useFactory: ToggleServiceFactory };
    var ClrPasswordContainer = /** @class */ (function (_super) {
        __extends(ClrPasswordContainer, _super);
        function ClrPasswordContainer(ifErrorService, layoutService, controlClassService, ngControlService, focusService, toggleService, commonStrings) {
            var _this = _super.call(this, ifErrorService, layoutService, controlClassService, ngControlService) || this;
            _this.focusService = focusService;
            _this.toggleService = toggleService;
            _this.commonStrings = commonStrings;
            _this.show = false;
            _this.focus = false;
            _this._toggle = true;
            _this.subscriptions.push(_this.focusService.focusChange.subscribe(function (state) {
                _this.focus = state;
            }));
            return _this;
        }
        Object.defineProperty(ClrPasswordContainer.prototype, "clrToggle", {
            get: function () {
                return this._toggle;
            },
            set: function (state) {
                this._toggle = state;
                if (!state) {
                    this.show = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrPasswordContainer.prototype.toggle = function () {
            this.show = !this.show;
            this.toggleService.next(this.show);
        };
        ClrPasswordContainer.ctorParameters = function () { return [
            { type: IfErrorService },
            { type: LayoutService, decorators: [{ type: core.Optional }] },
            { type: ControlClassService },
            { type: NgControlService },
            { type: FocusService },
            { type: rxjs.BehaviorSubject, decorators: [{ type: core.Inject, args: [TOGGLE_SERVICE,] }] },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.Input('clrToggle')
        ], ClrPasswordContainer.prototype, "clrToggle", null);
        ClrPasswordContainer = __decorate([ __param(1, core.Optional()),
            __param(5, core.Inject(TOGGLE_SERVICE))
        ], ClrPasswordContainer);
ClrPasswordContainer.ɵfac = function ClrPasswordContainer_Factory(t) { return new (t || ClrPasswordContainer)(ɵngcc0.ɵɵdirectiveInject(IfErrorService), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(ControlClassService), ɵngcc0.ɵɵdirectiveInject(NgControlService), ɵngcc0.ɵɵdirectiveInject(FocusService), ɵngcc0.ɵɵdirectiveInject(TOGGLE_SERVICE), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrPasswordContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrPasswordContainer, selectors: [["clr-password-container"]], hostVars: 6, hostBindings: function ClrPasswordContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, inputs: { clrToggle: "clrToggle" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IfErrorService,
            NgControlService,
            ControlIdService,
            ControlClassService,
            FocusService,
            TOGGLE_SERVICE_PROVIDER,
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c15, decls: 10, vars: 8, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["class", "clr-input-group-icon-action", "type", "button", 3, "disabled", "click", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["type", "button", 1, "clr-input-group-icon-action", 3, "disabled", "click"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrPasswordContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c14);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrPasswordContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵtemplate(6, ClrPasswordContainer_button_6_Template, 2, 3, "button", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ClrPasswordContainer_clr_icon_7_Template, 1, 0, "clr-icon", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ClrPasswordContainer_8_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(9, ClrPasswordContainer_9_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("clr-focus", ctx.focus);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.clrToggle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPasswordContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-password-container',
                template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n      <div class=\"clr-input-wrapper\">\n        <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n          <ng-content select=\"[clrPassword]\"></ng-content>\n          <button\n            *ngIf=\"clrToggle\"\n            (click)=\"toggle()\"\n            [disabled]=\"control?.disabled\"\n            class=\"clr-input-group-icon-action\"\n            type=\"button\">\n            <clr-icon\n            [attr.shape]=\"show ? 'eye-hide' : 'eye'\"\n            [attr.title]=\"show ? commonStrings.keys.hide : commonStrings.keys.show\"></clr-icon>\n          </button>\n        </div>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n      </div>\n      <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n      <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n    </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [
                    IfErrorService,
                    NgControlService,
                    ControlIdService,
                    ControlClassService,
                    FocusService,
                    TOGGLE_SERVICE_PROVIDER,
                ]
            }]
    }], function () { return [{ type: IfErrorService }, { type: LayoutService, decorators: [{
                type: core.Optional
            }] }, { type: ControlClassService }, { type: NgControlService }, { type: FocusService }, { type: ɵngcc3.BehaviorSubject, decorators: [{
                type: core.Inject,
                args: [TOGGLE_SERVICE]
            }] }, { type: ClrCommonStringsService }]; }, { clrToggle: [{
            type: core.Input,
            args: ['clrToggle']
        }] }); })();
        return ClrPasswordContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrPassword = /** @class */ (function (_super) {
        __extends(ClrPassword, _super);
        function ClrPassword(vcr, injector, control, renderer, el, focusService, toggleService) {
            var _this = _super.call(this, vcr, ClrPasswordContainer, injector, control, renderer, el) || this;
            _this.focusService = focusService;
            _this.toggleService = toggleService;
            _this.index = 1;
            if (!_this.focusService) {
                throw new Error('clrPassword requires being wrapped in <clr-password-container>');
            }
            _this.subscriptions.push(_this.toggleService.subscribe(function (toggle) {
                renderer.setProperty(el.nativeElement, 'type', toggle ? 'text' : 'password');
            }));
            return _this;
        }
        ClrPassword.prototype.triggerFocus = function () {
            if (this.focusService) {
                this.focusService.focused = true;
            }
        };
        ClrPassword.prototype.triggerValidation = function () {
            _super.prototype.triggerValidation.call(this);
            if (this.focusService) {
                this.focusService.focused = false;
            }
        };
        ClrPassword.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: FocusService, decorators: [{ type: core.Optional }] },
            { type: rxjs.BehaviorSubject, decorators: [{ type: core.Optional }, { type: core.Inject, args: [TOGGLE_SERVICE,] }] }
        ]; };
        __decorate([
            core.HostListener('focus')
        ], ClrPassword.prototype, "triggerFocus", null);
        __decorate([
            core.HostListener('blur')
        ], ClrPassword.prototype, "triggerValidation", null);
        ClrPassword = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional()),
            __param(5, core.Optional()),
            __param(6, core.Optional()),
            __param(6, core.Inject(TOGGLE_SERVICE))
        ], ClrPassword);
ClrPassword.ɵfac = function ClrPassword_Factory(t) { return new (t || ClrPassword)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(FocusService, 8), ɵngcc0.ɵɵdirectiveInject(TOGGLE_SERVICE, 8)); };
ClrPassword.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrPassword, selectors: [["", "clrPassword", ""]], hostVars: 2, hostBindings: function ClrPassword_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function ClrPassword_focus_HostBindingHandler() { return ctx.triggerFocus(); })("blur", function ClrPassword_blur_HostBindingHandler() { return ctx.triggerValidation(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-input", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPassword, [{
        type: core.Directive,
        args: [{ selector: '[clrPassword]', host: { '[class.clr-input]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: FocusService, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc3.BehaviorSubject, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [TOGGLE_SERVICE]
            }] }]; }, { triggerFocus: [{
            type: core.HostListener,
            args: ['focus']
        }], triggerValidation: [{
            type: core.HostListener,
            args: ['blur']
        }] }); })();
        return ClrPassword;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrPasswordModule = /** @class */ (function () {
        function ClrPasswordModule() {
        }
ClrPasswordModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrPasswordModule });
ClrPasswordModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrPasswordModule_Factory(t) { return new (t || ClrPasswordModule)(); }, imports: [[common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrPasswordModule, { declarations: [ClrPassword,
        ClrPasswordContainer], imports: [ɵngcc1.CommonModule, ɵngcc2.FormsModule, ClrIconModule,
        ClrCommonFormsModule], exports: [ClrCommonFormsModule,
        ClrPassword,
        ClrPasswordContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPasswordModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrPassword, ClrPasswordContainer],
                exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer],
                entryComponents: [ClrPasswordContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrPasswordModule;
    }());

    /**
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRadioWrapper = /** @class */ (function () {
        function ClrRadioWrapper() {
            // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
            // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
            // but we'd still need to insert a label
            this._dynamic = false;
        }
        ClrRadioWrapper.prototype.ngOnInit = function () {
            if (this.label) {
                this.label.disableGrid();
            }
        };
        __decorate([
            core.ContentChild(ClrLabel, { static: true })
        ], ClrRadioWrapper.prototype, "label", void 0);
ClrRadioWrapper.ɵfac = function ClrRadioWrapper_Factory(t) { return new (t || ClrRadioWrapper)(); };
ClrRadioWrapper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrRadioWrapper, selectors: [["clr-radio-wrapper"]], contentQueries: function ClrRadioWrapper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
    } }, hostVars: 2, hostBindings: function ClrRadioWrapper_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-radio-wrapper", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ControlIdService])], ngContentSelectors: _c17, decls: 3, vars: 1, consts: [[4, "ngIf"]], template: function ClrRadioWrapper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c16);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵtemplate(2, ClrRadioWrapper_label_2_Template, 1, 0, "label", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label);
    } }, directives: [ɵngcc1.NgIf, ClrLabel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRadioWrapper, [{
        type: core.Component,
        args: [{
                selector: 'clr-radio-wrapper',
                template: "\n    <ng-content select=\"[clrRadio]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                host: {
                    '[class.clr-radio-wrapper]': 'true'
                },
                providers: [ControlIdService]
            }]
    }], function () { return []; }, { label: [{
            type: core.ContentChild,
            args: [ClrLabel, { static: true }]
        }] }); })();
        return ClrRadioWrapper;
    }());

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRadio = /** @class */ (function (_super) {
        __extends(ClrRadio, _super);
        function ClrRadio(vcr, injector, control, renderer, el) {
            return _super.call(this, vcr, ClrRadioWrapper, injector, control, renderer, el) || this;
        }
        ClrRadio.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        ClrRadio = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional())
        ], ClrRadio);
ClrRadio.ɵfac = function ClrRadio_Factory(t) { return new (t || ClrRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrRadio.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrRadio, selectors: [["", "clrRadio", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRadio, [{
        type: core.Directive,
        args: [{ selector: '[clrRadio]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrRadio;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRadioContainer = /** @class */ (function (_super) {
        __extends(ClrRadioContainer, _super);
        function ClrRadioContainer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.inline = false;
            return _this;
        }
        Object.defineProperty(ClrRadioContainer.prototype, "clrInline", {
            get: function () {
                return this.inline;
            },
            /*
             * Here we want to support the following cases
             * clrInline - true by presence
             * clrInline="true|false" - unless it is explicitly false, strings are considered true
             * [clrInline]="true|false" - expect a boolean
             */
            set: function (value) {
                if (typeof value === 'string') {
                    this.inline = value === 'false' ? false : true;
                }
                else {
                    this.inline = !!value;
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input()
        ], ClrRadioContainer.prototype, "clrInline", null);
ClrRadioContainer.ɵfac = function ClrRadioContainer_Factory(t) { return ɵClrRadioContainer_BaseFactory(t || ClrRadioContainer); };
ClrRadioContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrRadioContainer, selectors: [["clr-radio-container"]], hostVars: 6, hostBindings: function ClrRadioContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, inputs: { clrInline: "clrInline" }, features: [ɵngcc0.ɵɵProvidersFeature([NgControlService, ControlClassService, IfErrorService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c19, decls: 8, vars: 7, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-subtext-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrRadioContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c18);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrRadioContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵtemplate(5, ClrRadioContainer_5_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(6, ClrRadioContainer_clr_icon_6_Template, 1, 0, "clr-icon", 3);
        ɵngcc0.ɵɵtemplate(7, ClrRadioContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("clr-control-inline", ctx.clrInline);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
var ɵClrRadioContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ClrRadioContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRadioContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-radio-container',
                template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-radio-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [NgControlService, ControlClassService, IfErrorService]
            }]
    }], null, { clrInline: [{
            type: core.Input
        }] }); })();
        return ClrRadioContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRadioModule = /** @class */ (function () {
        function ClrRadioModule() {
        }
ClrRadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrRadioModule });
ClrRadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrRadioModule_Factory(t) { return new (t || ClrRadioModule)(); }, imports: [[common.CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrRadioModule, { declarations: [ClrRadio,
        ClrRadioContainer,
        ClrRadioWrapper], imports: [ɵngcc1.CommonModule, ClrCommonFormsModule,
        ClrHostWrappingModule,
        ClrIconModule], exports: [ClrCommonFormsModule,
        ClrRadio,
        ClrRadioContainer,
        ClrRadioWrapper] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRadioModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
                declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                entryComponents: [ClrRadioWrapper]
            }]
    }], function () { return []; }, null); })();
        return ClrRadioModule;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrSelectContainer = /** @class */ (function (_super) {
        __extends(ClrSelectContainer, _super);
        function ClrSelectContainer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.multi = false;
            return _this;
        }
        ClrSelectContainer.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                if (control) {
                    _this.multi = control.valueAccessor instanceof forms.SelectMultipleControlValueAccessor;
                    _this.control = control;
                }
            }));
        };
        ClrSelectContainer.prototype.wrapperClass = function () {
            return this.multi ? 'clr-multiselect-wrapper' : 'clr-select-wrapper';
        };
        __decorate([
            core.ContentChild(forms.SelectMultipleControlValueAccessor, { static: false })
        ], ClrSelectContainer.prototype, "multiple", void 0);
ClrSelectContainer.ɵfac = function ClrSelectContainer_Factory(t) { return ɵClrSelectContainer_BaseFactory(t || ClrSelectContainer); };
ClrSelectContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrSelectContainer, selectors: [["clr-select-container"]], contentQueries: function ClrSelectContainer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, forms.SelectMultipleControlValueAccessor, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.multiple = _t.first);
    } }, hostVars: 6, hostBindings: function ClrSelectContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, features: [ɵngcc0.ɵɵProvidersFeature([IfErrorService, NgControlService, ControlIdService, ControlClassService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c21, decls: 8, vars: 6, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [3, "ngClass"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrSelectContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c20);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrSelectContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrSelectContainer_clr_icon_5_Template, 1, 0, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ClrSelectContainer_6_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(7, ClrSelectContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.wrapperClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
var ɵClrSelectContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ClrSelectContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSelectContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-select-container',
                template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div [ngClass]=\"wrapperClass()\">\n                <ng-content select=\"[clrSelect]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }]
    }], null, { multiple: [{
            type: core.ContentChild,
            args: [forms.SelectMultipleControlValueAccessor, { static: false }]
        }] }); })();
        return ClrSelectContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrSelect = /** @class */ (function (_super) {
        __extends(ClrSelect, _super);
        function ClrSelect(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrSelectContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrSelect.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        ClrSelect = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional())
        ], ClrSelect);
ClrSelect.ɵfac = function ClrSelect_Factory(t) { return new (t || ClrSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrSelect.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrSelect, selectors: [["", "clrSelect", ""]], hostVars: 2, hostBindings: function ClrSelect_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-select", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSelect, [{
        type: core.Directive,
        args: [{ selector: '[clrSelect]', host: { '[class.clr-select]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrSelect;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrSelectModule = /** @class */ (function () {
        function ClrSelectModule() {
        }
ClrSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrSelectModule });
ClrSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrSelectModule_Factory(t) { return new (t || ClrSelectModule)(); }, imports: [[common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrSelectModule, { declarations: [ClrSelect,
        ClrSelectContainer], imports: [ɵngcc1.CommonModule, ɵngcc2.FormsModule, ClrIconModule,
        ClrCommonFormsModule], exports: [ClrCommonFormsModule,
        ClrSelect,
        ClrSelectContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSelectModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrSelect, ClrSelectContainer],
                exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer],
                entryComponents: [ClrSelectContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrSelectModule;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTextareaContainer = /** @class */ (function (_super) {
        __extends(ClrTextareaContainer, _super);
        function ClrTextareaContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
ClrTextareaContainer.ɵfac = function ClrTextareaContainer_Factory(t) { return ɵClrTextareaContainer_BaseFactory(t || ClrTextareaContainer); };
ClrTextareaContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTextareaContainer, selectors: [["clr-textarea-container"]], hostVars: 6, hostBindings: function ClrTextareaContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, features: [ɵngcc0.ɵɵProvidersFeature([IfErrorService, NgControlService, ControlIdService, ControlClassService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c23, decls: 8, vars: 5, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-textarea-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrTextareaContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c22);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrTextareaContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrTextareaContainer_clr_icon_5_Template, 1, 0, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ClrTextareaContainer_6_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(7, ClrTextareaContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
var ɵClrTextareaContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ClrTextareaContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTextareaContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-textarea-container',
                template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-textarea-wrapper\">\n                <ng-content select=\"[clrTextarea]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }]
    }], null, null); })();
        return ClrTextareaContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTextarea = /** @class */ (function (_super) {
        __extends(ClrTextarea, _super);
        function ClrTextarea(vcr, injector, control, renderer, el) {
            var _this = _super.call(this, vcr, ClrTextareaContainer, injector, control, renderer, el) || this;
            _this.index = 1;
            return _this;
        }
        ClrTextarea.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        ClrTextarea = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional())
        ], ClrTextarea);
ClrTextarea.ɵfac = function ClrTextarea_Factory(t) { return new (t || ClrTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrTextarea.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrTextarea, selectors: [["", "clrTextarea", ""]], hostVars: 2, hostBindings: function ClrTextarea_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-textarea", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTextarea, [{
        type: core.Directive,
        args: [{ selector: '[clrTextarea]', host: { '[class.clr-textarea]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrTextarea;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTextareaModule = /** @class */ (function () {
        function ClrTextareaModule() {
        }
ClrTextareaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrTextareaModule });
ClrTextareaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrTextareaModule_Factory(t) { return new (t || ClrTextareaModule)(); }, imports: [[common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrTextareaModule, { declarations: [ClrTextarea,
        ClrTextareaContainer], imports: [ɵngcc1.CommonModule, ɵngcc2.FormsModule, ClrIconModule,
        ClrCommonFormsModule], exports: [ClrCommonFormsModule,
        ClrTextarea,
        ClrTextareaContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTextareaModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrTextarea, ClrTextareaContainer],
                exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer],
                entryComponents: [ClrTextareaContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrTextareaModule;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRangeContainer = /** @class */ (function (_super) {
        __extends(ClrRangeContainer, _super);
        function ClrRangeContainer(ifErrorService, layoutService, controlClassService, ngControlService, renderer, idService) {
            var _this = _super.call(this, ifErrorService, layoutService, controlClassService, ngControlService) || this;
            _this.renderer = renderer;
            _this.idService = idService;
            _this._hasProgress = false;
            return _this;
        }
        Object.defineProperty(ClrRangeContainer.prototype, "hasProgress", {
            get: function () {
                return this._hasProgress;
            },
            set: function (val) {
                var valBool = !!val;
                if (valBool !== this._hasProgress) {
                    this._hasProgress = valBool;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrRangeContainer.prototype.getRangeProgressFillWidth = function () {
            var input = this.renderer.selectRootElement('[clrRange]#' + this.idService.id);
            var inputWidth = input.offsetWidth;
            var inputMinValue = +input.min;
            var inputMaxValue = +input.max;
            if (inputMinValue === 0 && inputMaxValue === 0) {
                inputMaxValue = 100;
            }
            var inputMiddle = (inputMinValue + inputMaxValue) / 2;
            var inputValue = !!this.control && this.control.value !== undefined ? this.control.value : inputMiddle;
            var valueAsPercent = (inputValue - inputMinValue) * 100 / (inputMaxValue - inputMinValue);
            return valueAsPercent * inputWidth / 100 + 'px';
        };
        ClrRangeContainer.ctorParameters = function () { return [
            { type: IfErrorService },
            { type: LayoutService, decorators: [{ type: core.Optional }] },
            { type: ControlClassService },
            { type: NgControlService },
            { type: core.Renderer2 },
            { type: ControlIdService }
        ]; };
        __decorate([
            core.Input('clrRangeHasProgress')
        ], ClrRangeContainer.prototype, "hasProgress", null);
        ClrRangeContainer = __decorate([ __param(1, core.Optional())
        ], ClrRangeContainer);
ClrRangeContainer.ɵfac = function ClrRangeContainer_Factory(t) { return new (t || ClrRangeContainer)(ɵngcc0.ɵɵdirectiveInject(IfErrorService), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(ControlClassService), ɵngcc0.ɵɵdirectiveInject(NgControlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ControlIdService)); };
ClrRangeContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrRangeContainer, selectors: [["clr-range-container"]], hostVars: 6, hostBindings: function ClrRangeContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, inputs: { hasProgress: ["clrRangeHasProgress", "hasProgress"] }, features: [ɵngcc0.ɵɵProvidersFeature([IfErrorService, NgControlService, ControlIdService, ControlClassService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c25, decls: 9, vars: 8, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-range-wrapper"], ["class", "fill-input", 3, "width", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], [1, "fill-input"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrRangeContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c24);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrRangeContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrRangeContainer_span_5_Template, 1, 2, "span", 3);
        ɵngcc0.ɵɵtemplate(6, ClrRangeContainer_clr_icon_6_Template, 1, 0, "clr-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ClrRangeContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(8, ClrRangeContainer_8_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("progress-fill", ctx.hasProgress);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasProgress);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRangeContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-range-container',
                template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-range-wrapper\" [class.progress-fill]=\"hasProgress\">\n                <ng-content select=\"[clrRange]\"></ng-content>\n                <span\n                  *ngIf=\"hasProgress\"\n                  class=\"fill-input\"\n                  [style.width]=\"getRangeProgressFillWidth()\"\n                ></span>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }]
    }], function () { return [{ type: IfErrorService }, { type: LayoutService, decorators: [{
                type: core.Optional
            }] }, { type: ControlClassService }, { type: NgControlService }, { type: ɵngcc0.Renderer2 }, { type: ControlIdService }]; }, { hasProgress: [{
            type: core.Input,
            args: ['clrRangeHasProgress']
        }] }); })();
        return ClrRangeContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRange = /** @class */ (function (_super) {
        __extends(ClrRange, _super);
        function ClrRange(vcr, injector, control, renderer, el) {
            return _super.call(this, vcr, ClrRangeContainer, injector, control, renderer, el) || this;
        }
        ClrRange.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        ClrRange = __decorate([ __param(2, core.Self()),
            __param(2, core.Optional())
        ], ClrRange);
ClrRange.ɵfac = function ClrRange_Factory(t) { return new (t || ClrRange)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrRange.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrRange, selectors: [["", "clrRange", ""]], hostVars: 2, hostBindings: function ClrRange_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-range", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRange, [{
        type: core.Directive,
        args: [{ selector: '[clrRange]', host: { '[class.clr-range]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrRange;
    }(WrappedFormControl));

    /**
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRangeModule = /** @class */ (function () {
        function ClrRangeModule() {
        }
ClrRangeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrRangeModule });
ClrRangeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrRangeModule_Factory(t) { return new (t || ClrRangeModule)(); }, imports: [[common.CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
        ClrCommonFormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrRangeModule, { declarations: [ClrRange,
        ClrRangeContainer], imports: [ɵngcc1.CommonModule, ClrCommonFormsModule,
        ClrHostWrappingModule,
        ClrIconModule], exports: [ClrCommonFormsModule,
        ClrRange,
        ClrRangeContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRangeModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
                declarations: [ClrRange, ClrRangeContainer],
                exports: [ClrCommonFormsModule, ClrRange, ClrRangeContainer],
                entryComponents: [ClrRangeContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrRangeModule;
    }());

    var counter$1 = 0;
    var DatalistIdService = /** @class */ (function () {
        function DatalistIdService() {
            this._id = 'clr-datalist-' + ++counter$1;
            this._idChange = new rxjs.BehaviorSubject(this._id);
        }
        Object.defineProperty(DatalistIdService.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
                this._idChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatalistIdService.prototype, "idChange", {
            get: function () {
                return this._idChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
DatalistIdService.ɵfac = function DatalistIdService_Factory(t) { return new (t || DatalistIdService)(); };
DatalistIdService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DatalistIdService, factory: function (t) { return DatalistIdService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatalistIdService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DatalistIdService;
    }());

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDatalistContainer = /** @class */ (function (_super) {
        __extends(ClrDatalistContainer, _super);
        function ClrDatalistContainer(controlClassService, layoutService, ifErrorService, ngControlService, focusService) {
            var _this = _super.call(this, ifErrorService, layoutService, controlClassService, ngControlService) || this;
            _this.focusService = focusService;
            _this.focus = false;
            _this.subscriptions.push(_this.focusService.focusChange.subscribe(function (state) { return (_this.focus = state); }));
            return _this;
        }
        ClrDatalistContainer.ctorParameters = function () { return [
            { type: ControlClassService },
            { type: LayoutService, decorators: [{ type: core.Optional }] },
            { type: IfErrorService },
            { type: NgControlService },
            { type: FocusService }
        ]; };
        ClrDatalistContainer = __decorate([ __param(1, core.Optional())
        ], ClrDatalistContainer);
ClrDatalistContainer.ɵfac = function ClrDatalistContainer_Factory(t) { return new (t || ClrDatalistContainer)(ɵngcc0.ɵɵdirectiveInject(ControlClassService), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(IfErrorService), ɵngcc0.ɵɵdirectiveInject(NgControlService), ɵngcc0.ɵɵdirectiveInject(FocusService)); };
ClrDatalistContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatalistContainer, selectors: [["clr-datalist-container"]], hostVars: 6, hostBindings: function ClrDatalistContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            ControlClassService,
            LayoutService,
            ControlIdService,
            FocusService,
            IfErrorService,
            NgControlService,
            DatalistIdService,
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c27, decls: 10, vars: 7, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrDatalistContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c26);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrDatalistContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵprojection(6, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ClrDatalistContainer_clr_icon_7_Template, 1, 0, "clr-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ClrDatalistContainer_8_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(9, ClrDatalistContainer_9_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("clr-focus", ctx.focus);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrLabel,
        ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatalistContainer, [{
        type: core.Component,
        args: [{
                selector: 'clr-datalist-container',
                template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n      <div class=\"clr-input-wrapper\">\n        <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n          <ng-content select=\"[clrDatalistInput]\"></ng-content>\n          <ng-content select=\"datalist\"></ng-content>\n        </div>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n      </div>\n      <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n      <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n    </div>\n    ",
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [
                    ControlClassService,
                    LayoutService,
                    ControlIdService,
                    FocusService,
                    IfErrorService,
                    NgControlService,
                    DatalistIdService,
                ]
            }]
    }], function () { return [{ type: ControlClassService }, { type: LayoutService, decorators: [{
                type: core.Optional
            }] }, { type: IfErrorService }, { type: NgControlService }, { type: FocusService }]; }, null); })();
        return ClrDatalistContainer;
    }(ClrAbstractContainer));

    /**
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDatalistInput = /** @class */ (function (_super) {
        __extends(ClrDatalistInput, _super);
        function ClrDatalistInput(focusService, vcr, injector, control, renderer, el, datalistIdService) {
            var _this = _super.call(this, vcr, ClrDatalistContainer, injector, control, renderer, el) || this;
            _this.focusService = focusService;
            _this.datalistIdService = datalistIdService;
            if (!_this.focusService) {
                throw new Error('clrDatalist requires being wrapped in <clr-datalist-container>');
            }
            return _this;
        }
        ClrDatalistInput.prototype.ngAfterContentInit = function () {
            var _this = this;
            // Subscriptions is inherited from WrappedFormControl, unsubscribe is handled there
            this.subscriptions.push(this.datalistIdService.idChange.subscribe(function (id) { return (_this.listValue = id); }));
        };
        ClrDatalistInput.prototype.triggerFocus = function () {
            if (this.focusService) {
                this.focusService.focused = true;
            }
        };
        ClrDatalistInput.prototype.triggerValidation = function () {
            _super.prototype.triggerValidation.call(this);
            if (this.focusService) {
                this.focusService.focused = false;
            }
        };
        ClrDatalistInput.ctorParameters = function () { return [
            { type: FocusService, decorators: [{ type: core.Optional }] },
            { type: core.ViewContainerRef },
            { type: core.Injector },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: DatalistIdService }
        ]; };
        __decorate([
            core.HostListener('focus')
        ], ClrDatalistInput.prototype, "triggerFocus", null);
        __decorate([
            core.HostListener('blur')
        ], ClrDatalistInput.prototype, "triggerValidation", null);
        ClrDatalistInput = __decorate([ __param(0, core.Optional()),
            __param(3, core.Self()),
            __param(3, core.Optional())
        ], ClrDatalistInput);
ClrDatalistInput.ɵfac = function ClrDatalistInput_Factory(t) { return new (t || ClrDatalistInput)(ɵngcc0.ɵɵdirectiveInject(FocusService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DatalistIdService)); };
ClrDatalistInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDatalistInput, selectors: [["", "clrDatalistInput", ""]], hostVars: 3, hostBindings: function ClrDatalistInput_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function ClrDatalistInput_focus_HostBindingHandler() { return ctx.triggerFocus(); })("blur", function ClrDatalistInput_blur_HostBindingHandler() { return ctx.triggerValidation(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("list", ctx.listValue);
        ɵngcc0.ɵɵclassProp("clr-input", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatalistInput, [{
        type: core.Directive,
        args: [{
                selector: '[clrDatalistInput]',
                host: {
                    '[class.clr-input]': 'true',
                    '[attr.list]': 'listValue'
                }
            }]
    }], function () { return [{ type: FocusService, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc2.NgControl, decorators: [{
                type: core.Self
            }, {
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: DatalistIdService }]; }, { triggerFocus: [{
            type: core.HostListener,
            args: ['focus']
        }], triggerValidation: [{
            type: core.HostListener,
            args: ['blur']
        }] }); })();
        return ClrDatalistInput;
    }(WrappedFormControl));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDatalist = /** @class */ (function () {
        function ClrDatalist(datalistIdService) {
            this.datalistIdService = datalistIdService;
            this.subscriptions = [];
        }
        ClrDatalist.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.datalistIdService) {
                return;
            }
            this.subscriptions.push(this.datalistIdService.idChange.subscribe(function (id) { return (_this.datalistId = id); }));
        };
        Object.defineProperty(ClrDatalist.prototype, "id", {
            set: function (idValue) {
                if (!!idValue && this.datalistIdService) {
                    this.datalistId = idValue;
                    this.datalistIdService.id = idValue;
                }
                else if (!!idValue) {
                    this.datalistId = idValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatalist.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDatalist.ctorParameters = function () { return [
            { type: DatalistIdService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input()
        ], ClrDatalist.prototype, "id", null);
        ClrDatalist = __decorate([ __param(0, core.Optional())
        ], ClrDatalist);
ClrDatalist.ɵfac = function ClrDatalist_Factory(t) { return new (t || ClrDatalist)(ɵngcc0.ɵɵdirectiveInject(DatalistIdService, 8)); };
ClrDatalist.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDatalist, selectors: [["datalist"]], hostVars: 1, hostBindings: function ClrDatalist_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.datalistId);
    } }, inputs: { id: "id" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatalist, [{
        type: core.Directive,
        args: [{
                selector: 'datalist',
                host: {
                    '[id]': 'datalistId'
                }
            }]
    }], function () { return [{ type: DatalistIdService, decorators: [{
                type: core.Optional
            }] }]; }, { id: [{
            type: core.Input
        }] }); })();
        return ClrDatalist;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDatalistModule = /** @class */ (function () {
        function ClrDatalistModule() {
        }
ClrDatalistModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrDatalistModule });
ClrDatalistModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrDatalistModule_Factory(t) { return new (t || ClrDatalistModule)(); }, imports: [[common.CommonModule, ClrInputModule, ClrIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrDatalistModule, { declarations: [ClrDatalist,
        ClrDatalistInput,
        ClrDatalistContainer], imports: [ɵngcc1.CommonModule, ClrInputModule,
        ClrIconModule], exports: [ClrDatalist,
        ClrDatalistInput,
        ClrDatalistContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatalistModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrInputModule, ClrIconModule],
                declarations: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer],
                exports: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer]
            }]
    }], function () { return []; }, null); })();
        return ClrDatalistModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrFormsModule = /** @class */ (function () {
        function ClrFormsModule() {
        }
ClrFormsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrFormsModule });
ClrFormsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrFormsModule_Factory(t) { return new (t || ClrFormsModule)(); }, imports: [[common.CommonModule],
        ClrCommonFormsModule,
        ClrCheckboxModule,
        ClrDatepickerModule,
        ClrInputModule,
        ClrPasswordModule,
        ClrRadioModule,
        ClrSelectModule,
        ClrTextareaModule,
        ClrRangeModule,
        ClrDatalistModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrFormsModule, { imports: [ɵngcc1.CommonModule], exports: [ClrCommonFormsModule,
        ClrCheckboxModule,
        ClrDatepickerModule,
        ClrInputModule,
        ClrPasswordModule,
        ClrRadioModule,
        ClrSelectModule,
        ClrTextareaModule,
        ClrRangeModule,
        ClrDatalistModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrFormsModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                exports: [
                    ClrCommonFormsModule,
                    ClrCheckboxModule,
                    ClrDatepickerModule,
                    ClrInputModule,
                    ClrPasswordModule,
                    ClrRadioModule,
                    ClrSelectModule,
                    ClrTextareaModule,
                    ClrRangeModule,
                    ClrDatalistModule,
                ]
            }]
    }], function () { return []; }, null); })();
        return ClrFormsModule;
    }());

    var CLR_LOADING_DIRECTIVES = [ClrLoading];
    var ClrLoadingModule = /** @class */ (function () {
        function ClrLoadingModule() {
        }
ClrLoadingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrLoadingModule });
ClrLoadingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrLoadingModule_Factory(t) { return new (t || ClrLoadingModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrLoadingModule, { declarations: [ClrLoading], imports: [ɵngcc1.CommonModule], exports: [ClrLoading] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLoadingModule, [{
        type: core.NgModule,
        args: [{ imports: [common.CommonModule], declarations: [CLR_LOADING_DIRECTIVES], exports: [CLR_LOADING_DIRECTIVES] }]
    }], function () { return []; }, null); })();
        return ClrLoadingModule;
    }());

    var OutsideClick = /** @class */ (function () {
        function OutsideClick(el) {
            this.el = el;
            this.strict = false;
            this.outsideClick = new core.EventEmitter(false);
        }
        OutsideClick.prototype.documentClick = function (event) {
            var target = event.target; // Get the element in the DOM on which the mouse was clicked
            var host = this.el.nativeElement; // Get the current actionMenu native HTML element
            if (target === host) {
                return;
            }
            if (!this.strict && host.contains(target)) {
                return;
            }
            this.outsideClick.emit(event);
        };
        OutsideClick.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('clrStrict')
        ], OutsideClick.prototype, "strict", void 0);
        __decorate([
            core.Output('clrOutsideClick')
        ], OutsideClick.prototype, "outsideClick", void 0);
        __decorate([
            core.HostListener('document:click', ['$event'])
        ], OutsideClick.prototype, "documentClick", null);
OutsideClick.ɵfac = function OutsideClick_Factory(t) { return new (t || OutsideClick)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
OutsideClick.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: OutsideClick, selectors: [["", "clrOutsideClick", ""]], hostBindings: function OutsideClick_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function OutsideClick_click_HostBindingHandler($event) { return ctx.documentClick($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { strict: ["clrStrict", "strict"] }, outputs: { outsideClick: "clrOutsideClick" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OutsideClick, [{
        type: core.Directive,
        args: [{ selector: '[clrOutsideClick]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { strict: [{
            type: core.Input,
            args: ['clrStrict']
        }], outsideClick: [{
            type: core.Output,
            args: ['clrOutsideClick']
        }], documentClick: [{
            type: core.HostListener,
            args: ['document:click', ['$event']]
        }] }); })();
        return OutsideClick;
    }());

    var OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];

    var ClrOutsideClickModule = /** @class */ (function () {
        function ClrOutsideClickModule() {
        }
ClrOutsideClickModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrOutsideClickModule });
ClrOutsideClickModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrOutsideClickModule_Factory(t) { return new (t || ClrOutsideClickModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrOutsideClickModule, { declarations: [OutsideClick], imports: [ɵngcc1.CommonModule], exports: [OutsideClick] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrOutsideClickModule, [{
        type: core.NgModule,
        args: [{ imports: [common.CommonModule], declarations: [OUSTIDE_CLICK_DIRECTIVES], exports: [OUSTIDE_CLICK_DIRECTIVES] }]
    }], function () { return []; }, null); })();
        return ClrOutsideClickModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DomAdapter = /** @class */ (function () {
        function DomAdapter() {
        }
        DomAdapter.prototype.userDefinedWidth = function (element) {
            element.classList.add('datagrid-cell-width-zero');
            var userDefinedWidth = this.clientRect(element).width;
            element.classList.remove('datagrid-cell-width-zero');
            return userDefinedWidth;
        };
        DomAdapter.prototype.scrollBarWidth = function (element) {
            return element.offsetWidth - element.clientWidth;
        };
        DomAdapter.prototype.scrollWidth = function (element) {
            return element.scrollWidth || 0;
        };
        DomAdapter.prototype.computedHeight = function (element) {
            return parseInt(getComputedStyle(element).getPropertyValue('height'), 10);
        };
        DomAdapter.prototype.clientRect = function (element) {
            var elementClientRect = element.getBoundingClientRect();
            return {
                top: parseInt(elementClientRect.top, 10),
                bottom: parseInt(elementClientRect.bottom, 10),
                left: parseInt(elementClientRect.left, 10),
                right: parseInt(elementClientRect.right, 10),
                width: parseInt(elementClientRect.width, 10),
                height: parseInt(elementClientRect.height, 10),
            };
        };
        DomAdapter.prototype.minWidth = function (element) {
            return parseInt(getComputedStyle(element).getPropertyValue('min-width'), 10);
        };
        DomAdapter.prototype.focus = function (element) {
            element.focus();
        };
DomAdapter.ɵfac = function DomAdapter_Factory(t) { return new (t || DomAdapter)(); };
DomAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DomAdapter, factory: function (t) { return DomAdapter.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DomAdapter, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DomAdapter;
    }());

    // This class is used to convert an internal event
    // to an external event to be emitted.
    var ClrDragEvent = /** @class */ (function () {
        function ClrDragEvent(dragEvent) {
            this.dragPosition = dragEvent.dragPosition;
            this.group = dragEvent.group;
            this.dragDataTransfer = dragEvent.dragDataTransfer;
            this.dropPointPosition = dragEvent.dropPointPosition;
        }
        return ClrDragEvent;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DragEventType;
    (function (DragEventType) {
        DragEventType[DragEventType["DRAG_START"] = 0] = "DRAG_START";
        DragEventType[DragEventType["DRAG_MOVE"] = 1] = "DRAG_MOVE";
        DragEventType[DragEventType["DRAG_END"] = 2] = "DRAG_END";
        DragEventType[DragEventType["DRAG_ENTER"] = 3] = "DRAG_ENTER";
        DragEventType[DragEventType["DRAG_LEAVE"] = 4] = "DRAG_LEAVE";
        DragEventType[DragEventType["DROP"] = 5] = "DROP";
    })(DragEventType || (DragEventType = {}));

    var DragAndDropEventBusService = /** @class */ (function () {
        function DragAndDropEventBusService() {
            this.dragStart = new rxjs.Subject();
            this.dragMove = new rxjs.Subject();
            this.dragEnd = new rxjs.Subject();
            this.drop = new rxjs.Subject();
        }
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragStarted", {
            get: function () {
                return this.dragStart.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragMoved", {
            get: function () {
                return this.dragMove.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragEnded", {
            get: function () {
                return this.dragEnd.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dropped", {
            get: function () {
                return this.drop.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DragAndDropEventBusService.prototype.broadcast = function (event) {
            switch (event.type) {
                case DragEventType.DRAG_START:
                    this.dragStart.next(event);
                    break;
                case DragEventType.DRAG_MOVE:
                    this.dragMove.next(event);
                    break;
                case DragEventType.DRAG_END:
                    this.dragEnd.next(event);
                    break;
                case DragEventType.DROP:
                    this.drop.next(event);
                    break;
                default:
                    break;
            }
        };
        DragAndDropEventBusService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function DragAndDropEventBusService_Factory() { return new DragAndDropEventBusService(); }, token: DragAndDropEventBusService, providedIn: "root" });
DragAndDropEventBusService.ɵfac = function DragAndDropEventBusService_Factory(t) { return new (t || DragAndDropEventBusService)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragAndDropEventBusService, [{
        type: core.Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
        return DragAndDropEventBusService;
    }());

    var DragEventListenerService = /** @class */ (function () {
        function DragEventListenerService(ngZone, renderer, eventBus) {
            this.ngZone = ngZone;
            this.renderer = renderer;
            this.eventBus = eventBus;
            this.dragStart = new rxjs.Subject();
            this.dragMove = new rxjs.Subject();
            this.dragEnd = new rxjs.Subject();
            this.hasDragStarted = false;
        }
        Object.defineProperty(DragEventListenerService.prototype, "dragStarted", {
            get: function () {
                return this.dragStart.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragEventListenerService.prototype, "dragMoved", {
            get: function () {
                return this.dragMove.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragEventListenerService.prototype, "dragEnded", {
            get: function () {
                return this.dragEnd.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DragEventListenerService.prototype.attachDragListeners = function (draggableEl) {
            this.draggableEl = draggableEl;
            this.listeners = [
                this.customDragEvent(this.draggableEl, 'mousedown', 'mousemove', 'mouseup'),
                this.customDragEvent(this.draggableEl, 'touchstart', 'touchmove', 'touchend'),
            ];
        };
        DragEventListenerService.prototype.detachDragListeners = function () {
            if (this.listeners) {
                this.listeners.map(function (event) { return event(); });
            }
            // In most cases, once users start dragging with mousedown/touchstart events,
            // they will end dragging at one point with mouseup/touchend.
            // However, there might be a few cases where mousedown/touchstart events get registered,
            // but the draggable element gets removed before user ends dragging.
            // In that case, we need to remove the attached listeners that happened during the mousedown/touchstart events.
            if (this.nestedListeners) {
                this.nestedListeners.map(function (event) { return event(); });
            }
        };
        DragEventListenerService.prototype.getNativeEventObject = function (event) {
            if (event.hasOwnProperty('changedTouches')) {
                return event.changedTouches[0];
            }
            else {
                return event;
            }
        };
        DragEventListenerService.prototype.customDragEvent = function (element, startOnEvent, moveOnEvent, endOnEvent) {
            var _this = this;
            return this.renderer.listen(element, startOnEvent, function (startEvent) {
                // save the initial point to initialPosition
                // this will be used to calculate how far the draggable has been dragged from its initial position
                _this.initialPosition = {
                    pageX: _this.getNativeEventObject(startEvent).pageX,
                    pageY: _this.getNativeEventObject(startEvent).pageY,
                };
                // Initialize nested listeners' property with a new empty array;
                _this.nestedListeners = [];
                // This is needed to disable selection during dragging (especially in EDGE/IE11).
                _this.nestedListeners.push(_this.renderer.listen('document', 'selectstart', function (selectEvent) {
                    selectEvent.preventDefault();
                    selectEvent.stopImmediatePropagation();
                }));
                // Listen to mousemove/touchmove events outside of angular zone.
                _this.nestedListeners.push(_this.ngZone.runOutsideAngular(function () {
                    return _this.renderer.listen('document', moveOnEvent, function (moveEvent) {
                        // Event.stopImmediatePropagation() is needed here to prevent nested draggables from getting dragged
                        // altogether. We shouldn't use Event.stopPropagation() here as we are listening to the events
                        // on the global element level.
                        // With Event.stopImmediatePropagation(), it registers the events sent from the inner most draggable
                        // first. Then immediately after that, it stops listening to the same type of events on the same
                        // element. So this will help us to not register the same events that would come from the parent
                        // level draggables eventually.
                        moveEvent.stopImmediatePropagation();
                        if (!_this.hasDragStarted) {
                            _this.hasDragStarted = true;
                            // Fire "dragstart"
                            _this.broadcast(moveEvent, DragEventType.DRAG_START);
                        }
                        else {
                            // Fire "dragmove"
                            _this.broadcast(moveEvent, DragEventType.DRAG_MOVE);
                        }
                    });
                }));
                // Listen to mouseup/touchend events.
                _this.nestedListeners.push(_this.renderer.listen('document', endOnEvent, function (endEvent) {
                    if (_this.hasDragStarted) {
                        // Fire "dragend" only if dragstart is registered
                        _this.hasDragStarted = false;
                        _this.broadcast(endEvent, DragEventType.DRAG_END);
                    }
                    // We must remove the the nested listeners every time drag completes.
                    if (_this.nestedListeners) {
                        _this.nestedListeners.map(function (event) { return event(); });
                    }
                }));
            });
        };
        DragEventListenerService.prototype.broadcast = function (event, eventType) {
            var dragEvent = this.generateDragEvent(event, eventType);
            switch (dragEvent.type) {
                case DragEventType.DRAG_START:
                    this.dragStart.next(dragEvent);
                    break;
                case DragEventType.DRAG_MOVE:
                    this.dragMove.next(dragEvent);
                    break;
                case DragEventType.DRAG_END:
                    this.dragEnd.next(dragEvent);
                    break;
                default:
                    break;
            }
            // The following properties are set after they are broadcasted to the DraggableGhost component.
            dragEvent.ghostElement = this.ghostElement;
            dragEvent.dropPointPosition = this.dropPointPosition;
            this.eventBus.broadcast(dragEvent);
        };
        DragEventListenerService.prototype.generateDragEvent = function (event, eventType) {
            var nativeEvent = this.getNativeEventObject(event);
            return {
                type: eventType,
                dragPosition: {
                    pageX: nativeEvent.pageX,
                    pageY: nativeEvent.pageY,
                    moveX: nativeEvent.pageX - this.initialPosition.pageX,
                    moveY: nativeEvent.pageY - this.initialPosition.pageY,
                },
                group: this.group,
                dragDataTransfer: this.dragDataTransfer,
                ghostElement: this.ghostElement,
            };
        };
        DragEventListenerService.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.Renderer2 },
            { type: DragAndDropEventBusService }
        ]; };
DragEventListenerService.ɵfac = function DragEventListenerService_Factory(t) { return new (t || DragEventListenerService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(DragAndDropEventBusService)); };
DragEventListenerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DragEventListenerService, factory: function (t) { return DragEventListenerService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragEventListenerService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: DragAndDropEventBusService }]; }, null); })();
        return DragEventListenerService;
    }());

    // This service is used to capture the state of clrDraggable element
    // at a certain event and passes it to clrDraggableGhost component.
    var DraggableSnapshotService = /** @class */ (function () {
        function DraggableSnapshotService(domAdapter) {
            this.domAdapter = domAdapter;
        }
        DraggableSnapshotService.prototype.capture = function (el, event) {
            this.draggableElClientRect = this.domAdapter.clientRect(el);
            this.snapshotDragEvent = event;
        };
        DraggableSnapshotService.prototype.discard = function () {
            delete this.draggableElClientRect;
            delete this.snapshotDragEvent;
        };
        Object.defineProperty(DraggableSnapshotService.prototype, "hasDraggableState", {
            get: function () {
                return !!this.snapshotDragEvent && !!this.draggableElClientRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DraggableSnapshotService.prototype, "clientRect", {
            get: function () {
                return this.draggableElClientRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DraggableSnapshotService.prototype, "dragEvent", {
            get: function () {
                return this.snapshotDragEvent;
            },
            enumerable: true,
            configurable: true
        });
        DraggableSnapshotService.ctorParameters = function () { return [
            { type: DomAdapter }
        ]; };
DraggableSnapshotService.ɵfac = function DraggableSnapshotService_Factory(t) { return new (t || DraggableSnapshotService)(ɵngcc0.ɵɵinject(DomAdapter)); };
DraggableSnapshotService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DraggableSnapshotService, factory: function (t) { return DraggableSnapshotService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableSnapshotService, [{
        type: core.Injectable
    }], function () { return [{ type: DomAdapter }]; }, null); })();
        return DraggableSnapshotService;
    }());

    var ClrDraggableGhost = /** @class */ (function () {
        function ClrDraggableGhost(el, dragEventListener, draggableSnapshot, renderer, ngZone) {
            var _this = this;
            this.el = el;
            this.dragEventListener = dragEventListener;
            this.draggableSnapshot = draggableSnapshot;
            this.renderer = renderer;
            this.ngZone = ngZone;
            this.subscriptions = [];
            this.leaveAnimConfig = { value: 0, params: { top: '0px', left: '0px' } };
            if (!this.dragEventListener || !this.draggableSnapshot) {
                throw new Error('The clr-draggable-ghost component can only be used inside of a clrDraggable directive.');
            }
            this.draggableGhostEl = this.el.nativeElement;
            // Need to use Renderer2 as it runs outside of NgZone
            this.renderer.addClass(this.draggableGhostEl, 'draggable-ghost');
            // Register the ghost element in DragEventListener to pass in a ClrDragEvent.
            this.dragEventListener.ghostElement = this.draggableGhostEl;
            // Default ghost size gets the size of ClrDraggable element.
            this.setDefaultGhostSize(this.draggableGhostEl);
            var offset = {
                top: this.draggableSnapshot.hasDraggableState
                    ? this.draggableSnapshot.dragEvent.dragPosition.pageY - this.draggableSnapshot.clientRect.top
                    : 0,
                left: this.draggableSnapshot.hasDraggableState
                    ? this.draggableSnapshot.dragEvent.dragPosition.pageX - this.draggableSnapshot.clientRect.left
                    : 0,
            };
            var isAnimationConfigured = false;
            this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
                // On the first drag move event, we configure the animation as it's dependent on the first drag event.
                if (!isAnimationConfigured) {
                    if (_this.draggableSnapshot.hasDraggableState) {
                        _this.animateToOnLeave(_this.draggableSnapshot.clientRect.top + "px", _this.draggableSnapshot.clientRect.left + "px");
                    }
                    else {
                        _this.animateToOnLeave(event.dragPosition.pageY + "px", event.dragPosition.pageX + "px");
                    }
                    isAnimationConfigured = true;
                }
                // Position the draggable ghost.
                var topLeftPosition = _this.findTopLeftPosition(event.dragPosition, offset);
                _this.setPositionStyle(_this.draggableGhostEl, topLeftPosition.pageX, topLeftPosition.pageY);
                _this.dragEventListener.dropPointPosition = _this.findDropPointPosition(topLeftPosition);
            }));
        }
        ClrDraggableGhost.prototype.setDefaultGhostSize = function (el) {
            if (this.draggableSnapshot.hasDraggableState) {
                this.setSizeStyle(el, this.draggableSnapshot.clientRect.width, this.draggableSnapshot.clientRect.height);
            }
        };
        ClrDraggableGhost.prototype.animateToOnLeave = function (top, left) {
            var _this = this;
            this.ngZone.run(function () {
                _this.leaveAnimConfig = { value: 0, params: { top: top, left: left } };
            });
        };
        ClrDraggableGhost.prototype.findTopLeftPosition = function (dragPosition, offset) {
            return { pageX: dragPosition.pageX - offset.left, pageY: dragPosition.pageY - offset.top };
        };
        ClrDraggableGhost.prototype.findDropPointPosition = function (topLeftPosition) {
            if (this.draggableSnapshot.hasDraggableState) {
                return {
                    pageX: topLeftPosition.pageX + this.draggableSnapshot.clientRect.width / 2,
                    pageY: topLeftPosition.pageY + this.draggableSnapshot.clientRect.height / 2,
                };
            }
            else {
                return topLeftPosition;
            }
        };
        ClrDraggableGhost.prototype.setSizeStyle = function (el, width, height) {
            this.renderer.setStyle(el, 'width', width + "px");
            this.renderer.setStyle(el, 'height', height + "px");
        };
        ClrDraggableGhost.prototype.setPositionStyle = function (el, left, top) {
            this.renderer.setStyle(el, 'left', left + "px");
            this.renderer.setStyle(el, 'top', top + "px");
            this.renderer.setStyle(el, 'visibility', 'visible');
        };
        ClrDraggableGhost.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDraggableGhost.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: DragEventListenerService, decorators: [{ type: core.Optional }] },
            { type: DraggableSnapshotService, decorators: [{ type: core.Optional }] },
            { type: core.Renderer2 },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.HostBinding('@leaveAnimation')
        ], ClrDraggableGhost.prototype, "leaveAnimConfig", void 0);
        ClrDraggableGhost = __decorate([ __param(1, core.Optional()),
            __param(2, core.Optional())
        ], ClrDraggableGhost);
ClrDraggableGhost.ɵfac = function ClrDraggableGhost_Factory(t) { return new (t || ClrDraggableGhost)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragEventListenerService, 8), ɵngcc0.ɵɵdirectiveInject(DraggableSnapshotService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ClrDraggableGhost.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDraggableGhost, selectors: [["clr-draggable-ghost"]], hostVars: 1, hostBindings: function ClrDraggableGhost_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@leaveAnimation", ctx.leaveAnimConfig);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrDraggableGhost_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, data: { animation: [
            animations.trigger('leaveAnimation', [
                animations.transition(':leave', [
                    animations.style({ left: '*', top: '*' }),
                    animations.animate('0.2s ease-in-out', animations.style({ top: '{{top}}', left: '{{left}}' })),
                ]),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDraggableGhost, [{
        type: core.Component,
        args: [{
                selector: 'clr-draggable-ghost',
                template: "<ng-content></ng-content>",
                animations: [
                    animations.trigger('leaveAnimation', [
                        animations.transition(':leave', [
                            animations.style({ left: '*', top: '*' }),
                            animations.animate('0.2s ease-in-out', animations.style({ top: '{{top}}', left: '{{left}}' })),
                        ]),
                    ]),
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragEventListenerService, decorators: [{
                type: core.Optional
            }] }, { type: DraggableSnapshotService, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { leaveAnimConfig: [{
            type: core.HostBinding,
            args: ['@leaveAnimation']
        }] }); })();
        return ClrDraggableGhost;
    }());

    // This structural directive will be used mainly together with `clr-draggable-ghost` directive inside of clrDraggable
    // directive. The directive is responsible for instantiating `clr-draggable-ghost` directive only during dragging so
    // that Angular Change Detection is prevented from running if a component or directive is placed inside of the
    // `clr-draggable-ghost` directive.
    var ClrIfDragged = /** @class */ (function () {
        function ClrIfDragged(template, container, dragEventListener) {
            var _this = this;
            this.template = template;
            this.container = container;
            this.dragEventListener = dragEventListener;
            this.subscriptions = [];
            if (!this.dragEventListener || !this.container) {
                throw new Error('The *clrIfDragged directive can only be used inside of a clrDraggable directive.');
            }
            this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
                _this.container.createEmbeddedView(_this.template);
            }));
            this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
                _this.container.clear();
            }));
        }
        ClrIfDragged.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrIfDragged.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: DragEventListenerService, decorators: [{ type: core.Optional }] }
        ]; };
        ClrIfDragged = __decorate([ __param(1, core.Optional()),
            __param(1, core.SkipSelf()),
            __param(2, core.Optional())
        ], ClrIfDragged);
ClrIfDragged.ɵfac = function ClrIfDragged_Factory(t) { return new (t || ClrIfDragged)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef, 12), ɵngcc0.ɵɵdirectiveInject(DragEventListenerService, 8)); };
ClrIfDragged.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIfDragged, selectors: [["", "clrIfDragged", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIfDragged, [{
        type: core.Directive,
        args: [{ selector: '[clrIfDragged]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef, decorators: [{
                type: core.Optional
            }, {
                type: core.SkipSelf
            }] }, { type: DragEventListenerService, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return ClrIfDragged;
    }());

    // This provider registers the drag handle element.
    // When it registers a element as a drag handle, it attaches that element to the listeners from ClrDragEventListener.
    // Also, it adds the "drag-handle" css class to the registered element through Renderer.
    var DragHandleRegistrarService = /** @class */ (function () {
        function DragHandleRegistrarService(dragEventListener, renderer) {
            this.dragEventListener = dragEventListener;
            this.renderer = renderer;
        }
        Object.defineProperty(DragHandleRegistrarService.prototype, "defaultHandleEl", {
            get: function () {
                return this._defaultHandleEl;
            },
            set: function (el) {
                this._defaultHandleEl = el; // defaultHandleEl will be usually the clrDraggable element.
                // If the customHandleEl has been registered,
                // don't make the defaultHandleEl the drag handle yet until the customHandleEl is unregistered.
                if (!this._customHandleEl) {
                    this.makeElementHandle(this._defaultHandleEl);
                }
            },
            enumerable: true,
            configurable: true
        });
        DragHandleRegistrarService.prototype.makeElementHandle = function (el) {
            if (this._defaultHandleEl && this._defaultHandleEl !== el) {
                // Before making an element the custom handle element,
                // we should remove the existing drag-handle class from the draggable element.
                this.renderer.removeClass(this._defaultHandleEl, 'drag-handle');
            }
            this.dragEventListener.attachDragListeners(el);
            this.renderer.addClass(el, 'drag-handle');
        };
        Object.defineProperty(DragHandleRegistrarService.prototype, "customHandleEl", {
            get: function () {
                return this._customHandleEl;
            },
            enumerable: true,
            configurable: true
        });
        DragHandleRegistrarService.prototype.registerCustomHandle = function (el) {
            this.dragEventListener.detachDragListeners(); // removes the existing listeners
            this._customHandleEl = el;
            this.makeElementHandle(this._customHandleEl);
        };
        DragHandleRegistrarService.prototype.unregisterCustomHandle = function () {
            this.dragEventListener.detachDragListeners(); // removes the existing listeners
            this.renderer.removeClass(this._customHandleEl, 'drag-handle');
            delete this._customHandleEl;
            // if default handle is set, make that handle
            if (this._defaultHandleEl) {
                this.makeElementHandle(this._defaultHandleEl);
            }
        };
        DragHandleRegistrarService.ctorParameters = function () { return [
            { type: DragEventListenerService },
            { type: core.Renderer2 }
        ]; };
DragHandleRegistrarService.ɵfac = function DragHandleRegistrarService_Factory(t) { return new (t || DragHandleRegistrarService)(ɵngcc0.ɵɵinject(DragEventListenerService), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2)); };
DragHandleRegistrarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DragHandleRegistrarService, factory: function (t) { return DragHandleRegistrarService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragHandleRegistrarService, [{
        type: core.Injectable
    }], function () { return [{ type: DragEventListenerService }, { type: ɵngcc0.Renderer2 }]; }, null); })();
        return DragHandleRegistrarService;
    }());

    // This service class adds and removes the "in-drag" class to the document body element
    // through its public enter() and exit() methods.
    var GlobalDragModeService = /** @class */ (function () {
        function GlobalDragModeService(renderer) {
            this.renderer = renderer;
        }
        GlobalDragModeService.prototype.enter = function () {
            this.renderer.addClass(document.body, 'in-drag');
        };
        GlobalDragModeService.prototype.exit = function () {
            this.renderer.removeClass(document.body, 'in-drag');
        };
        GlobalDragModeService.ctorParameters = function () { return [
            { type: core.Renderer2 }
        ]; };
GlobalDragModeService.ɵfac = function GlobalDragModeService_Factory(t) { return new (t || GlobalDragModeService)(ɵngcc0.ɵɵinject(ɵngcc0.Renderer2)); };
GlobalDragModeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GlobalDragModeService, factory: function (t) { return GlobalDragModeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GlobalDragModeService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();
        return GlobalDragModeService;
    }());

    var ClrDraggable = /** @class */ (function () {
        function ClrDraggable(el, dragEventListener, dragHandleRegistrar, viewContainerRef, cfr, injector, draggableSnapshot, globalDragMode) {
            this.el = el;
            this.dragEventListener = dragEventListener;
            this.dragHandleRegistrar = dragHandleRegistrar;
            this.viewContainerRef = viewContainerRef;
            this.cfr = cfr;
            this.injector = injector;
            this.draggableSnapshot = draggableSnapshot;
            this.globalDragMode = globalDragMode;
            this.subscriptions = [];
            this.dragOn = false;
            this.dragStartEmitter = new core.EventEmitter();
            this.dragMoveEmitter = new core.EventEmitter();
            this.dragEndEmitter = new core.EventEmitter();
            this.draggableEl = this.el.nativeElement;
            this.componentFactory = this.cfr.resolveComponentFactory(ClrDraggableGhost);
        }
        Object.defineProperty(ClrDraggable.prototype, "dataTransfer", {
            set: function (value) {
                this.dragEventListener.dragDataTransfer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDraggable.prototype, "group", {
            set: function (value) {
                this.dragEventListener.group = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrDraggable.prototype.createDefaultGhost = function (event) {
            this.draggableSnapshot.capture(this.draggableEl, event);
            // NOTE: The default ghost element will appear
            // next to the clrDraggable in the DOM as a sibling element.
            this.viewContainerRef.createComponent(this.componentFactory, 0, this.injector, [
                [this.draggableEl.cloneNode(true)],
            ]);
        };
        ClrDraggable.prototype.destroyDefaultGhost = function () {
            this.viewContainerRef.clear();
            this.draggableSnapshot.discard();
        };
        ClrDraggable.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.dragHandleRegistrar.defaultHandleEl = this.draggableEl;
            this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
                _this.globalDragMode.enter();
                _this.dragOn = true;
                if (!_this.customGhost) {
                    _this.createDefaultGhost(event);
                }
                _this.dragStartEmitter.emit(new ClrDragEvent(event));
            }));
            this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
                _this.dragMoveEmitter.emit(new ClrDragEvent(event));
            }));
            this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
                _this.globalDragMode.exit();
                _this.dragOn = false;
                if (!_this.customGhost) {
                    _this.destroyDefaultGhost();
                }
                _this.dragEndEmitter.emit(new ClrDragEvent(event));
            }));
        };
        ClrDraggable.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            this.dragEventListener.detachDragListeners();
        };
        ClrDraggable.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: DragEventListenerService },
            { type: DragHandleRegistrarService },
            { type: core.ViewContainerRef },
            { type: core.ComponentFactoryResolver },
            { type: core.Injector },
            { type: DraggableSnapshotService },
            { type: GlobalDragModeService }
        ]; };
        __decorate([
            core.ContentChild(ClrIfDragged)
        ], ClrDraggable.prototype, "customGhost", void 0);
        __decorate([
            core.Input('clrDraggable')
        ], ClrDraggable.prototype, "dataTransfer", null);
        __decorate([
            core.Input('clrGroup')
        ], ClrDraggable.prototype, "group", null);
        __decorate([
            core.Output('clrDragStart')
        ], ClrDraggable.prototype, "dragStartEmitter", void 0);
        __decorate([
            core.Output('clrDragMove')
        ], ClrDraggable.prototype, "dragMoveEmitter", void 0);
        __decorate([
            core.Output('clrDragEnd')
        ], ClrDraggable.prototype, "dragEndEmitter", void 0);
ClrDraggable.ɵfac = function ClrDraggable_Factory(t) { return new (t || ClrDraggable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragEventListenerService), ɵngcc0.ɵɵdirectiveInject(DragHandleRegistrarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(DraggableSnapshotService), ɵngcc0.ɵɵdirectiveInject(GlobalDragModeService)); };
ClrDraggable.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDraggable, selectors: [["", "clrDraggable", ""]], contentQueries: function ClrDraggable_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrIfDragged, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customGhost = _t.first);
    } }, hostVars: 4, hostBindings: function ClrDraggable_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("draggable", true)("being-dragged", ctx.dragOn);
    } }, inputs: { dataTransfer: ["clrDraggable", "dataTransfer"], group: ["clrGroup", "group"] }, outputs: { dragStartEmitter: "clrDragStart", dragMoveEmitter: "clrDragMove", dragEndEmitter: "clrDragEnd" }, features: [ɵngcc0.ɵɵProvidersFeature([
            DragEventListenerService,
            DragHandleRegistrarService,
            DraggableSnapshotService,
            GlobalDragModeService,
            DomAdapter,
        ])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDraggable, [{
        type: core.Directive,
        args: [{
                selector: '[clrDraggable]',
                providers: [
                    DragEventListenerService,
                    DragHandleRegistrarService,
                    DraggableSnapshotService,
                    GlobalDragModeService,
                    DomAdapter,
                ],
                host: { '[class.draggable]': 'true', '[class.being-dragged]': 'dragOn' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragEventListenerService }, { type: DragHandleRegistrarService }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }, { type: DraggableSnapshotService }, { type: GlobalDragModeService }]; }, { dragStartEmitter: [{
            type: core.Output,
            args: ['clrDragStart']
        }], dragMoveEmitter: [{
            type: core.Output,
            args: ['clrDragMove']
        }], dragEndEmitter: [{
            type: core.Output,
            args: ['clrDragEnd']
        }], dataTransfer: [{
            type: core.Input,
            args: ['clrDraggable']
        }], group: [{
            type: core.Input,
            args: ['clrGroup']
        }], customGhost: [{
            type: core.ContentChild,
            args: [ClrIfDragged]
        }] }); })();
        return ClrDraggable;
    }());

    var ClrDroppable = /** @class */ (function () {
        function ClrDroppable(el, eventBus, domAdapter, renderer) {
            this.el = el;
            this.eventBus = eventBus;
            this.domAdapter = domAdapter;
            this.renderer = renderer;
            this.isDraggableMatch = false;
            this._isDraggableOver = false;
            this._dropTolerance = { top: 0, right: 0, bottom: 0, left: 0 };
            this.dragStartEmitter = new core.EventEmitter();
            this.dragMoveEmitter = new core.EventEmitter();
            this.dragEndEmitter = new core.EventEmitter();
            this.dragLeaveEmitter = new core.EventEmitter();
            this.dragEnterEmitter = new core.EventEmitter();
            this.dropEmitter = new core.EventEmitter();
            this.droppableEl = this.el.nativeElement;
        }
        Object.defineProperty(ClrDroppable.prototype, "isDraggableOver", {
            set: function (value) {
                // We need to add/remove this draggable-over class via Renderer2
                // because isDraggableOver is set outside of NgZone.
                if (value) {
                    this.renderer.addClass(this.droppableEl, 'draggable-over');
                }
                else {
                    this.renderer.removeClass(this.droppableEl, 'draggable-over');
                }
                this._isDraggableOver = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDroppable.prototype, "group", {
            set: function (value) {
                this._group = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrDroppable.prototype.dropToleranceGenerator = function (top, right, bottom, left) {
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = top; }
            if (bottom === void 0) { bottom = top; }
            if (left === void 0) { left = right; }
            return { top: top, right: right, bottom: bottom, left: left };
        };
        Object.defineProperty(ClrDroppable.prototype, "dropTolerance", {
            set: function (value) {
                // If user provides an object here and wants to manipulate/update properties individually,
                // the object must be immutable as we generate new object based user's given object.
                if (typeof value === 'number') {
                    this._dropTolerance = this.dropToleranceGenerator(value);
                }
                else if (typeof value === 'string') {
                    var toleranceValues = value
                        .trim()
                        .split(/\s+/)
                        .map(function (tolerance) { return parseInt(tolerance, 10); });
                    this._dropTolerance = this.dropToleranceGenerator.apply(this, __spread(toleranceValues));
                }
                else if (value) {
                    // The value could be passed in as {left: 20, top: 30 }
                    // In this case, the rest of the direction properties should be 0.
                    // That's why we initialize properties with 0 first, then override with user's given value.
                    this._dropTolerance = __assign(__assign({}, this.dropToleranceGenerator(0)), value);
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDroppable.prototype.unsubscribeFrom = function (subscription) {
            if (subscription) {
                subscription.unsubscribe();
            }
        };
        ClrDroppable.prototype.checkGroupMatch = function (draggableGroup) {
            // Both Draggable and Droppable have clrGroup input.
            // The clrGroup input can be both a string key or array of string keys in Draggable and Droppable.
            // It's not match if Draggable has no defined value assigned to clrGroup, but Droppable has a defined clrGroup.
            if (!draggableGroup && this._group) {
                return false;
            }
            // The same is true the other way round.
            if (!this._group && draggableGroup) {
                return false;
            }
            // It's match if both Draggable and Droppable have no assigned value for clrGroup.
            if (!this._group && !draggableGroup) {
                return true;
            }
            // It's match if both Draggable and Droppable have simple string keys that are matching.
            // It's match if Draggable's simple clrGroup key is matching with one of the clrGroup keys of Droppable. The
            // same is true the other way round.
            // it's match if one of the clrGroup keys of Droppable is matching with one of the clrGroup keys of Draggable.
            if (typeof draggableGroup === 'string') {
                if (typeof this._group === 'string') {
                    return this._group === draggableGroup;
                }
                else {
                    return this._group.indexOf(draggableGroup) > -1;
                }
            }
            else {
                if (typeof this._group === 'string') {
                    return draggableGroup.indexOf(this._group) > -1;
                }
                else {
                    return this._group.some(function (groupKey) { return draggableGroup.indexOf(groupKey) > -1; });
                }
            }
        };
        ClrDroppable.prototype.isInDropArea = function (point) {
            if (!point) {
                return false;
            }
            if (!this.clientRect) {
                this.clientRect = this.domAdapter.clientRect(this.droppableEl);
            }
            if (point.pageX >= this.clientRect.left - this._dropTolerance.left &&
                point.pageX <= this.clientRect.right + this._dropTolerance.right &&
                point.pageY >= this.clientRect.top - this._dropTolerance.top &&
                point.pageY <= this.clientRect.bottom + this._dropTolerance.bottom) {
                return true;
            }
            else {
                return false;
            }
        };
        ClrDroppable.prototype.onDragStart = function (dragStartEvent) {
            var _this = this;
            // Check draggable and droppable have a matching group key.
            this.isDraggableMatch = this.checkGroupMatch(dragStartEvent.group);
            // Subscribe to dragMoved and dragEnded only if draggable and droppable have a matching group key.
            if (this.isDraggableMatch) {
                this.dragStartEmitter.emit(new ClrDragEvent(dragStartEvent));
                this.dragMoveSubscription = this.eventBus.dragMoved.subscribe(function (dragMoveEvent) {
                    _this.onDragMove(dragMoveEvent);
                });
                this.dragEndSubscription = this.eventBus.dragEnded.subscribe(function (dragEndEvent) {
                    _this.onDragEnd(dragEndEvent);
                });
            }
        };
        ClrDroppable.prototype.onDragMove = function (dragMoveEvent) {
            var isInDropArea = this.isInDropArea(dragMoveEvent.dropPointPosition);
            if (!this._isDraggableOver && isInDropArea) {
                this.isDraggableOver = true;
                var dragEnterEvent = __assign(__assign({}, dragMoveEvent), { type: DragEventType.DRAG_ENTER });
                this.eventBus.broadcast(dragEnterEvent);
                this.dragEnterEmitter.emit(new ClrDragEvent(dragEnterEvent));
            }
            else if (this._isDraggableOver && !isInDropArea) {
                this.isDraggableOver = false;
                var dragLeaveEvent = __assign(__assign({}, dragMoveEvent), { type: DragEventType.DRAG_LEAVE });
                this.eventBus.broadcast(dragLeaveEvent);
                this.dragLeaveEmitter.emit(new ClrDragEvent(dragLeaveEvent));
            }
            this.dragMoveEmitter.emit(new ClrDragEvent(dragMoveEvent));
        };
        ClrDroppable.prototype.onDragEnd = function (dragEndEvent) {
            if (this._isDraggableOver) {
                if (dragEndEvent.ghostElement) {
                    // By this point, the draggable ghost component is destroyed,
                    // but the element would be active until its animation completes.
                    // As such, once the ghost is dropped over, we will give it "dropped" class.
                    // This process cannot be done in the ghost component
                    // because any subscription to the drop event is ineffective or invalid
                    // as the component had been already destroyed.
                    this.renderer.addClass(dragEndEvent.ghostElement, 'dropped');
                }
                var dropEvent = __assign(__assign({}, dragEndEvent), { type: DragEventType.DROP });
                this.eventBus.broadcast(dropEvent);
                this.dropEmitter.emit(new ClrDragEvent(dropEvent));
                this.isDraggableOver = false;
            }
            this.dragEndEmitter.emit(new ClrDragEvent(dragEndEvent));
            this.unsubscribeFrom(this.dragMoveSubscription);
            this.unsubscribeFrom(this.dragEndSubscription);
            this.isDraggableMatch = false;
            delete this.clientRect;
        };
        ClrDroppable.prototype.ngOnInit = function () {
            var _this = this;
            this.dragStartSubscription = this.eventBus.dragStarted.subscribe(function (dragStartEvent) {
                _this.onDragStart(dragStartEvent);
            });
        };
        ClrDroppable.prototype.ngOnDestroy = function () {
            this.unsubscribeFrom(this.dragStartSubscription);
            this.unsubscribeFrom(this.dragMoveSubscription);
            this.unsubscribeFrom(this.dragEndSubscription);
        };
        ClrDroppable.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: DragAndDropEventBusService },
            { type: DomAdapter },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.Input('clrGroup')
        ], ClrDroppable.prototype, "group", null);
        __decorate([
            core.Input('clrDropTolerance')
        ], ClrDroppable.prototype, "dropTolerance", null);
        __decorate([
            core.Output('clrDragStart')
        ], ClrDroppable.prototype, "dragStartEmitter", void 0);
        __decorate([
            core.Output('clrDragMove')
        ], ClrDroppable.prototype, "dragMoveEmitter", void 0);
        __decorate([
            core.Output('clrDragEnd')
        ], ClrDroppable.prototype, "dragEndEmitter", void 0);
        __decorate([
            core.Output('clrDragLeave')
        ], ClrDroppable.prototype, "dragLeaveEmitter", void 0);
        __decorate([
            core.Output('clrDragEnter')
        ], ClrDroppable.prototype, "dragEnterEmitter", void 0);
        __decorate([
            core.Output('clrDrop')
        ], ClrDroppable.prototype, "dropEmitter", void 0);
ClrDroppable.ɵfac = function ClrDroppable_Factory(t) { return new (t || ClrDroppable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragAndDropEventBusService), ɵngcc0.ɵɵdirectiveInject(DomAdapter), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ClrDroppable.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDroppable, selectors: [["", "clrDroppable", ""]], hostVars: 4, hostBindings: function ClrDroppable_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("droppable", true)("draggable-match", ctx.isDraggableMatch);
    } }, inputs: { group: ["clrGroup", "group"], dropTolerance: ["clrDropTolerance", "dropTolerance"] }, outputs: { dragStartEmitter: "clrDragStart", dragMoveEmitter: "clrDragMove", dragEndEmitter: "clrDragEnd", dragLeaveEmitter: "clrDragLeave", dragEnterEmitter: "clrDragEnter", dropEmitter: "clrDrop" }, features: [ɵngcc0.ɵɵProvidersFeature([DomAdapter])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDroppable, [{
        type: core.Directive,
        args: [{
                selector: '[clrDroppable]',
                providers: [DomAdapter],
                host: { '[class.droppable]': 'true', '[class.draggable-match]': 'isDraggableMatch' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragAndDropEventBusService }, { type: DomAdapter }, { type: ɵngcc0.Renderer2 }]; }, { dragStartEmitter: [{
            type: core.Output,
            args: ['clrDragStart']
        }], dragMoveEmitter: [{
            type: core.Output,
            args: ['clrDragMove']
        }], dragEndEmitter: [{
            type: core.Output,
            args: ['clrDragEnd']
        }], dragLeaveEmitter: [{
            type: core.Output,
            args: ['clrDragLeave']
        }], dragEnterEmitter: [{
            type: core.Output,
            args: ['clrDragEnter']
        }], dropEmitter: [{
            type: core.Output,
            args: ['clrDrop']
        }], group: [{
            type: core.Input,
            args: ['clrGroup']
        }], dropTolerance: [{
            type: core.Input,
            args: ['clrDropTolerance']
        }] }); })();
        return ClrDroppable;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDragHandle = /** @class */ (function () {
        function ClrDragHandle(el, dragHandleRegistrar) {
            this.el = el;
            this.dragHandleRegistrar = dragHandleRegistrar;
            if (!this.dragHandleRegistrar) {
                // ClrDragHandleRegistrar is provided in ClrDraggable so we expect it to be present here
                // as clrDragHandle is required to be used only inside of a clrDraggable directive.
                throw new Error('The clrDragHandle directive can only be used inside of a clrDraggable directive.');
            }
            this.dragHandleRegistrar.registerCustomHandle(this.el.nativeElement);
        }
        ClrDragHandle.prototype.ngOnDestroy = function () {
            this.dragHandleRegistrar.unregisterCustomHandle();
        };
        ClrDragHandle.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: DragHandleRegistrarService, decorators: [{ type: core.Optional }] }
        ]; };
        ClrDragHandle = __decorate([ __param(1, core.Optional())
        ], ClrDragHandle);
ClrDragHandle.ɵfac = function ClrDragHandle_Factory(t) { return new (t || ClrDragHandle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragHandleRegistrarService, 8)); };
ClrDragHandle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDragHandle, selectors: [["", "clrDragHandle", ""]], hostVars: 2, hostBindings: function ClrDragHandle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("drag-handle", true);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDragHandle, [{
        type: core.Directive,
        args: [{ selector: '[clrDragHandle]', host: { '[class.drag-handle]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragHandleRegistrarService, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return ClrDragHandle;
    }());

    var CLR_DRAG_AND_DROP_DIRECTIVES = [
        ClrDraggable,
        ClrDroppable,
        ClrIfDragged,
        ClrDragHandle,
        ClrDraggableGhost,
    ];
    var ClrDragAndDropModule = /** @class */ (function () {
        function ClrDragAndDropModule() {
        }
ClrDragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrDragAndDropModule });
ClrDragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrDragAndDropModule_Factory(t) { return new (t || ClrDragAndDropModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrDragAndDropModule, { declarations: [ClrDraggable,
        ClrDroppable,
        ClrIfDragged,
        ClrDragHandle,
        ClrDraggableGhost], imports: [ɵngcc1.CommonModule], exports: [ClrDraggable,
        ClrDroppable,
        ClrIfDragged,
        ClrDragHandle,
        ClrDraggableGhost] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDragAndDropModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [CLR_DRAG_AND_DROP_DIRECTIVES],
                entryComponents: [ClrDraggableGhost],
                exports: [CLR_DRAG_AND_DROP_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrDragAndDropModule;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrExpandableAnimation = /** @class */ (function () {
        function ClrExpandableAnimation(element, domAdapter) {
            this.element = element;
            this.domAdapter = domAdapter;
            this.startHeight = 0;
        }
        Object.defineProperty(ClrExpandableAnimation.prototype, "expandAnimation", {
            get: function () {
                return { value: this.clrExpandTrigger, params: { startHeight: this.startHeight } };
            },
            enumerable: true,
            configurable: true
        });
        ClrExpandableAnimation.prototype.animationDone = function () {
            // A "safe" auto-update of the height ensuring basic OOTB user experience .
            // Prone to small jumps in initial animation height if data was changed in the meantime, window was resized, etc.
            // For optimal behavior call manually updateStartHeight() from the parent component before initiating the update.
            this.updateStartHeight();
        };
        ClrExpandableAnimation.prototype.updateStartHeight = function () {
            this.startHeight = this.domAdapter.computedHeight(this.element.nativeElement) || 0;
        };
        ClrExpandableAnimation.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: DomAdapter }
        ]; };
        __decorate([
            core.Input()
        ], ClrExpandableAnimation.prototype, "clrExpandTrigger", void 0);
        __decorate([
            core.HostBinding('@expandAnimation')
        ], ClrExpandableAnimation.prototype, "expandAnimation", null);
        __decorate([
            core.HostListener('@expandAnimation.done')
        ], ClrExpandableAnimation.prototype, "animationDone", null);
ClrExpandableAnimation.ɵfac = function ClrExpandableAnimation_Factory(t) { return new (t || ClrExpandableAnimation)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DomAdapter)); };
ClrExpandableAnimation.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrExpandableAnimation, selectors: [["clr-expandable-animation"]], hostVars: 1, hostBindings: function ClrExpandableAnimation_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵcomponentHostSyntheticListener("@expandAnimation.done", function ClrExpandableAnimation_animation_expandAnimation_done_HostBindingHandler() { return ctx.animationDone(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@expandAnimation", ctx.expandAnimation);
    } }, inputs: { clrExpandTrigger: "clrExpandTrigger" }, features: [ɵngcc0.ɵɵProvidersFeature([DomAdapter])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrExpandableAnimation_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n      display: block;\n    }"], data: { animation: [
            animations.trigger('expandAnimation', [
                animations.transition('true <=> false', [
                    animations.style({ height: '{{startHeight}}px', overflow: 'hidden' }),
                    animations.animate('0.2s ease-in-out', animations.style({ height: '*' })),
                ]),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrExpandableAnimation, [{
        type: core.Component,
        args: [{
                selector: 'clr-expandable-animation',
                template: "\n    <ng-content></ng-content>\n  ",
                animations: [
                    animations.trigger('expandAnimation', [
                        animations.transition('true <=> false', [
                            animations.style({ height: '{{startHeight}}px', overflow: 'hidden' }),
                            animations.animate('0.2s ease-in-out', animations.style({ height: '*' })),
                        ]),
                    ]),
                ],
                providers: [DomAdapter],
                styles: ["\n    :host {\n      display: block;\n    }\n  "]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DomAdapter }]; }, { expandAnimation: [{
            type: core.HostBinding,
            args: ['@expandAnimation']
        }], animationDone: [{
            type: core.HostListener,
            args: ['@expandAnimation.done']
        }], clrExpandTrigger: [{
            type: core.Input
        }] }); })();
        return ClrExpandableAnimation;
    }());

    var EXPANDABLE_ANIMATION_DIRECTIVES = [ClrExpandableAnimation];

    var ClrExpandableAnimationModule = /** @class */ (function () {
        function ClrExpandableAnimationModule() {
        }
ClrExpandableAnimationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrExpandableAnimationModule });
ClrExpandableAnimationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrExpandableAnimationModule_Factory(t) { return new (t || ClrExpandableAnimationModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrExpandableAnimationModule, { declarations: [ClrExpandableAnimation], imports: [ɵngcc1.CommonModule], exports: [ClrExpandableAnimation] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrExpandableAnimationModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [EXPANDABLE_ANIMATION_DIRECTIVES],
                exports: [EXPANDABLE_ANIMATION_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrExpandableAnimationModule;
    }());

    var ClrSpinner = /** @class */ (function () {
        function ClrSpinner(el, ariaLiveService) {
            this.el = el;
            this.ariaLiveService = ariaLiveService;
        }
        ClrSpinner.prototype.ngAfterViewInit = function () {
            this.ariaLiveService.announce(this.el.nativeElement, this.ariaLive);
        };
        Object.defineProperty(ClrSpinner.prototype, "spinnerClass", {
            /**
             * Default class for all spinners. This class is always true
             */
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "inlineClass", {
            get: function () {
                return this._inline;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrInline", {
            set: function (value) {
                this._inline = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "inverseClass", {
            get: function () {
                return this._inverse;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrInverse", {
            set: function (value) {
                this._inverse = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "smallClass", {
            get: function () {
                return this._small;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrSmall", {
            set: function (value) {
                this._small = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "mediumClass", {
            get: function () {
                if (this._small) {
                    return false;
                }
                return this._medium;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "clrMedium", {
            set: function (value) {
                this._medium = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrSpinner.prototype, "ariaLive", {
            get: function () {
                if (isBooleanAttributeSet(this.assertive)) {
                    return exports.ClrAriaLivePoliteness.assertive;
                }
                if (isBooleanAttributeSet(this.off)) {
                    return exports.ClrAriaLivePoliteness.off;
                }
                return exports.ClrAriaLivePoliteness.polite;
            },
            enumerable: true,
            configurable: true
        });
        ClrSpinner.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: ClrAriaLiveService }
        ]; };
        __decorate([
            core.HostBinding('class.spinner')
        ], ClrSpinner.prototype, "spinnerClass", null);
        __decorate([
            core.HostBinding('class.spinner-inline')
        ], ClrSpinner.prototype, "inlineClass", null);
        __decorate([
            core.Input('clrInline')
        ], ClrSpinner.prototype, "clrInline", null);
        __decorate([
            core.HostBinding('class.spinner-inverse')
        ], ClrSpinner.prototype, "inverseClass", null);
        __decorate([
            core.Input('clrInverse')
        ], ClrSpinner.prototype, "clrInverse", null);
        __decorate([
            core.HostBinding('class.spinner-sm')
        ], ClrSpinner.prototype, "smallClass", null);
        __decorate([
            core.Input('clrSmall')
        ], ClrSpinner.prototype, "clrSmall", null);
        __decorate([
            core.HostBinding('class.spinner-md')
        ], ClrSpinner.prototype, "mediumClass", null);
        __decorate([
            core.Input('clrMedium')
        ], ClrSpinner.prototype, "clrMedium", null);
        __decorate([
            core.Input('clrAssertive')
        ], ClrSpinner.prototype, "assertive", void 0);
        __decorate([
            core.Input('clrOff')
        ], ClrSpinner.prototype, "off", void 0);
ClrSpinner.ɵfac = function ClrSpinner_Factory(t) { return new (t || ClrSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService)); };
ClrSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrSpinner, selectors: [["clr-spinner"]], hostVars: 11, hostBindings: function ClrSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-busy", true);
        ɵngcc0.ɵɵclassProp("spinner", ctx.spinnerClass)("spinner-inline", ctx.inlineClass)("spinner-inverse", ctx.inverseClass)("spinner-sm", ctx.smallClass)("spinner-md", ctx.mediumClass);
    } }, inputs: { clrInline: "clrInline", clrInverse: "clrInverse", clrSmall: "clrSmall", clrMedium: "clrMedium", assertive: ["clrAssertive", "assertive"], off: ["clrOff", "off"] }, features: [ɵngcc0.ɵɵProvidersFeature([ClrAriaLiveService])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSpinner, [{
        type: core.Component,
        args: [{
                selector: 'clr-spinner',
                providers: [ClrAriaLiveService],
                template: "\n    <ng-content></ng-content>\n  ",
                host: {
                    '[attr.aria-busy]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ClrAriaLiveService }]; }, { spinnerClass: [{
            type: core.HostBinding,
            args: ['class.spinner']
        }], inlineClass: [{
            type: core.HostBinding,
            args: ['class.spinner-inline']
        }], clrInline: [{
            type: core.Input,
            args: ['clrInline']
        }], inverseClass: [{
            type: core.HostBinding,
            args: ['class.spinner-inverse']
        }], clrInverse: [{
            type: core.Input,
            args: ['clrInverse']
        }], smallClass: [{
            type: core.HostBinding,
            args: ['class.spinner-sm']
        }], clrSmall: [{
            type: core.Input,
            args: ['clrSmall']
        }], mediumClass: [{
            type: core.HostBinding,
            args: ['class.spinner-md']
        }], clrMedium: [{
            type: core.Input,
            args: ['clrMedium']
        }], assertive: [{
            type: core.Input,
            args: ['clrAssertive']
        }], off: [{
            type: core.Input,
            args: ['clrOff']
        }] }); })();
        return ClrSpinner;
    }());

    var CLR_SPINNER_DIRECTIVES = [ClrSpinner];
    var ClrSpinnerModule = /** @class */ (function () {
        function ClrSpinnerModule() {
        }
ClrSpinnerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrSpinnerModule });
ClrSpinnerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrSpinnerModule_Factory(t) { return new (t || ClrSpinnerModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrSpinnerModule, { declarations: [ClrSpinner], imports: [ɵngcc1.CommonModule], exports: [ClrSpinner] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSpinnerModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [CLR_SPINNER_DIRECTIVES],
                exports: [CLR_SPINNER_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrSpinnerModule;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var FOCUS_ON_VIEW_INIT = new core.InjectionToken('FOCUS_ON_VIEW_INIT');
    // This provider holds the default value for clrFocusOnViewInit directive's isEnabled property.
    // So users can interject this provider and set their own value for this provider.
    var FOCUS_ON_VIEW_INIT_PROVIDER = {
        provide: FOCUS_ON_VIEW_INIT,
        useValue: true,
    };

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /*  This directive is for guiding the document focus to the newly added content when its view is initialized
        so that assistive technologies can read its content. */
    var ClrFocusOnViewInit = /** @class */ (function () {
        function ClrFocusOnViewInit(el, platformId, focusOnViewInit, document, renderer) {
            this.el = el;
            this.platformId = platformId;
            this.focusOnViewInit = focusOnViewInit;
            this.renderer = renderer;
            this.directFocus = true; // true if the element gets focused without need to set tabindex;
            this._isEnabled = this.focusOnViewInit;
            // Angular compiler doesn't understand the type Document
            // when working out the metadata for injectable parameters,
            // even though it understands the injection token DOCUMENT
            // https://github.com/angular/angular/issues/20351
            this.document = document;
        }
        ClrFocusOnViewInit.prototype.onFocusout = function () {
            if (!this.directFocus) {
                // manually set attributes and styles should be removed
                this.renderer.removeAttribute(this.el.nativeElement, 'tabindex');
                this.renderer.setStyle(this.el.nativeElement, 'outline', null);
            }
        };
        Object.defineProperty(ClrFocusOnViewInit.prototype, "isEnabled", {
            set: function (value) {
                if (this.focusOnViewInit && typeof value === 'boolean') {
                    this._isEnabled = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrFocusOnViewInit.prototype.ngAfterViewInit = function () {
            this.focus();
        };
        ClrFocusOnViewInit.prototype.focus = function () {
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            if (!this._isEnabled) {
                return;
            }
            if (this.document && this.document.activeElement !== this.el.nativeElement) {
                this.el.nativeElement.focus();
                if (this.document.activeElement !== this.el.nativeElement) {
                    // if it's not directly focused now, it means it was a non-interactive element
                    // so we need to give it a tabindex.
                    this.directFocus = false;
                    this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '-1');
                    this.renderer.setStyle(this.el.nativeElement, 'outline', 'none');
                    this.el.nativeElement.focus();
                }
            }
        };
        ClrFocusOnViewInit.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: Boolean, decorators: [{ type: core.Inject, args: [FOCUS_ON_VIEW_INIT,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.HostListener('focusout')
        ], ClrFocusOnViewInit.prototype, "onFocusout", null);
        __decorate([
            core.Input('clrFocusOnViewInit')
        ], ClrFocusOnViewInit.prototype, "isEnabled", null);
        ClrFocusOnViewInit = __decorate([ __param(1, core.Inject(core.PLATFORM_ID)),
            __param(2, core.Inject(FOCUS_ON_VIEW_INIT)),
            __param(3, core.Inject(common.DOCUMENT))
        ], ClrFocusOnViewInit);
ClrFocusOnViewInit.ɵfac = function ClrFocusOnViewInit_Factory(t) { return new (t || ClrFocusOnViewInit)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(FOCUS_ON_VIEW_INIT), ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ClrFocusOnViewInit.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrFocusOnViewInit, selectors: [["", "clrFocusOnViewInit", ""]], hostBindings: function ClrFocusOnViewInit_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusout", function ClrFocusOnViewInit_focusout_HostBindingHandler() { return ctx.onFocusout(); });
    } }, inputs: { isEnabled: ["clrFocusOnViewInit", "isEnabled"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrFocusOnViewInit, [{
        type: core.Directive,
        args: [{
                selector: '[clrFocusOnViewInit]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: Boolean, decorators: [{
                type: core.Inject,
                args: [FOCUS_ON_VIEW_INIT]
            }] }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }, { type: ɵngcc0.Renderer2 }]; }, { onFocusout: [{
            type: core.HostListener,
            args: ['focusout']
        }], isEnabled: [{
            type: core.Input,
            args: ['clrFocusOnViewInit']
        }] }); })();
        return ClrFocusOnViewInit;
    }());

    var FOCUS_ON_VIEW_INIT_DIRECTIVES = [ClrFocusOnViewInit];
    var ClrFocusOnViewInitModule = /** @class */ (function () {
        function ClrFocusOnViewInitModule() {
        }
ClrFocusOnViewInitModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrFocusOnViewInitModule });
ClrFocusOnViewInitModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrFocusOnViewInitModule_Factory(t) { return new (t || ClrFocusOnViewInitModule)(); }, providers: [FOCUS_ON_VIEW_INIT_PROVIDER], imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrFocusOnViewInitModule, { declarations: [ClrFocusOnViewInit], imports: [ɵngcc1.CommonModule], exports: [ClrFocusOnViewInit] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrFocusOnViewInitModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [FOCUS_ON_VIEW_INIT_DIRECTIVES],
                providers: [FOCUS_ON_VIEW_INIT_PROVIDER],
                exports: [FOCUS_ON_VIEW_INIT_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrFocusOnViewInitModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CustomFilter = /** @class */ (function () {
        function CustomFilter() {
        }
        return CustomFilter;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /*
     * This provider implements some form of synchronous debouncing through a lock pattern
     * to avoid emitting multiple state changes for a single user action.
     */
    var StateDebouncer = /** @class */ (function () {
        function StateDebouncer() {
            /**
             * The Observable that lets other classes subscribe to global state changes
             */
            this._change = new rxjs.Subject();
            /*
               * This is the lock, to only emit once all the changes have finished processing
               */
            this.nbChanges = 0;
        }
        Object.defineProperty(StateDebouncer.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        StateDebouncer.prototype.changeStart = function () {
            this.nbChanges++;
        };
        StateDebouncer.prototype.changeDone = function () {
            if (--this.nbChanges === 0) {
                this._change.next();
            }
        };
StateDebouncer.ɵfac = function StateDebouncer_Factory(t) { return new (t || StateDebouncer)(); };
StateDebouncer.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: StateDebouncer, factory: function (t) { return StateDebouncer.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StateDebouncer, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return StateDebouncer;
    }());

    var Page = /** @class */ (function () {
        function Page(stateDebouncer) {
            this.stateDebouncer = stateDebouncer;
            this.preventEmit = false;
            this.activated = false;
            /**
             * Page size, a value of 0 means no pagination
             */
            this._size = 0;
            /**
             * The Observable that lets other classes subscribe to page changes
             */
            this._change = new rxjs.Subject();
            this._sizeChange = new rxjs.Subject();
            /**
             * Current page
             */
            this._current = 1;
        }
        Object.defineProperty(Page.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                var oldSize = this._size;
                if (size !== oldSize) {
                    if (!this.preventEmit) {
                        this.stateDebouncer.changeStart();
                    }
                    this._size = size;
                    if (size === 0) {
                        this._current = 1;
                    }
                    else {
                        // Yeap. That's the formula to keep the first item from the old page still
                        // displayed in the new one.
                        this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
                    }
                    // We always emit an event even if the current page index didn't change, because
                    // the size changing means the items inside the page are different
                    if (!this.preventEmit) {
                        this._change.next(this._current);
                        this._sizeChange.next(this._size);
                        this.stateDebouncer.changeDone();
                    }
                }
                this.preventEmit = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "totalItems", {
            get: function () {
                return this._totalItems || 0; // remains 0 if not set to avoid breaking change
            },
            set: function (total) {
                this._totalItems = total;
                // If we have less items than before, we might need to change the current page
                if (this.current > this.last) {
                    this.current = this.last;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "last", {
            get: function () {
                if (this._last) {
                    return this._last;
                }
                // If the last page isn't known, we compute it from the last item's index
                if (this.size > 0 && this.totalItems) {
                    return Math.ceil(this.totalItems / this.size);
                }
                return 1;
            },
            set: function (page) {
                this._last = page;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "sizeChange", {
            get: function () {
                return this._sizeChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "current", {
            get: function () {
                return this._current;
            },
            set: function (page) {
                if (page !== this._current) {
                    this.stateDebouncer.changeStart();
                    this._current = page;
                    this._change.next(page);
                    this.stateDebouncer.changeDone();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Moves to the previous page if it exists
         */
        Page.prototype.previous = function () {
            if (this.current > 1) {
                this.current--;
            }
        };
        /**
         * Moves to the next page if it exists
         */
        Page.prototype.next = function () {
            if (this.current < this.last) {
                this.current++;
            }
        };
        Object.defineProperty(Page.prototype, "firstItem", {
            /**
             * Index of the first item displayed on the current page, starting at 0, -1 if none displayed
             */
            get: function () {
                if (this._totalItems === 0) {
                    return -1;
                }
                if (this.size === 0) {
                    return 0;
                }
                return (this.current - 1) * this.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "lastItem", {
            /**
             * Index of the last item displayed on the current page, starting at 0, -1 if none displayed
             */
            get: function () {
                if (this._totalItems === 0) {
                    return -1;
                }
                if (this.size === 0) {
                    return this.totalItems - 1;
                }
                var lastInPage = this.current * this.size - 1;
                if (this.totalItems) {
                    lastInPage = Math.min(lastInPage, this.totalItems - 1);
                }
                return lastInPage;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Resets the page size to 0
         */
        Page.prototype.resetPageSize = function (preventEmit) {
            if (preventEmit === void 0) { preventEmit = false; }
            this.preventEmit = preventEmit;
            this.size = 0;
        };
        Page.ctorParameters = function () { return [
            { type: StateDebouncer }
        ]; };
Page.ɵfac = function Page_Factory(t) { return new (t || Page)(ɵngcc0.ɵɵinject(StateDebouncer)); };
Page.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Page, factory: function (t) { return Page.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Page, [{
        type: core.Injectable
    }], function () { return [{ type: StateDebouncer }]; }, null); })();
        return Page;
    }());

    var FiltersProvider = /** @class */ (function () {
        function FiltersProvider(_page, stateDebouncer) {
            this._page = _page;
            this.stateDebouncer = stateDebouncer;
            /**
             * This subject is the list of filters that changed last, not the whole list.
             * We emit a list rather than just one filter to allow batch changes to several at once.
             */
            this._change = new rxjs.Subject();
            /**
             * List of all filters, whether they're active or not
             */
            this._all = [];
        }
        Object.defineProperty(FiltersProvider.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Tests if at least one filter is currently active
         */
        FiltersProvider.prototype.hasActiveFilters = function () {
            var e_1, _a;
            try {
                // We do not use getActiveFilters() because this function will be called much more often
                // and stopping the loop early might be relevant.
                for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var filter = _c.value.filter;
                    if (filter && filter.isActive()) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        /**
         * Returns a list of all currently active filters
         */
        FiltersProvider.prototype.getActiveFilters = function () {
            var e_2, _a;
            var ret = [];
            try {
                for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var filter = _c.value.filter;
                    if (filter && filter.isActive()) {
                        ret.push(filter);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return ret;
        };
        /**
         * Registers a filter, and returns a deregistration function
         */
        FiltersProvider.prototype.add = function (filter) {
            var _this = this;
            var subscription = filter.changes.subscribe(function () { return _this.resetPageAndEmitFilterChange([filter]); });
            var hasUnregistered = false;
            var registered = new RegisteredFilter(filter, function () {
                if (hasUnregistered) {
                    return;
                }
                subscription.unsubscribe();
                var matchIndex = _this._all.findIndex(function (item) { return item.filter === filter; });
                if (matchIndex >= 0) {
                    _this._all.splice(matchIndex, 1);
                }
                if (filter.isActive()) {
                    _this.resetPageAndEmitFilterChange([]);
                }
                hasUnregistered = true;
            });
            this._all.push(registered);
            if (filter.isActive()) {
                this.resetPageAndEmitFilterChange([filter]);
            }
            return registered;
        };
        /**
         * Accepts an item if it is accepted by all currently active filters
         */
        FiltersProvider.prototype.accepts = function (item) {
            var e_3, _a;
            try {
                for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var filter = _c.value.filter;
                    if (filter && filter.isActive() && !filter.accepts(item)) {
                        return false;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return true;
        };
        FiltersProvider.prototype.resetPageAndEmitFilterChange = function (filters) {
            this.stateDebouncer.changeStart();
            // filtering may change the page number such that current page number doesn't exist in the filtered dataset.
            // So here we always set the current page to 1 so that it'll fetch first page's data with the given filter.
            this._page.current = 1;
            this._change.next(filters);
            this.stateDebouncer.changeDone();
        };
        FiltersProvider.ctorParameters = function () { return [
            { type: Page },
            { type: StateDebouncer }
        ]; };
FiltersProvider.ɵfac = function FiltersProvider_Factory(t) { return new (t || FiltersProvider)(ɵngcc0.ɵɵinject(Page), ɵngcc0.ɵɵinject(StateDebouncer)); };
FiltersProvider.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FiltersProvider, factory: function (t) { return FiltersProvider.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FiltersProvider, [{
        type: core.Injectable
    }], function () { return [{ type: Page }, { type: StateDebouncer }]; }, null); })();
        return FiltersProvider;
    }());
    var RegisteredFilter = /** @class */ (function () {
        function RegisteredFilter(filter, unregister) {
            this.filter = filter;
            this.unregister = unregister;
        }
        return RegisteredFilter;
    }());

    var DatagridFilterRegistrar = /** @class */ (function () {
        function DatagridFilterRegistrar(filters) {
            this.filters = filters;
        }
        Object.defineProperty(DatagridFilterRegistrar.prototype, "filter", {
            get: function () {
                return this.registered && this.registered.filter;
            },
            enumerable: true,
            configurable: true
        });
        DatagridFilterRegistrar.prototype.setFilter = function (filter) {
            // If we previously had another filter, we unregister it
            this.deleteFilter();
            if (filter instanceof RegisteredFilter) {
                this.registered = filter;
            }
            else if (filter) {
                this.registered = this.filters.add(filter);
            }
        };
        DatagridFilterRegistrar.prototype.deleteFilter = function () {
            if (this.registered) {
                this.registered.unregister();
                delete this.registered;
            }
        };
        DatagridFilterRegistrar.prototype.ngOnDestroy = function () {
            this.deleteFilter();
        };
DatagridFilterRegistrar.ɵfac = function DatagridFilterRegistrar_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
DatagridFilterRegistrar.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridFilterRegistrar });

        return DatagridFilterRegistrar;
    }());

    /**
     * Custom filter that can be added in any column to override the default object property string filter.
     * The reason this is not just an input on DatagridColumn is because we need the filter's template to be projected,
     * since it can be anything (not just a text input).
     */
    var ClrDatagridFilter = /** @class */ (function (_super) {
        __extends(ClrDatagridFilter, _super);
        function ClrDatagridFilter(_filters, commonStrings, smartToggleService, platformId, popoverId) {
            var _this = _super.call(this, _filters) || this;
            _this.commonStrings = commonStrings;
            _this.smartToggleService = smartToggleService;
            _this.platformId = platformId;
            _this.popoverId = popoverId;
            _this.subs = [];
            _this.ariaExpanded = false;
            // Smart Popover
            _this.smartPosition = {
                axis: exports.ClrAxis.VERTICAL,
                side: exports.ClrSide.AFTER,
                anchor: exports.ClrAlignment.END,
                content: exports.ClrAlignment.END,
            };
            _this._open = false;
            _this.openChange = new core.EventEmitter(false);
            _this.subs.push(smartToggleService.openChange.subscribe(function (change) {
                _this.open = change;
                _this.ariaExpanded = change;
            }));
            return _this;
        }
        ClrDatagridFilter_1 = ClrDatagridFilter;
        Object.defineProperty(ClrDatagridFilter.prototype, "open", {
            get: function () {
                return this._open;
            },
            set: function (open) {
                open = !!open;
                if (this.open !== open) {
                    this.smartToggleService.open = open;
                    this.openChange.emit(open);
                    if (!open && common.isPlatformBrowser(this.platformId)) {
                        this.anchor.nativeElement.focus();
                    }
                    // keep track of the state
                    this._open = open;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridFilter.prototype, "customFilter", {
            set: function (filter) {
                this.setFilter(filter);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridFilter.prototype, "active", {
            /**
             * Indicates if the filter is currently active
             */
            get: function () {
                return !!this.filter && this.filter.isActive();
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridFilter.prototype.ngOnDestroy = function () {
            _super.prototype.ngOnDestroy.call(this);
            this.subs.forEach(function (sub) { return sub.unsubscribe(); });
        };
        var ClrDatagridFilter_1;
        ClrDatagridFilter.ctorParameters = function () { return [
            { type: FiltersProvider },
            { type: ClrCommonStringsService },
            { type: ClrPopoverToggleService },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        __decorate([
            core.ViewChild('anchor', { read: core.ElementRef })
        ], ClrDatagridFilter.prototype, "anchor", void 0);
        __decorate([
            core.Input('clrDgFilterOpen')
        ], ClrDatagridFilter.prototype, "open", null);
        __decorate([
            core.Output('clrDgFilterOpenChange')
        ], ClrDatagridFilter.prototype, "openChange", void 0);
        __decorate([
            core.Input('clrDgFilter')
        ], ClrDatagridFilter.prototype, "customFilter", null);
        ClrDatagridFilter = ClrDatagridFilter_1 = __decorate([ __param(3, core.Inject(core.PLATFORM_ID)),
            __param(4, core.Inject(UNIQUE_ID))
        ], ClrDatagridFilter);
ClrDatagridFilter.ɵfac = function ClrDatagridFilter_Factory(t) { return new (t || ClrDatagridFilter)(ɵngcc0.ɵɵdirectiveInject(FiltersProvider), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrDatagridFilter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridFilter, selectors: [["clr-dg-filter"]], viewQuery: function ClrDatagridFilter_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c28, true, core.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.anchor = _t.first);
    } }, inputs: { open: ["clrDgFilterOpen", "open"], customFilter: ["clrDgFilter", "customFilter"] }, outputs: { openChange: "clrDgFilterOpenChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CustomFilter, useExisting: ClrDatagridFilter_1 }, UNIQUE_ID_PROVIDER]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 12, consts: [["type", "button", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "datagrid-filter-toggle"], ["anchor", ""], [1, "is-solid"], ["class", "datagrid-filter", "clrFocusTrap", "", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["clrFocusTrap", "", 1, "datagrid-filter", 3, "id"], [1, "datagrid-filter-close-wrapper"], ["type", "button", "clrPopoverCloseButton", "", 1, "close"], ["shape", "close"]], template: function ClrDatagridFilter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵelement(2, "clr-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ClrDatagridFilter_div_3_Template, 5, 2, "div", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-filter-open", ctx.open)("datagrid-filtered", ctx.active);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.datagridFilterAriaLabel)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.popoverId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("shape", ctx.active ? "filter-grid-circle" : "filter-grid");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    } }, directives: [ClrPopoverAnchor,
        ClrPopoverOpenCloseButton,
        ClrIconCustomTag,
        ClrPopoverContent,
        FocusTrapDirective,
        ClrPopoverCloseButton], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridFilter, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-filter',
                // We register this component as a CustomFilter, for the parent column to detect it.
                providers: [{ provide: CustomFilter, useExisting: ClrDatagridFilter_1 }, UNIQUE_ID_PROVIDER],
                template: "\n      <button class=\"datagrid-filter-toggle\"\n              type=\"button\"\n              #anchor\n              [attr.aria-label]=\"commonStrings.keys.datagridFilterAriaLabel\"\n              [attr.aria-expanded]=\"ariaExpanded\"\n              [attr.aria-controls]=\"popoverId\"\n              clrPopoverAnchor\n              clrPopoverOpenCloseButton\n              [class.datagrid-filter-open]=\"open\"\n              [class.datagrid-filtered]=\"active\">\n          <clr-icon [attr.shape]=\"active ? 'filter-grid-circle': 'filter-grid'\" class=\"is-solid\"></clr-icon>\n      </button>\n\n      <div class=\"datagrid-filter\"\n           [id]=\"popoverId\"\n           clrFocusTrap\n           *clrPopoverContent=\"open at smartPosition; outsideClickToClose: true; scrollToClose: true\">\n          <div class=\"datagrid-filter-close-wrapper\">\n              <button type=\"button\" class=\"close\" clrPopoverCloseButton>\n                  <clr-icon shape=\"close\" [attr.title]=\"commonStrings.keys.close\"></clr-icon>\n              </button>\n          </div>\n\n          <ng-content></ng-content>\n      </div>\n  "
            }]
    }], function () { return [{ type: FiltersProvider }, { type: ClrCommonStringsService }, { type: ClrPopoverToggleService }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, { open: [{
            type: core.Input,
            args: ['clrDgFilterOpen']
        }], customFilter: [{
            type: core.Input,
            args: ['clrDgFilter']
        }], anchor: [{
            type: core.ViewChild,
            args: ['anchor', { read: core.ElementRef }]
        }], openChange: [{
            type: core.Output,
            args: ['clrDgFilterOpenChange']
        }] }); })();
        return ClrDatagridFilter;
    }(DatagridFilterRegistrar));

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Generic accessor for deep object properties
     * that can be specified as simple dot-separated strings.
     */
    var NestedProperty = /** @class */ (function () {
        function NestedProperty(prop) {
            this.prop = prop;
            if (prop.indexOf('.') >= 0) {
                this.splitProp = prop.split('.');
            }
        }
        // Safe getter for a deep object property, will not throw an error but return
        // undefined if one of the intermediate properties is null or undefined.
        NestedProperty.prototype.getPropValue = function (item) {
            var e_1, _a;
            if (this.splitProp) {
                var value = item;
                try {
                    for (var _b = __values(this.splitProp), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var nestedProp = _c.value;
                        if (value == null || typeof value === 'undefined' || typeof value[nestedProp] === 'undefined') {
                            return undefined;
                        }
                        value = value[nestedProp];
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return value;
            }
            else {
                return item[this.prop];
            }
        };
        return NestedProperty;
    }());

    var DatagridPropertyStringFilter = /** @class */ (function () {
        function DatagridPropertyStringFilter(prop, exact) {
            if (exact === void 0) { exact = false; }
            this.prop = prop;
            this.exact = exact;
            this.nestedProp = new NestedProperty(prop);
        }
        DatagridPropertyStringFilter.prototype.accepts = function (item, search) {
            var propValue = this.nestedProp.getPropValue(item);
            if (typeof propValue === 'undefined') {
                return false;
            }
            else if (this.exact) {
                return ('' + propValue).toLowerCase() === search;
            }
            else {
                return ('' + propValue).toLowerCase().indexOf(search) >= 0;
            }
        };
        return DatagridPropertyStringFilter;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatagridStringFilterImpl = /** @class */ (function () {
        function DatagridStringFilterImpl(filterFn) {
            this.filterFn = filterFn;
            /**
             * The Observable required as part of the Filter interface
             */
            this._changes = new rxjs.Subject();
            /**
             * Raw input value
             */
            this._rawValue = '';
            /**
             * Input value converted to lowercase
             */
            this._lowerCaseValue = '';
        }
        Object.defineProperty(DatagridStringFilterImpl.prototype, "changes", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridStringFilterImpl.prototype, "value", {
            get: function () {
                return this._rawValue;
            },
            /**
             * Common setter for the input value
             */
            set: function (value) {
                if (!value) {
                    value = '';
                }
                if (value !== this._rawValue) {
                    this._rawValue = value;
                    this._lowerCaseValue = value.toLowerCase().trim();
                    this._changes.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridStringFilterImpl.prototype, "lowerCaseValue", {
            get: function () {
                return this._lowerCaseValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if the filter is currently active, meaning the input is not empty
         */
        DatagridStringFilterImpl.prototype.isActive = function () {
            return !!this.value;
        };
        /**
         * Tests if an item matches a search text
         */
        DatagridStringFilterImpl.prototype.accepts = function (item) {
            // We always test with the lowercase value of the input, to stay case insensitive
            return this.filterFn.accepts(item, this.lowerCaseValue);
        };
        Object.defineProperty(DatagridStringFilterImpl.prototype, "state", {
            get: function () {
                if (this.filterFn instanceof DatagridPropertyStringFilter) {
                    return {
                        property: this.filterFn.prop,
                        value: this.value,
                    };
                }
                return this;
            },
            enumerable: true,
            configurable: true
        });
        DatagridStringFilterImpl.prototype.equals = function (other) {
            if (other instanceof DatagridStringFilterImpl) {
                if (other.filterFn instanceof DatagridPropertyStringFilter) {
                    return (this.filterFn instanceof DatagridPropertyStringFilter &&
                        other.filterFn.prop === this.filterFn.prop &&
                        other.value === this.value);
                }
                return other === this;
            }
            return false;
        };
        return DatagridStringFilterImpl;
    }());

    var DatagridStringFilter = /** @class */ (function (_super) {
        __extends(DatagridStringFilter, _super);
        function DatagridStringFilter(filters, domAdapter, smartToggleService) {
            var _this = _super.call(this, filters) || this;
            _this.domAdapter = domAdapter;
            _this.smartToggleService = smartToggleService;
            _this.subs = [];
            /**
             * Indicates if the filter dropdown is open
             */
            _this.open = false;
            _this.filterValueChange = new core.EventEmitter();
            return _this;
        }
        DatagridStringFilter_1 = DatagridStringFilter;
        Object.defineProperty(DatagridStringFilter.prototype, "customStringFilter", {
            /**
             * Customizable filter logic based on a search text
             */
            set: function (value) {
                if (value instanceof RegisteredFilter) {
                    this.setFilter(value);
                }
                else {
                    this.setFilter(new DatagridStringFilterImpl(value));
                }
                if (this.initFilterValue) {
                    this.value = this.initFilterValue;
                    // This initFilterValue should be used only once after the filter registration
                    // So deleting this property value to prevent it from being used again
                    // if this customStringFilter property is set again
                    delete this.initFilterValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        DatagridStringFilter.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.subs.push(this.smartToggleService.openChange.subscribe(function (openChange) {
                _this.open = openChange;
                // The timeout in used because when this executes, the input isn't displayed.
                setTimeout(function () {
                    _this.domAdapter.focus(_this.input.nativeElement);
                });
            }));
        };
        DatagridStringFilter.prototype.ngOnDestroy = function () {
            _super.prototype.ngOnDestroy.call(this);
            this.subs.forEach(function (sub) { return sub.unsubscribe(); });
        };
        Object.defineProperty(DatagridStringFilter.prototype, "value", {
            /**
             * Common setter for the input value
             */
            get: function () {
                return this.filter.value;
            },
            set: function (value) {
                if (this.filter) {
                    if (!value) {
                        value = '';
                    }
                    if (value !== this.filter.value) {
                        this.filter.value = value;
                        this.filterValueChange.emit(value);
                    }
                }
                else {
                    this.initFilterValue = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        var DatagridStringFilter_1;
        DatagridStringFilter.ctorParameters = function () { return [
            { type: FiltersProvider },
            { type: DomAdapter },
            { type: ClrPopoverToggleService }
        ]; };
        __decorate([
            core.Input('clrDgStringFilter')
        ], DatagridStringFilter.prototype, "customStringFilter", null);
        __decorate([
            core.ViewChild('input')
        ], DatagridStringFilter.prototype, "input", void 0);
        __decorate([
            core.ViewChild(ClrDatagridFilter)
        ], DatagridStringFilter.prototype, "filterContainer", void 0);
        __decorate([
            core.Input('clrFilterValue')
        ], DatagridStringFilter.prototype, "value", null);
        __decorate([
            core.Output('clrFilterValueChange')
        ], DatagridStringFilter.prototype, "filterValueChange", void 0);
DatagridStringFilter.ɵfac = function DatagridStringFilter_Factory(t) { return new (t || DatagridStringFilter)(ɵngcc0.ɵɵdirectiveInject(FiltersProvider), ɵngcc0.ɵɵdirectiveInject(DomAdapter), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService)); };
DatagridStringFilter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DatagridStringFilter, selectors: [["clr-dg-string-filter"]], viewQuery: function DatagridStringFilter_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c29, true);
        ɵngcc0.ɵɵviewQuery(ClrDatagridFilter, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterContainer = _t.first);
    } }, inputs: { customStringFilter: ["clrDgStringFilter", "customStringFilter"], value: ["clrFilterValue", "value"] }, outputs: { filterValueChange: "clrFilterValueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CustomFilter, useExisting: DatagridStringFilter_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 3, consts: [[3, "clrDgFilter", "clrDgFilterOpen", "clrDgFilterOpenChange"], ["type", "text", "name", "search", 1, "clr-input", 3, "ngModel", "ngModelChange"], ["input", ""]], template: function DatagridStringFilter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "clr-dg-filter", 0);
        ɵngcc0.ɵɵlistener("clrDgFilterOpenChange", function DatagridStringFilter_Template_clr_dg_filter_clrDgFilterOpenChange_0_listener($event) { return ctx.open = $event; });
        ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function DatagridStringFilter_Template_input_ngModelChange_1_listener($event) { return ctx.value = $event; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("clrDgFilter", ctx.registered)("clrDgFilterOpen", ctx.open);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngModel", ctx.value);
    } }, directives: [ClrDatagridFilter, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridStringFilter, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-string-filter',
                providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter_1 }],
                template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" class=\"clr-input\" />\n        </clr-dg-filter>\n    "
            }]
    }], function () { return [{ type: FiltersProvider }, { type: DomAdapter }, { type: ClrPopoverToggleService }]; }, { customStringFilter: [{
            type: core.Input,
            args: ['clrDgStringFilter']
        }], value: [{
            type: core.Input,
            args: ['clrFilterValue']
        }], input: [{
            type: core.ViewChild,
            args: ['input']
        }], filterContainer: [{
            type: core.ViewChild,
            args: [ClrDatagridFilter]
        }], filterValueChange: [{
            type: core.Output,
            args: ['clrFilterValueChange']
        }] }); })();
        return DatagridStringFilter;
    }(DatagridFilterRegistrar));

    var DatagridPropertyNumericFilter = /** @class */ (function () {
        function DatagridPropertyNumericFilter(prop, exact) {
            if (exact === void 0) { exact = false; }
            this.prop = prop;
            this.exact = exact;
            this.nestedProp = new NestedProperty(prop);
        }
        DatagridPropertyNumericFilter.prototype.accepts = function (item, low, high) {
            var propValue = this.nestedProp.getPropValue(item);
            if (low !== null && propValue < low) {
                return false;
            }
            if (high !== null && propValue > high) {
                return false;
            }
            return true;
        };
        return DatagridPropertyNumericFilter;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatagridNumericFilterImpl = /** @class */ (function () {
        function DatagridNumericFilterImpl(filterFn) {
            this.filterFn = filterFn;
            /**
             * The Observable required as part of the Filter interface
             */
            this._changes = new rxjs.Subject();
            /**
             * Internal values and accessor
             */
            this._low = null;
            this._high = null;
        }
        Object.defineProperty(DatagridNumericFilterImpl.prototype, "changes", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridNumericFilterImpl.prototype, "value", {
            /**
             * Common setters for the input values, including individual limits and
             * both at the same time.  Value is singular to make the interface similar
             * to the built-in string filter.
             */
            get: function () {
                return [this._low, this._high];
            },
            set: function (vals) {
                var low = vals[0];
                var high = vals[1];
                if (low !== this._low || high !== this._high) {
                    this._low = low;
                    this._high = high;
                    this._changes.next([this._low, this._high]);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridNumericFilterImpl.prototype, "low", {
            get: function () {
                return this._low;
            },
            set: function (low) {
                if (low !== this._low) {
                    this._low = low;
                    this._changes.next([this._low, this._high]);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridNumericFilterImpl.prototype, "high", {
            get: function () {
                return this._high;
            },
            set: function (high) {
                if (high !== this._high) {
                    this._high = high;
                    this._changes.next([this._low, this._high]);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if the filter is currently active, (at least one input is set)
         */
        DatagridNumericFilterImpl.prototype.isActive = function () {
            return this._low !== null || this.high !== null;
        };
        /**
         * Tests if an item matches a search text
         */
        DatagridNumericFilterImpl.prototype.accepts = function (item) {
            // We have a filter function in case someone wants to implement a numeric
            // filter that always passes nulls or similar
            return this.filterFn.accepts(item, this._low, this._high);
        };
        Object.defineProperty(DatagridNumericFilterImpl.prototype, "state", {
            get: function () {
                if (this.filterFn instanceof DatagridPropertyNumericFilter) {
                    return {
                        property: this.filterFn.prop,
                        low: this._low,
                        high: this._high,
                    };
                }
                return this;
            },
            enumerable: true,
            configurable: true
        });
        DatagridNumericFilterImpl.prototype.equals = function (other) {
            if (other instanceof DatagridNumericFilterImpl) {
                if (other.filterFn instanceof DatagridPropertyNumericFilter) {
                    return (this.filterFn instanceof DatagridPropertyNumericFilter &&
                        other.filterFn.prop === this.filterFn.prop &&
                        other.low === this._low &&
                        other.high === this._high);
                }
                return other === this;
            }
            return false;
        };
        return DatagridNumericFilterImpl;
    }());

    var DatagridNumericFilter = /** @class */ (function (_super) {
        __extends(DatagridNumericFilter, _super);
        function DatagridNumericFilter(filters, domAdapter, commonStrings, popoverToggleService) {
            var _this = _super.call(this, filters) || this;
            _this.domAdapter = domAdapter;
            _this.commonStrings = commonStrings;
            _this.popoverToggleService = popoverToggleService;
            _this.subscriptions = [];
            /**
             * Indicates if the filter dropdown is open
             */
            _this.open = false;
            _this.filterValueChange = new core.EventEmitter();
            return _this;
        }
        DatagridNumericFilter_1 = DatagridNumericFilter;
        DatagridNumericFilter.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) {
                sub.unsubscribe();
            });
        };
        Object.defineProperty(DatagridNumericFilter.prototype, "customNumericFilter", {
            /**
             * Customizable filter logic based on high and low values
             */
            set: function (value) {
                if (value instanceof RegisteredFilter) {
                    this.setFilter(value);
                }
                else {
                    this.setFilter(new DatagridNumericFilterImpl(value));
                }
                if (this.initFilterValues) {
                    this.value = this.initFilterValues;
                    // This initFilterValues should be used only once after the filter registration
                    // So deleting this property value to prevent it from being used again
                    // if this customStringFilter property is set again
                    delete this.initFilterValues;
                }
            },
            enumerable: true,
            configurable: true
        });
        DatagridNumericFilter.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.subscriptions.push(this.popoverToggleService.openChange.subscribe(function (openChange) {
                _this.open = openChange;
                // The timeout in used because when this executes, the input isn't displayed.
                setTimeout(function () {
                    _this.domAdapter.focus(_this.input.nativeElement);
                });
            }));
        };
        Object.defineProperty(DatagridNumericFilter.prototype, "value", {
            /**
             * Common setter for the input values
             */
            get: function () {
                return [this.filter.low, this.filter.high];
            },
            set: function (values) {
                if (this.filter) {
                    if (values && (values[0] !== this.filter.low || values[1] !== this.filter.high)) {
                        if (typeof values[0] === 'number') {
                            this.filter.low = values[0];
                        }
                        else {
                            this.filter.low = null;
                        }
                        if (typeof values[1] === 'number') {
                            this.filter.high = values[1];
                        }
                        else {
                            this.filter.high = null;
                        }
                        this.filterValueChange.emit(values);
                    }
                }
                else {
                    this.initFilterValues = values;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridNumericFilter.prototype, "low", {
            get: function () {
                if (typeof this.filter.low === 'number' && isFinite(this.filter.low)) {
                    return this.filter.low;
                }
                else {
                    // There's not a low limit
                    return null;
                }
            },
            set: function (low) {
                if (typeof low === 'number' && low !== this.filter.low) {
                    this.filter.low = low;
                    this.filterValueChange.emit([this.filter.low, this.filter.high]);
                }
                else if (typeof low !== 'number') {
                    this.filter.low = null;
                    this.filterValueChange.emit([this.filter.low, this.filter.high]);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridNumericFilter.prototype, "high", {
            get: function () {
                if (typeof this.filter.high === 'number' && isFinite(this.filter.high)) {
                    return this.filter.high;
                }
                else {
                    // There's not a high limit
                    return null;
                }
            },
            set: function (high) {
                if (typeof high === 'number' && high !== this.filter.high) {
                    this.filter.high = high;
                    this.filterValueChange.emit([this.filter.low, this.filter.high]);
                }
                else if (typeof high !== 'number') {
                    this.filter.high = null;
                    this.filterValueChange.emit([this.filter.low, this.filter.high]);
                }
            },
            enumerable: true,
            configurable: true
        });
        var DatagridNumericFilter_1;
        DatagridNumericFilter.ctorParameters = function () { return [
            { type: FiltersProvider },
            { type: DomAdapter },
            { type: ClrCommonStringsService },
            { type: ClrPopoverToggleService }
        ]; };
        __decorate([
            core.Input('clrDgNumericFilter')
        ], DatagridNumericFilter.prototype, "customNumericFilter", null);
        __decorate([
            core.ViewChild('input_low')
        ], DatagridNumericFilter.prototype, "input", void 0);
        __decorate([
            core.ViewChild(ClrDatagridFilter)
        ], DatagridNumericFilter.prototype, "filterContainer", void 0);
        __decorate([
            core.Input('clrFilterValue')
        ], DatagridNumericFilter.prototype, "value", null);
        __decorate([
            core.Output('clrFilterValueChange')
        ], DatagridNumericFilter.prototype, "filterValueChange", void 0);
DatagridNumericFilter.ɵfac = function DatagridNumericFilter_Factory(t) { return new (t || DatagridNumericFilter)(ɵngcc0.ɵɵdirectiveInject(FiltersProvider), ɵngcc0.ɵɵdirectiveInject(DomAdapter), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService)); };
DatagridNumericFilter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DatagridNumericFilter, selectors: [["clr-dg-numeric-filter"]], viewQuery: function DatagridNumericFilter_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c30, true);
        ɵngcc0.ɵɵviewQuery(ClrDatagridFilter, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterContainer = _t.first);
    } }, inputs: { customNumericFilter: ["clrDgNumericFilter", "customNumericFilter"], value: ["clrFilterValue", "value"] }, outputs: { filterValueChange: "clrFilterValueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CustomFilter, useExisting: DatagridNumericFilter_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 8, consts: [[3, "clrDgFilter", "clrDgFilterOpen", "clrDgFilterOpenChange"], ["type", "number", "name", "low", 1, "datagrid-numeric-filter-input", 3, "ngModel", "placeholder", "ngModelChange"], ["input_low", ""], [1, "datagrid-filter-input-spacer"], ["type", "number", "name", "high", 1, "datagrid-numeric-filter-input", 3, "ngModel", "placeholder", "ngModelChange"], ["input_high", ""]], template: function DatagridNumericFilter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "clr-dg-filter", 0);
        ɵngcc0.ɵɵlistener("clrDgFilterOpenChange", function DatagridNumericFilter_Template_clr_dg_filter_clrDgFilterOpenChange_0_listener($event) { return ctx.open = $event; });
        ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function DatagridNumericFilter_Template_input_ngModelChange_1_listener($event) { return ctx.low = $event; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "span", 3);
        ɵngcc0.ɵɵelementStart(4, "input", 4, 5);
        ɵngcc0.ɵɵlistener("ngModelChange", function DatagridNumericFilter_Template_input_ngModelChange_4_listener($event) { return ctx.high = $event; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("clrDgFilter", ctx.registered)("clrDgFilterOpen", ctx.open);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngModel", ctx.low)("placeholder", ctx.commonStrings.keys.minValue);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.minValue);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngModel", ctx.high)("placeholder", ctx.commonStrings.keys.maxValue);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.maxValue);
    } }, directives: [ClrDatagridFilter, ɵngcc2.NumberValueAccessor, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridNumericFilter, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-numeric-filter',
                providers: [{ provide: CustomFilter, useExisting: DatagridNumericFilter_1 }],
                template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <input class=\"datagrid-numeric-filter-input\" #input_low type=\"number\" name=\"low\" [(ngModel)]=\"low\"\n                   [placeholder]=\"commonStrings.keys.minValue\" [attr.aria-label]=\"commonStrings.keys.minValue\" />\n                <span class=\"datagrid-filter-input-spacer\"></span>\n            <input class=\"datagrid-numeric-filter-input\" #input_high type=\"number\" name=\"high\" [(ngModel)]=\"high\"\n                   [placeholder]=\"commonStrings.keys.maxValue\" [attr.aria-label]=\"commonStrings.keys.maxValue\" />\n        </clr-dg-filter>\n    "
            }]
    }], function () { return [{ type: FiltersProvider }, { type: DomAdapter }, { type: ClrCommonStringsService }, { type: ClrPopoverToggleService }]; }, { customNumericFilter: [{
            type: core.Input,
            args: ['clrDgNumericFilter']
        }], value: [{
            type: core.Input,
            args: ['clrFilterValue']
        }], input: [{
            type: core.ViewChild,
            args: ['input_low']
        }], filterContainer: [{
            type: core.ViewChild,
            args: [ClrDatagridFilter]
        }], filterValueChange: [{
            type: core.Output,
            args: ['clrFilterValueChange']
        }] }); })();
        return DatagridNumericFilter;
    }(DatagridFilterRegistrar));

    var OompaLoompa = /** @class */ (function () {
        // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
        function OompaLoompa(cdr, willyWonka) {
            var _this = this;
            this.subscription = willyWonka.chocolate.subscribe(function () {
                if (_this.latestFlavor !== _this.flavor) {
                    willyWonka.disableChocolateCheck = true;
                    cdr.detectChanges();
                    willyWonka.disableChocolateCheck = false;
                }
            });
        }
        OompaLoompa.prototype.ngAfterContentChecked = function () {
            this.latestFlavor = this.flavor;
        };
        OompaLoompa.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
OompaLoompa.ɵfac = function OompaLoompa_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
OompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: OompaLoompa });

        return OompaLoompa;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var RowActionService = /** @class */ (function () {
        function RowActionService() {
            this.actionableCount = 0;
        }
        RowActionService.prototype.register = function () {
            this.actionableCount++;
        };
        RowActionService.prototype.unregister = function () {
            this.actionableCount--;
        };
        Object.defineProperty(RowActionService.prototype, "hasActionableRow", {
            /**
             * false means no rows with action
             */
            get: function () {
                return this.actionableCount > 0;
            },
            enumerable: true,
            configurable: true
        });
RowActionService.ɵfac = function RowActionService_Factory(t) { return new (t || RowActionService)(); };
RowActionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RowActionService, factory: function (t) { return RowActionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RowActionService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return RowActionService;
    }());

    /*
     * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
     * declarative API, we need to fight against change detection and its one-way flow. This is
     * currently the least dirty solution to do what we want.
     *
     * Do not modify or even use this class unless you know exactly what you're doing.
     * It has the potential to trigger change detection loops or kill app performances.
     */
    var WillyWonka = /** @class */ (function () {
        function WillyWonka() {
            this._chocolate = new rxjs.Subject();
            this.disableChocolateCheck = false;
        }
        Object.defineProperty(WillyWonka.prototype, "chocolate", {
            get: function () {
                return this._chocolate.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        WillyWonka.prototype.ngAfterViewChecked = function () {
            if (!this.disableChocolateCheck) {
                this._chocolate.next();
            }
        };
WillyWonka.ɵfac = function WillyWonka_Factory(t) { return new (t || WillyWonka)(); };
WillyWonka.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: WillyWonka });

        return WillyWonka;
    }());

    var DatagridWillyWonka = /** @class */ (function (_super) {
        __extends(DatagridWillyWonka, _super);
        function DatagridWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
DatagridWillyWonka.ɵfac = function DatagridWillyWonka_Factory(t) { return ɵDatagridWillyWonka_BaseFactory(t || DatagridWillyWonka); };
DatagridWillyWonka.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridWillyWonka, selectors: [["clr-datagrid"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
var ɵDatagridWillyWonka_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(DatagridWillyWonka);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridWillyWonka, [{
        type: core.Directive,
        args: [{ selector: 'clr-datagrid' }]
    }], null, null); })();
        return DatagridWillyWonka;
    }(WillyWonka));

    var ActionableOompaLoompa = /** @class */ (function (_super) {
        __extends(ActionableOompaLoompa, _super);
        function ActionableOompaLoompa(cdr, willyWonka, rowActions) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.rowActions = rowActions;
            return _this;
        }
        Object.defineProperty(ActionableOompaLoompa.prototype, "flavor", {
            get: function () {
                return this.rowActions.hasActionableRow;
            },
            enumerable: true,
            configurable: true
        });
        ActionableOompaLoompa.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: DatagridWillyWonka, decorators: [{ type: core.Optional }] },
            { type: RowActionService }
        ]; };
        ActionableOompaLoompa = __decorate([ __param(1, core.Optional())
        ], ActionableOompaLoompa);
ActionableOompaLoompa.ɵfac = function ActionableOompaLoompa_Factory(t) { return new (t || ActionableOompaLoompa)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DatagridWillyWonka, 8), ɵngcc0.ɵɵdirectiveInject(RowActionService)); };
ActionableOompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ActionableOompaLoompa, selectors: [["clr-datagrid"], ["clr-dg-row"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActionableOompaLoompa, [{
        type: core.Directive,
        args: [{ selector: 'clr-datagrid, clr-dg-row' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: DatagridWillyWonka, decorators: [{
                type: core.Optional
            }] }, { type: RowActionService }]; }, null); })();
        return ActionableOompaLoompa;
    }(OompaLoompa));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DetailService = /** @class */ (function () {
        function DetailService() {
            this.toggleState = false;
            this._state = new rxjs.BehaviorSubject(this.toggleState);
            this._enabled = false;
        }
        Object.defineProperty(DetailService.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (state) {
                this._enabled = state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DetailService.prototype, "stateChange", {
            get: function () {
                return this._state.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DetailService.prototype.close = function () {
            this.toggleState = false;
            this._state.next(this.toggleState);
            if (this.button) {
                this.button.focus();
                this.button = null;
            }
        };
        DetailService.prototype.open = function (item, button) {
            this.cache = item;
            this.button = button;
            this.toggleState = true;
            this._state.next(this.toggleState);
        };
        DetailService.prototype.toggle = function (item, button) {
            if (this.isRowOpen(item) || !item) {
                this.close();
            }
            else {
                this.open(item, button);
            }
        };
        Object.defineProperty(DetailService.prototype, "state", {
            get: function () {
                return this.cache;
            },
            enumerable: true,
            configurable: true
        });
        DetailService.prototype.isRowOpen = function (item) {
            return !!(this.toggleState && this.cache === item);
        };
        Object.defineProperty(DetailService.prototype, "isOpen", {
            get: function () {
                return this.toggleState === true;
            },
            enumerable: true,
            configurable: true
        });
DetailService.ɵfac = function DetailService_Factory(t) { return new (t || DetailService)(); };
DetailService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DetailService, factory: function (t) { return DetailService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DetailService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DetailService;
    }());

    var ExpandableRowsCount = /** @class */ (function () {
        function ExpandableRowsCount(detailService) {
            this.detailService = detailService;
            this.expandableCount = 0;
        }
        ExpandableRowsCount.prototype.register = function () {
            this.expandableCount++;
        };
        ExpandableRowsCount.prototype.unregister = function () {
            this.expandableCount--;
        };
        Object.defineProperty(ExpandableRowsCount.prototype, "hasExpandableRow", {
            /**
             * false means no rows with action
             * check if details are on, and disable rows entirely
             */
            get: function () {
                return !this.detailService.enabled && this.expandableCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        ExpandableRowsCount.ctorParameters = function () { return [
            { type: DetailService }
        ]; };
ExpandableRowsCount.ɵfac = function ExpandableRowsCount_Factory(t) { return new (t || ExpandableRowsCount)(ɵngcc0.ɵɵinject(DetailService)); };
ExpandableRowsCount.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ExpandableRowsCount, factory: function (t) { return ExpandableRowsCount.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandableRowsCount, [{
        type: core.Injectable
    }], function () { return [{ type: DetailService }]; }, null); })();
        return ExpandableRowsCount;
    }());

    var ExpandableOompaLoompa = /** @class */ (function (_super) {
        __extends(ExpandableOompaLoompa, _super);
        function ExpandableOompaLoompa(cdr, willyWonka, expandableCount) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.expandableCount = expandableCount;
            return _this;
        }
        Object.defineProperty(ExpandableOompaLoompa.prototype, "flavor", {
            get: function () {
                return this.expandableCount.hasExpandableRow;
            },
            enumerable: true,
            configurable: true
        });
        ExpandableOompaLoompa.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: DatagridWillyWonka, decorators: [{ type: core.Optional }] },
            { type: ExpandableRowsCount }
        ]; };
        ExpandableOompaLoompa = __decorate([ __param(1, core.Optional())
        ], ExpandableOompaLoompa);
ExpandableOompaLoompa.ɵfac = function ExpandableOompaLoompa_Factory(t) { return new (t || ExpandableOompaLoompa)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DatagridWillyWonka, 8), ɵngcc0.ɵɵdirectiveInject(ExpandableRowsCount)); };
ExpandableOompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ExpandableOompaLoompa, selectors: [["clr-datagrid"], ["clr-dg-row"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandableOompaLoompa, [{
        type: core.Directive,
        args: [{ selector: 'clr-datagrid, clr-dg-row' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: DatagridWillyWonka, decorators: [{
                type: core.Optional
            }] }, { type: ExpandableRowsCount }]; }, null); })();
        return ExpandableOompaLoompa;
    }(OompaLoompa));

    var DatagridPropertyComparator = /** @class */ (function () {
        function DatagridPropertyComparator(prop) {
            this.prop = prop;
            this.nestedProp = new NestedProperty(prop);
        }
        DatagridPropertyComparator.prototype.compare = function (a, b) {
            var propA = this.nestedProp.getPropValue(a);
            var propB = this.nestedProp.getPropValue(b);
            if (typeof propA === 'string') {
                propA = propA.toLowerCase();
            }
            if (typeof propB === 'string') {
                propB = propB.toLowerCase();
            }
            if (typeof propA === 'undefined' || propA === null) {
                if (typeof propB === 'undefined' || propB === null) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else {
                if (typeof propB === 'undefined' || propB === null) {
                    return -1;
                }
                else if (propA < propB) {
                    return -1;
                }
                else if (propA > propB) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
        };
        return DatagridPropertyComparator;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Enumeration representing the sorting order of a datagrid column. It is a constant Enum,
     * i.e. each value needs to be treated as a `number`, starting at index 0.
     *
     * @export
     * @enum {number}
     */

    (function (ClrDatagridSortOrder) {
        ClrDatagridSortOrder[ClrDatagridSortOrder["UNSORTED"] = 0] = "UNSORTED";
        ClrDatagridSortOrder[ClrDatagridSortOrder["ASC"] = 1] = "ASC";
        ClrDatagridSortOrder[ClrDatagridSortOrder["DESC"] = -1] = "DESC";
    })(exports.ClrDatagridSortOrder || (exports.ClrDatagridSortOrder = {}));

    var Sort = /** @class */ (function () {
        function Sort(stateDebouncer) {
            this.stateDebouncer = stateDebouncer;
            /**
             * Ascending order if false, descending if true
             */
            this._reverse = false;
            /**
             * The Observable that lets other classes subscribe to sort changes
             */
            this._change = new rxjs.Subject();
        }
        Object.defineProperty(Sort.prototype, "comparator", {
            get: function () {
                return this._comparator;
            },
            set: function (value) {
                this.stateDebouncer.changeStart();
                this._comparator = value;
                this.emitChange();
                this.stateDebouncer.changeDone();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sort.prototype, "reverse", {
            get: function () {
                return this._reverse;
            },
            set: function (value) {
                this.stateDebouncer.changeStart();
                this._reverse = value;
                this.emitChange();
                this.stateDebouncer.changeDone();
            },
            enumerable: true,
            configurable: true
        });
        Sort.prototype.emitChange = function () {
            this._change.next(this);
        };
        Object.defineProperty(Sort.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * @memberof Sort
         */
        Sort.prototype.toggle = function (sortBy, forceReverse) {
            this.stateDebouncer.changeStart();
            // We modify private properties directly, to batch the change event
            if (this.comparator === sortBy) {
                this._reverse = typeof forceReverse !== 'undefined' ? forceReverse || !this._reverse : !this._reverse;
            }
            else {
                this._comparator = sortBy;
                this._reverse = typeof forceReverse !== 'undefined' ? forceReverse : false;
            }
            this.emitChange();
            this.stateDebouncer.changeDone();
        };
        /**
         * Clears the current sorting order
         */
        Sort.prototype.clear = function () {
            this.comparator = null;
        };
        /**
         * Compares two objects according to the current comparator
         */
        Sort.prototype.compare = function (a, b) {
            return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
        };
        Sort.ctorParameters = function () { return [
            { type: StateDebouncer }
        ]; };
Sort.ɵfac = function Sort_Factory(t) { return new (t || Sort)(ɵngcc0.ɵɵinject(StateDebouncer)); };
Sort.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Sort, factory: function (t) { return Sort.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Sort, [{
        type: core.Injectable
    }], function () { return [{ type: StateDebouncer }]; }, null); })();
        return Sort;
    }());

    var WrappedColumn = /** @class */ (function () {
        function WrappedColumn() {
            this._dynamic = false;
        }
        WrappedColumn.prototype.ngAfterViewInit = function () {
            // Create the cells view in memory, not the DOM.
            this.columnView = this.templateRef.createEmbeddedView(null);
        };
        WrappedColumn.prototype.ngOnDestroy = function () {
            this.columnView.destroy();
        };
        __decorate([
            core.ViewChild('columnPortal')
        ], WrappedColumn.prototype, "templateRef", void 0);
WrappedColumn.ɵfac = function WrappedColumn_Factory(t) { return new (t || WrappedColumn)(); };
WrappedColumn.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WrappedColumn, selectors: [["dg-wrapped-column"]], viewQuery: function WrappedColumn_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c31, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, ngContentSelectors: _c1, decls: 2, vars: 0, consts: [["columnPortal", ""]], template: function WrappedColumn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, WrappedColumn_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WrappedColumn, [{
        type: core.Component,
        args: [{
                selector: 'dg-wrapped-column',
                template: "\n        <ng-template #columnPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
            }]
    }], function () { return []; }, { templateRef: [{
            type: core.ViewChild,
            args: ['columnPortal']
        }] }); })();
        return WrappedColumn;
    }());

    var ClrDatagridColumn = /** @class */ (function (_super) {
        __extends(ClrDatagridColumn, _super);
        function ClrDatagridColumn(_sort, filters, vcr, detailService, changeDetectorRef, commonStrings) {
            var _this = _super.call(this, filters) || this;
            _this._sort = _sort;
            _this.vcr = vcr;
            _this.detailService = detailService;
            _this.changeDetectorRef = changeDetectorRef;
            _this.commonStrings = commonStrings;
            _this.showSeparator = true;
            /**
             * Subscription to the sort service changes
             */
            _this.subscriptions = [];
            /*
            * What type is this column?  This defaults to STRING, but can also be
            * set to NUMBER.  Unsupported types default to STRING. Users can set it
            * via the [clrDgColType] input by setting it to 'string' or 'number'.
            */
            _this._colType = 'string';
            // deprecated: to be removed - START
            /**
             * Indicates if the column is currently sorted
             *
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            _this._sorted = false;
            /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            _this.sortedChange = new core.EventEmitter();
            // deprecated: to be removed - END
            /**
             * Indicates how the column is currently sorted
             */
            _this._sortOrder = exports.ClrDatagridSortOrder.UNSORTED;
            _this.sortOrderChange = new core.EventEmitter();
            /**
             * A custom filter for this column that can be provided in the projected content
             */
            _this.customFilter = false;
            _this.filterValueChange = new core.EventEmitter();
            _this.subscriptions.push(_this.listenForSortingChanges());
            _this.subscriptions.push(_this.listenForDetailPaneChanges());
            return _this;
        }
        ClrDatagridColumn.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ClrDatagridColumn.prototype.listenForDetailPaneChanges = function () {
            var _this = this;
            return this.detailService.stateChange.subscribe(function (state) {
                if (_this.showSeparator !== !state) {
                    _this.showSeparator = !state;
                    // Have to manually change because of OnPush
                    _this.changeDetectorRef.markForCheck();
                }
            });
        };
        ClrDatagridColumn.prototype.listenForSortingChanges = function () {
            var _this = this;
            return this._sort.change.subscribe(function (sort) {
                // Need to manually mark the component to be checked
                // for both activating and deactivating sorting
                _this.changeDetectorRef.markForCheck();
                // We're only listening to make sure we emit an event when the column goes from sorted to unsorted
                if (_this.sortOrder !== exports.ClrDatagridSortOrder.UNSORTED && sort.comparator !== _this._sortBy) {
                    _this._sortOrder = exports.ClrDatagridSortOrder.UNSORTED;
                    _this.sortOrderChange.emit(_this._sortOrder);
                    // removes the sortIcon when column becomes unsorted
                    _this.sortIcon = null;
                }
                // deprecated: to be removed - START
                if (_this.sorted && sort.comparator !== _this._sortBy) {
                    _this._sorted = false;
                    _this.sortedChange.emit(false);
                }
                // deprecated: to be removed - END
            });
        };
        Object.defineProperty(ClrDatagridColumn.prototype, "field", {
            get: function () {
                return this._field;
            },
            set: function (field) {
                if (typeof field === 'string') {
                    this._field = field;
                    if (!this.sortBy) {
                        this._sortBy = new DatagridPropertyComparator(field);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "colType", {
            get: function () {
                return this._colType;
            },
            // TODO: We might want to make this an enum in the future
            set: function (value) {
                this._colType = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumn.prototype.setupDefaultFilter = function (field, colType) {
            if (colType === 'number') {
                this.setFilter(new DatagridNumericFilterImpl(new DatagridPropertyNumericFilter(field)));
            }
            else if (colType === 'string') {
                this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
            }
            if (this.filter && this.initFilterValue) {
                this.updateFilterValue = this.initFilterValue;
                // This initFilterValue should be used only once after the filter registration
                // So deleting this property value to prevent it from being used again
                // if this field property is set again
                delete this.initFilterValue;
            }
        };
        ClrDatagridColumn.prototype.ngOnChanges = function (changes) {
            if (changes.colType &&
                changes.colType.currentValue &&
                changes.colType.currentValue !== changes.colType.previousValue) {
                if (!this.customFilter && !this.filter && this.colType && this.field) {
                    this.setupDefaultFilter(this.field, this.colType);
                }
            }
            if (changes.field && changes.field.currentValue && changes.field.currentValue !== changes.field.previousValue) {
                if (!this.customFilter && this.colType) {
                    this.setupDefaultFilter(this.field, this.colType);
                }
            }
        };
        Object.defineProperty(ClrDatagridColumn.prototype, "sortBy", {
            get: function () {
                return this._sortBy;
            },
            set: function (comparator) {
                if (typeof comparator === 'string') {
                    this._sortBy = new DatagridPropertyComparator(comparator);
                }
                else {
                    if (comparator) {
                        this._sortBy = comparator;
                    }
                    else {
                        if (this.field) {
                            this._sortBy = new DatagridPropertyComparator(this.field);
                        }
                        else {
                            delete this._sortBy;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortable", {
            /**
             * Indicates if the column is sortable
             */
            get: function () {
                return !!this._sortBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sorted", {
            get: function () {
                return this._sorted;
            },
            /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            set: function (value) {
                if (!value && this.sorted) {
                    this._sorted = false;
                    this._sort.clear();
                }
                else if (value && !this.sorted) {
                    this.sort();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortOrder", {
            get: function () {
                return this._sortOrder;
            },
            set: function (value) {
                if (typeof value === 'undefined') {
                    return;
                }
                // only if the incoming order is different from the current one
                if (this._sortOrder === value) {
                    return;
                }
                switch (value) {
                    // the Unsorted case happens when the current state is either Asc or Desc
                    default:
                    case exports.ClrDatagridSortOrder.UNSORTED:
                        this._sort.clear();
                        break;
                    case exports.ClrDatagridSortOrder.ASC:
                        this.sort(false);
                        break;
                    case exports.ClrDatagridSortOrder.DESC:
                        this.sort(true);
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "ariaSort", {
            get: function () {
                switch (this._sortOrder) {
                    default:
                    case exports.ClrDatagridSortOrder.UNSORTED:
                        return 'none';
                    case exports.ClrDatagridSortOrder.ASC:
                        return 'ascending';
                    case exports.ClrDatagridSortOrder.DESC:
                        return 'descending';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sorts the datagrid based on this column
         */
        ClrDatagridColumn.prototype.sort = function (reverse) {
            if (!this.sortable) {
                return;
            }
            this._sort.toggle(this._sortBy, reverse);
            // setting the private variable to not retrigger the setter logic
            this._sortOrder = this._sort.reverse ? exports.ClrDatagridSortOrder.DESC : exports.ClrDatagridSortOrder.ASC;
            // Sets the correct icon for current sort order
            this.sortIcon = this._sortOrder === exports.ClrDatagridSortOrder.DESC ? 'arrow down' : 'arrow';
            this.sortOrderChange.emit(this._sortOrder);
            // deprecated: to be removed - START
            this._sorted = true;
            this.sortedChange.emit(true);
            // deprecated: to be removed - END
        };
        Object.defineProperty(ClrDatagridColumn.prototype, "projectedFilter", {
            set: function (custom) {
                if (custom) {
                    this.deleteFilter();
                    this.customFilter = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "filterValue", {
            get: function () {
                if (this.filter instanceof DatagridStringFilterImpl || this.filter instanceof DatagridNumericFilterImpl) {
                    return this.filter.value;
                }
            },
            set: function (newValue) {
                if (this.filter instanceof DatagridStringFilterImpl || this.filter instanceof DatagridNumericFilterImpl) {
                    this.updateFilterValue = newValue;
                    this.filterValueChange.emit(this.filter.value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "updateFilterValue", {
            set: function (newValue) {
                if (this.filter) {
                    if (this.filter instanceof DatagridStringFilterImpl) {
                        if (!newValue || typeof newValue !== 'string') {
                            newValue = '';
                        }
                        if (newValue !== this.filter.value) {
                            this.filter.value = newValue;
                        }
                    }
                    else if (this.filter instanceof DatagridNumericFilterImpl) {
                        if (!newValue || !(newValue instanceof Array)) {
                            newValue = [null, null];
                        }
                        if (newValue.length === 2 && (newValue[0] !== this.filter.value[0] || newValue[1] !== this.filter.value[1])) {
                            this.filter.value = newValue;
                        }
                    }
                }
                else {
                    this.initFilterValue = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumn.prototype.ngOnInit = function () {
            this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
        };
        Object.defineProperty(ClrDatagridColumn.prototype, "_view", {
            get: function () {
                return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumn.ctorParameters = function () { return [
            { type: Sort },
            { type: FiltersProvider },
            { type: core.ViewContainerRef },
            { type: DetailService },
            { type: core.ChangeDetectorRef },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.Input('clrDgColType')
        ], ClrDatagridColumn.prototype, "colType", null);
        __decorate([
            core.Input('clrDgField')
        ], ClrDatagridColumn.prototype, "field", null);
        __decorate([
            core.Input('clrDgSortBy')
        ], ClrDatagridColumn.prototype, "sortBy", null);
        __decorate([
            core.Input('clrDgSorted')
        ], ClrDatagridColumn.prototype, "sorted", null);
        __decorate([
            core.Output('clrDgSortedChange')
        ], ClrDatagridColumn.prototype, "sortedChange", void 0);
        __decorate([
            core.Input('clrDgSortOrder')
        ], ClrDatagridColumn.prototype, "sortOrder", null);
        __decorate([
            core.Output('clrDgSortOrderChange')
        ], ClrDatagridColumn.prototype, "sortOrderChange", void 0);
        __decorate([
            core.ContentChild(CustomFilter)
        ], ClrDatagridColumn.prototype, "projectedFilter", null);
        __decorate([
            core.Input('clrFilterValue')
        ], ClrDatagridColumn.prototype, "updateFilterValue", null);
        __decorate([
            core.Output('clrFilterValueChange')
        ], ClrDatagridColumn.prototype, "filterValueChange", void 0);
ClrDatagridColumn.ɵfac = function ClrDatagridColumn_Factory(t) { return new (t || ClrDatagridColumn)(ɵngcc0.ɵɵdirectiveInject(Sort), ɵngcc0.ɵɵdirectiveInject(FiltersProvider), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrDatagridColumn.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridColumn, selectors: [["clr-dg-column"]], contentQueries: function ClrDatagridColumn_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CustomFilter, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.projectedFilter = _t.first);
    } }, hostAttrs: ["role", "columnheader"], hostVars: 3, hostBindings: function ClrDatagridColumn_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-sort", ctx.ariaSort);
        ɵngcc0.ɵɵclassProp("datagrid-column", true);
    } }, inputs: { field: ["clrDgField", "field"], colType: ["clrDgColType", "colType"], updateFilterValue: ["clrFilterValue", "updateFilterValue"], sortBy: ["clrDgSortBy", "sortBy"], sorted: ["clrDgSorted", "sorted"], sortOrder: ["clrDgSortOrder", "sortOrder"] }, outputs: { sortedChange: "clrDgSortedChange", sortOrderChange: "clrDgSortOrderChange", filterValueChange: "clrFilterValueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([ClrPopoverPositionService, ClrPopoverEventsService, ClrPopoverToggleService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c33, decls: 9, vars: 5, consts: [[1, "datagrid-column-flex"], ["class", "datagrid-column-title", "type", "button", 3, "click", 4, "ngIf"], [3, "clrDgStringFilter", "clrFilterValue", "clrFilterValueChange", 4, "ngIf"], [3, "clrDgNumericFilter", "clrFilterValue", "clrFilterValueChange", 4, "ngIf"], ["columnTitle", ""], ["class", "datagrid-column-title", 4, "ngIf"], [4, "ngIf"], ["type", "button", 1, "datagrid-column-title", 3, "click"], [4, "ngTemplateOutlet"], ["class", "sort-icon", 4, "ngIf"], [1, "sort-icon"], [3, "clrDgStringFilter", "clrFilterValue", "clrFilterValueChange"], [3, "clrDgNumericFilter", "clrFilterValue", "clrFilterValueChange"], [1, "datagrid-column-title"]], template: function ClrDatagridColumn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c32);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ClrDatagridColumn_button_1_Template, 3, 2, "button", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵtemplate(3, ClrDatagridColumn_clr_dg_string_filter_3_Template, 1, 2, "clr-dg-string-filter", 2);
        ɵngcc0.ɵɵtemplate(4, ClrDatagridColumn_clr_dg_numeric_filter_4_Template, 1, 2, "clr-dg-numeric-filter", 3);
        ɵngcc0.ɵɵtemplate(5, ClrDatagridColumn_ng_template_5_Template, 1, 0, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, ClrDatagridColumn_span_7_Template, 2, 1, "span", 5);
        ɵngcc0.ɵɵtemplate(8, ClrDatagridColumn_clr_dg_column_separator_8_Template, 1, 0, "clr-dg-column-separator", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.sortable);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.field && !ctx.customFilter && ctx.colType == "string");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.field && !ctx.customFilter && ctx.colType == "number");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.sortable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSeparator);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ClrIconCustomTag,
        DatagridStringFilter,
        DatagridNumericFilter,
        ClrDatagridColumnSeparator]; }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridColumn, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-column',
                template: "\n      <div class=\"datagrid-column-flex\">\n          <button\n            class=\"datagrid-column-title\"\n            *ngIf=\"sortable\"\n            (click)=\"sort()\"\n            type=\"button\">\n              <ng-container  *ngTemplateOutlet=\"columnTitle\"></ng-container>\n              <clr-icon\n                      *ngIf=\"sortIcon\"\n                      [attr.shape]=\"sortIcon\"\n                      class=\"sort-icon\"></clr-icon>\n          </button>\n          <!-- I'm really not happy with that select since it's not very scalable -->\n          <ng-content select=\"clr-dg-filter, clr-dg-string-filter, clr-dg-numeric-filter\"></ng-content>\n\n          <clr-dg-string-filter\n                  *ngIf=\"field && !customFilter && (colType=='string')\"\n                  [clrDgStringFilter]=\"registered\"\n                  [(clrFilterValue)]=\"filterValue\"></clr-dg-string-filter>\n\n          <clr-dg-numeric-filter\n                  *ngIf=\"field && !customFilter && (colType=='number')\"\n                  [clrDgNumericFilter]=\"registered\"\n                  [(clrFilterValue)]=\"filterValue\"></clr-dg-numeric-filter>\n\n          <ng-template #columnTitle>\n              <ng-content></ng-content>\n          </ng-template>\n\n\n          <span class=\"datagrid-column-title\" *ngIf=\"!sortable\">\n              <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n          </span>\n\n          <clr-dg-column-separator *ngIf=\"showSeparator\"></clr-dg-column-separator>\n      </div>\n    ",
                providers: [ClrPopoverPositionService, ClrPopoverEventsService, ClrPopoverToggleService],
                host: {
                    '[class.datagrid-column]': 'true',
                    '[attr.aria-sort]': 'ariaSort',
                    role: 'columnheader'
                },
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: Sort }, { type: FiltersProvider }, { type: ɵngcc0.ViewContainerRef }, { type: DetailService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ClrCommonStringsService }]; }, { field: [{
            type: core.Input,
            args: ['clrDgField']
        }], colType: [{
            type: core.Input,
            args: ['clrDgColType']
        }], updateFilterValue: [{
            type: core.Input,
            args: ['clrFilterValue']
        }], sortBy: [{
            type: core.Input,
            args: ['clrDgSortBy']
        }], sorted: [{
            type: core.Input,
            args: ['clrDgSorted']
        }], sortOrder: [{
            type: core.Input,
            args: ['clrDgSortOrder']
        }], projectedFilter: [{
            type: core.ContentChild,
            args: [CustomFilter]
        }], sortedChange: [{
            type: core.Output,
            args: ['clrDgSortedChange']
        }], sortOrderChange: [{
            type: core.Output,
            args: ['clrDgSortOrderChange']
        }], filterValueChange: [{
            type: core.Output,
            args: ['clrFilterValueChange']
        }] }); })();
        return ClrDatagridColumn;
    }(DatagridFilterRegistrar));

    var Items = /** @class */ (function () {
        function Items(_filters, _sort, _page) {
            this._filters = _filters;
            this._sort = _sort;
            this._page = _page;
            /**
             * Indicates if the data is currently loading
             */
            this.loading = false;
            // TODO: Verify that trackBy is registered for the *ngFor case too
            /**
             * Tracking function to identify objects. Default is reference equality.
             */
            this.trackBy = function (index, item) { return item; };
            /**
             * Whether we should use smart items for this datagrid or let the user handle
             * everything.
             */
            this._smart = false;
            /**
             * List of items currently displayed
             */
            this._displayed = [];
            /**
             * The Observable that lets other classes subscribe to items changes
             */
            this._change = new rxjs.Subject();
            this._allChanges = new rxjs.Subject();
        }
        /**
         * Cleans up our subscriptions to other providers
         */
        Items.prototype.destroy = function () {
            if (this._filtersSub) {
                this._filtersSub.unsubscribe();
            }
            if (this._sortSub) {
                this._sortSub.unsubscribe();
            }
            if (this._pageSub) {
                this._pageSub.unsubscribe();
            }
        };
        Object.defineProperty(Items.prototype, "smart", {
            get: function () {
                return this._smart;
            },
            enumerable: true,
            configurable: true
        });
        Items.prototype.smartenUp = function () {
            var _this = this;
            this._smart = true;
            /*
                 * These observers trigger a chain of function: filter -> sort -> paginate
                 * An observer up the chain re-triggers all the operations that follow it.
                 */
            this._filtersSub = this._filters.change.subscribe(function () { return _this._filterItems(); });
            this._sortSub = this._sort.change.subscribe(function () {
                // Special case, if the datagrid went from sorted to unsorted, we have to re-filter
                // to get the original order back
                if (!_this._sort.comparator) {
                    _this._filterItems();
                }
                else {
                    _this._sortItems();
                }
            });
            this._pageSub = this._page.change.subscribe(function () { return _this._changePage(); });
        };
        Object.defineProperty(Items.prototype, "all", {
            get: function () {
                return this._all;
            },
            set: function (items) {
                this._all = items;
                this.emitAllChanges(items);
                if (this.smart) {
                    this._filterItems();
                }
                else {
                    this._displayed = items;
                    this.emitChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Manually recompute the list of displayed items
         */
        Items.prototype.refresh = function () {
            if (this.smart) {
                this._filterItems();
            }
        };
        Object.defineProperty(Items.prototype, "displayed", {
            get: function () {
                // Ideally we could return an immutable array, but we don't have it in Clarity yet.
                return this._displayed;
            },
            enumerable: true,
            configurable: true
        });
        Items.prototype.emitChange = function () {
            this._change.next(this.displayed);
        };
        Object.defineProperty(Items.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Items.prototype.emitAllChanges = function (items) {
            this._allChanges.next(items);
        };
        Object.defineProperty(Items.prototype, "allChanges", {
            get: function () {
                return this._allChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Items.prototype, "uninitialized", {
            /**
             * Checks if we don't have data to process yet, to abort early operations
             */
            get: function () {
                return !this._all;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * FiltersProvider items from the raw list
         */
        Items.prototype._filterItems = function () {
            var _this = this;
            if (this.uninitialized) {
                return;
            }
            if (this._filters.hasActiveFilters()) {
                this._filtered = this._all.filter(function (item) { return _this._filters.accepts(item); });
            }
            else {
                // Work on a shallow copy of the array, to not modify the user's model
                this._filtered = this._all.slice();
            }
            this._page.totalItems = this._filtered.length;
            this._sortItems();
        };
        /**
         * Sorts items in the filtered list
         */
        Items.prototype._sortItems = function () {
            var _this = this;
            if (this.uninitialized) {
                return;
            }
            if (this._sort.comparator) {
                this._filtered.sort(function (a, b) { return _this._sort.compare(a, b); });
            }
            this._changePage();
        };
        /**
         * Extracts the current page from the sorted list
         */
        Items.prototype._changePage = function () {
            // If we know we have pagination but the page size hasn't been set yet, we wait for it.
            if (this.uninitialized || (this._page.activated && this._page.size === 0)) {
                return;
            }
            if (this._page.size > 0) {
                this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
            }
            else {
                this._displayed = this._filtered;
            }
            this.emitChange();
        };
        Items.ctorParameters = function () { return [
            { type: FiltersProvider },
            { type: Sort },
            { type: Page }
        ]; };
Items.ɵfac = function Items_Factory(t) { return new (t || Items)(ɵngcc0.ɵɵinject(FiltersProvider), ɵngcc0.ɵɵinject(Sort), ɵngcc0.ɵɵinject(Page)); };
Items.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Items, factory: function (t) { return Items.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Items, [{
        type: core.Injectable
    }], function () { return [{ type: FiltersProvider }, { type: Sort }, { type: Page }]; }, null); })();
        return Items;
    }());

    var ClrDatagridItems = /** @class */ (function () {
        function ClrDatagridItems(template, differs, items, vcr) {
            var _this = this;
            this.template = template;
            this.differs = differs;
            this.items = items;
            this.vcr = vcr;
            this.differ = null;
            this.subscriptions = [];
            items.smartenUp();
            this.iterableProxy = new common.NgForOf(this.vcr, this.template, this.differs);
            this.subscriptions.push(items.change.subscribe(function (newItems) {
                _this.iterableProxy.ngForOf = newItems;
                _this.iterableProxy.ngDoCheck();
            }));
        }
        Object.defineProperty(ClrDatagridItems.prototype, "rawItems", {
            set: function (items) {
                this._rawItems = items ? items : []; // local copy for ngOnChange diffing
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridItems.prototype, "trackBy", {
            set: function (value) {
                this.items.trackBy = value;
                this.iterableProxy.ngForTrackBy = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridItems.prototype.ngDoCheck = function () {
            if (!this.differ) {
                this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
            }
            if (this.differ) {
                var changes = this.differ.diff(this._rawItems);
                if (changes) {
                    // TODO: not very efficient right now,
                    // but premature optimization is the root of all evil.
                    this.items.all = this._rawItems;
                }
            }
        };
        ClrDatagridItems.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDatagridItems.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.IterableDiffers },
            { type: Items },
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.Input('clrDgItemsOf')
        ], ClrDatagridItems.prototype, "rawItems", null);
        __decorate([
            core.Input('clrDgItemsTrackBy')
        ], ClrDatagridItems.prototype, "trackBy", null);
ClrDatagridItems.ɵfac = function ClrDatagridItems_Factory(t) { return new (t || ClrDatagridItems)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(Items), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ClrDatagridItems.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDatagridItems, selectors: [["", "clrDgItems", "", "clrDgItemsOf", ""]], inputs: { rawItems: ["clrDgItemsOf", "rawItems"], trackBy: ["clrDgItemsTrackBy", "trackBy"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridItems, [{
        type: core.Directive,
        args: [{
                selector: '[clrDgItems][clrDgItemsOf]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: Items }, { type: ɵngcc0.ViewContainerRef }]; }, { rawItems: [{
            type: core.Input,
            args: ['clrDgItemsOf']
        }], trackBy: [{
            type: core.Input,
            args: ['clrDgItemsTrackBy']
        }] }); })();
        return ClrDatagridItems;
    }());

    var ClrDatagridPlaceholder = /** @class */ (function () {
        function ClrDatagridPlaceholder(items) {
            this.items = items;
        }
        Object.defineProperty(ClrDatagridPlaceholder.prototype, "emptyDatagrid", {
            /**
             * Tests if the datagrid is empty, meaning it doesn't contain any items
             */
            get: function () {
                return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridPlaceholder.ctorParameters = function () { return [
            { type: Items }
        ]; };
ClrDatagridPlaceholder.ɵfac = function ClrDatagridPlaceholder_Factory(t) { return new (t || ClrDatagridPlaceholder)(ɵngcc0.ɵɵdirectiveInject(Items)); };
ClrDatagridPlaceholder.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridPlaceholder, selectors: [["clr-dg-placeholder"]], hostVars: 2, hostBindings: function ClrDatagridPlaceholder_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-placeholder-container", true);
    } }, ngContentSelectors: _c1, decls: 3, vars: 4, consts: [[1, "datagrid-placeholder"], ["class", "datagrid-placeholder-image", 4, "ngIf"], [4, "ngIf"], [1, "datagrid-placeholder-image"]], template: function ClrDatagridPlaceholder_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ClrDatagridPlaceholder_div_1_Template, 1, 0, "div", 1);
        ɵngcc0.ɵɵtemplate(2, ClrDatagridPlaceholder_2_Template, 1, 0, undefined, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-empty", ctx.emptyDatagrid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.emptyDatagrid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.emptyDatagrid);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridPlaceholder, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-placeholder',
                template: "\n        <div\n            class=\"datagrid-placeholder\"\n            [class.datagrid-empty]=\"emptyDatagrid\">\n                <div class=\"datagrid-placeholder-image\" *ngIf=\"emptyDatagrid\"></div>\n                <ng-content *ngIf=\"emptyDatagrid\"></ng-content>\n        </div>\n    ",
                host: { '[class.datagrid-placeholder-container]': 'true' }
            }]
    }], function () { return [{ type: Items }]; }, null); })();
        return ClrDatagridPlaceholder;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var POPOVER_HOST_ANCHOR = new core.InjectionToken('POPOVER_HOST_ANCHOR');

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var SignpostFocusManager = /** @class */ (function () {
        function SignpostFocusManager() {
        }
        Object.defineProperty(SignpostFocusManager.prototype, "triggerEl", {
            set: function (value) {
                this._triggerEl = value;
            },
            enumerable: true,
            configurable: true
        });
        SignpostFocusManager.prototype.focusTrigger = function () {
            if (this._triggerEl) {
                this._triggerEl.focus();
            }
        };
SignpostFocusManager.ɵfac = function SignpostFocusManager_Factory(t) { return new (t || SignpostFocusManager)(); };
SignpostFocusManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SignpostFocusManager, factory: function (t) { return SignpostFocusManager.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SignpostFocusManager, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return SignpostFocusManager;
    }());

    /*
     *  Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     *
     */
    var SignpostIdService = /** @class */ (function () {
        function SignpostIdService() {
            this._id = new rxjs.Subject();
        }
        SignpostIdService.prototype.setId = function (id) {
            this._id.next(id);
        };
        Object.defineProperty(SignpostIdService.prototype, "id", {
            get: function () {
                return this._id.asObservable();
            },
            enumerable: true,
            configurable: true
        });
SignpostIdService.ɵfac = function SignpostIdService_Factory(t) { return new (t || SignpostIdService)(); };
SignpostIdService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SignpostIdService, factory: function (t) { return SignpostIdService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SignpostIdService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return SignpostIdService;
    }());

    var ClrSignpostTrigger = /** @class */ (function () {
        function ClrSignpostTrigger(toggleService, el, commonStrings, signpostIdService, signpostFocusManager, document, platformId) {
            this.toggleService = toggleService;
            this.el = el;
            this.commonStrings = commonStrings;
            this.signpostIdService = signpostIdService;
            this.signpostFocusManager = signpostFocusManager;
            this.platformId = platformId;
            this.subscriptions = [];
            this.document = document;
        }
        ClrSignpostTrigger.prototype.ngOnInit = function () {
            var _this = this;
            this.signpostFocusManager.triggerEl = this.el.nativeElement;
            this.subscriptions.push(this.toggleService.openChange.subscribe(function (isOpen) {
                _this.ariaExpanded = isOpen;
                var prevIsOpen = _this.isOpen;
                _this.isOpen = isOpen;
                // openChange fires false on initialization because signpost starts as closed by default
                // but we shouldn't focus on that initial false value
                // we should focus back only if it's closed after being opened
                if (!_this.isOpen && prevIsOpen) {
                    _this.focusOnClose();
                }
            }), this.signpostIdService.id.subscribe(function (idChange) { return (_this.ariaControl = idChange); }));
        };
        ClrSignpostTrigger.prototype.focusOnClose = function () {
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            // we have to set the focus back on the trigger only if the focus is reset back to the body element
            // if the focus is on another element, we are not allowed to move that focus back to this trigger again.
            if (!this.isOpen && this.document.activeElement === this.document.body) {
                this.signpostFocusManager.focusTrigger();
            }
        };
        ClrSignpostTrigger.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        /**********
         *
         * @description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         */
        ClrSignpostTrigger.prototype.onSignpostTriggerClick = function (event) {
            this.toggleService.toggleWithEvent(event);
        };
        ClrSignpostTrigger.ctorParameters = function () { return [
            { type: ClrPopoverToggleService },
            { type: core.ElementRef },
            { type: ClrCommonStringsService },
            { type: SignpostIdService },
            { type: SignpostFocusManager },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        __decorate([
            core.HostListener('click', ['$event'])
        ], ClrSignpostTrigger.prototype, "onSignpostTriggerClick", null);
        ClrSignpostTrigger = __decorate([ __param(5, core.Inject(common.DOCUMENT)),
            __param(6, core.Inject(core.PLATFORM_ID))
        ], ClrSignpostTrigger);
ClrSignpostTrigger.ɵfac = function ClrSignpostTrigger_Factory(t) { return new (t || ClrSignpostTrigger)(ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(SignpostIdService), ɵngcc0.ɵɵdirectiveInject(SignpostFocusManager), ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
ClrSignpostTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrSignpostTrigger, selectors: [["", "clrSignpostTrigger", ""]], hostAttrs: [1, "signpost-trigger"], hostVars: 5, hostBindings: function ClrSignpostTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrSignpostTrigger_click_HostBindingHandler($event) { return ctx.onSignpostTriggerClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.signpostToggle)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.ariaControl);
        ɵngcc0.ɵɵclassProp("active", ctx.isOpen);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSignpostTrigger, [{
        type: core.Directive,
        args: [{
                selector: '[clrSignpostTrigger]',
                host: {
                    class: 'signpost-trigger',
                    '[attr.aria-label]': 'commonStrings.keys.signpostToggle',
                    '[attr.aria-expanded]': 'ariaExpanded',
                    '[attr.aria-controls]': 'ariaControl',
                    '[class.active]': 'isOpen'
                }
            }]
    }], function () { return [{ type: ClrPopoverToggleService }, { type: ɵngcc0.ElementRef }, { type: ClrCommonStringsService }, { type: SignpostIdService }, { type: SignpostFocusManager }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { onSignpostTriggerClick: [{
            type: core.HostListener,
            args: ['click', ['$event']]
        }] }); })();
        return ClrSignpostTrigger;
    }());

    var ClrSignpost = /** @class */ (function () {
        function ClrSignpost(commonStrings) {
            this.commonStrings = commonStrings;
            /**********
             * @property useCustomTrigger
             *
             * @description
             * Flag used to determine if we need to use the default trigger or a user supplied trigger element.
             *
             */
            this.useCustomTrigger = false;
        }
        Object.defineProperty(ClrSignpost.prototype, "customTrigger", {
            /**********
             * @property signPostTrigger
             *
             * @description
             * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
             *
             */
            set: function (trigger) {
                this.useCustomTrigger = !!trigger;
            },
            enumerable: true,
            configurable: true
        });
        ClrSignpost.ctorParameters = function () { return [
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.ContentChild(ClrSignpostTrigger)
        ], ClrSignpost.prototype, "customTrigger", null);
ClrSignpost.ɵfac = function ClrSignpost_Factory(t) { return new (t || ClrSignpost)(ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrSignpost.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrSignpost, selectors: [["clr-signpost"]], contentQueries: function ClrSignpost_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrSignpostTrigger, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTrigger = _t.first);
    } }, hostVars: 2, hostBindings: function ClrSignpost_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("signpost", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            ClrPopoverToggleService,
            SignpostFocusManager,
            { provide: POPOVER_HOST_ANCHOR, useExisting: core.ElementRef },
            SignpostIdService,
        ])], ngContentSelectors: _c1, decls: 2, vars: 1, consts: [[4, "ngIf"], ["type", "button", "clrSignpostTrigger", "", 1, "signpost-action", "btn", "btn-small", "btn-link"], ["shape", "info"]], template: function ClrSignpost_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrSignpost_ng_container_0_Template, 3, 1, "ng-container", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.useCustomTrigger);
    } }, directives: [ɵngcc1.NgIf, ClrSignpostTrigger,
        ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSignpost, [{
        type: core.Component,
        args: [{
                selector: 'clr-signpost',
                template: "\n        <ng-container *ngIf=\"!useCustomTrigger\">\n            <button\n                type=\"button\"\n                class=\"signpost-action btn btn-small btn-link\"\n                clrSignpostTrigger>\n                <clr-icon shape=\"info\" [attr.title]=\"commonStrings.keys.info\"></clr-icon>\n            </button>\n        </ng-container>\n\n        <ng-content></ng-content>\n    ",
                host: { '[class.signpost]': 'true' },
                providers: [
                    ClrPopoverToggleService,
                    SignpostFocusManager,
                    { provide: POPOVER_HOST_ANCHOR, useExisting: core.ElementRef },
                    SignpostIdService,
                ]
            }]
    }], function () { return [{ type: ClrCommonStringsService }]; }, { customTrigger: [{
            type: core.ContentChild,
            args: [ClrSignpostTrigger]
        }] }); })();
        return ClrSignpost;
    }());

    var WrappedCell = /** @class */ (function () {
        function WrappedCell() {
            this._dynamic = false;
        }
        WrappedCell.prototype.ngAfterViewInit = function () {
            this.cellView = this.templateRef.createEmbeddedView(null);
        };
        WrappedCell.prototype.ngOnDestroy = function () {
            this.cellView.destroy();
        };
        __decorate([
            core.ViewChild('cellPortal')
        ], WrappedCell.prototype, "templateRef", void 0);
WrappedCell.ɵfac = function WrappedCell_Factory(t) { return new (t || WrappedCell)(); };
WrappedCell.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WrappedCell, selectors: [["dg-wrapped-cell"]], viewQuery: function WrappedCell_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c34, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, ngContentSelectors: _c1, decls: 2, vars: 0, consts: [["cellPortal", ""]], template: function WrappedCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, WrappedCell_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WrappedCell, [{
        type: core.Component,
        args: [{
                selector: 'dg-wrapped-cell',
                template: "\n        <ng-template #cellPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
            }]
    }], function () { return []; }, { templateRef: [{
            type: core.ViewChild,
            args: ['cellPortal']
        }] }); })();
        return WrappedCell;
    }());

    var ClrDatagridCell = /** @class */ (function () {
        function ClrDatagridCell(vcr) {
            this.vcr = vcr;
        }
        ClrDatagridCell.prototype.ngOnInit = function () {
            this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
        };
        Object.defineProperty(ClrDatagridCell.prototype, "_view", {
            get: function () {
                return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridCell.ctorParameters = function () { return [
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.ContentChildren(ClrSignpost)
        ], ClrDatagridCell.prototype, "signpost", void 0);
ClrDatagridCell.ɵfac = function ClrDatagridCell_Factory(t) { return new (t || ClrDatagridCell)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ClrDatagridCell.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridCell, selectors: [["clr-dg-cell"]], contentQueries: function ClrDatagridCell_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrSignpost, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.signpost = _t);
    } }, hostAttrs: ["role", "gridcell"], hostVars: 4, hostBindings: function ClrDatagridCell_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-cell", true)("datagrid-signpost-trigger", ctx.signpost.length > 0);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrDatagridCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridCell, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-cell',
                template: "\n        <ng-content></ng-content>\n    ",
                host: {
                    '[class.datagrid-cell]': 'true',
                    '[class.datagrid-signpost-trigger]': 'signpost.length > 0',
                    role: 'gridcell'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { signpost: [{
            type: core.ContentChildren,
            args: [ClrSignpost]
        }] }); })();
        return ClrDatagridCell;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatagridDisplayMode;
    (function (DatagridDisplayMode) {
        DatagridDisplayMode[DatagridDisplayMode["DISPLAY"] = 0] = "DISPLAY";
        DatagridDisplayMode[DatagridDisplayMode["CALCULATE"] = 1] = "CALCULATE";
    })(DatagridDisplayMode || (DatagridDisplayMode = {}));

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatagridRenderStep;
    (function (DatagridRenderStep) {
        DatagridRenderStep[DatagridRenderStep["ALIGN_COLUMNS"] = 0] = "ALIGN_COLUMNS";
        DatagridRenderStep[DatagridRenderStep["CALCULATE_MODE_ON"] = 1] = "CALCULATE_MODE_ON";
        DatagridRenderStep[DatagridRenderStep["CALCULATE_MODE_OFF"] = 2] = "CALCULATE_MODE_OFF";
        DatagridRenderStep[DatagridRenderStep["CLEAR_WIDTHS"] = 3] = "CLEAR_WIDTHS";
        DatagridRenderStep[DatagridRenderStep["COMPUTE_COLUMN_WIDTHS"] = 4] = "COMPUTE_COLUMN_WIDTHS";
    })(DatagridRenderStep || (DatagridRenderStep = {}));

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatagridRenderOrganizer = /** @class */ (function () {
        function DatagridRenderOrganizer() {
            this._renderStep = new rxjs.Subject();
            this.alreadySized = false;
        }
        Object.defineProperty(DatagridRenderOrganizer.prototype, "renderStep", {
            get: function () {
                return this._renderStep.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DatagridRenderOrganizer.prototype.filterRenderSteps = function (step) {
            return this.renderStep.pipe(operators.filter(function (testStep) { return step === testStep; }));
        };
        DatagridRenderOrganizer.prototype.resize = function () {
            this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
            if (this.alreadySized) {
                this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
            }
            this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
            this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
            this.alreadySized = true;
            this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
        };
DatagridRenderOrganizer.ɵfac = function DatagridRenderOrganizer_Factory(t) { return new (t || DatagridRenderOrganizer)(); };
DatagridRenderOrganizer.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DatagridRenderOrganizer, factory: function (t) { return DatagridRenderOrganizer.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridRenderOrganizer, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DatagridRenderOrganizer;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DisplayModeService = /** @class */ (function () {
        function DisplayModeService(renderOrganizer) {
            var _this = this;
            this.subscriptions = [];
            this._view = new rxjs.BehaviorSubject(DatagridDisplayMode.DISPLAY);
            this.subscriptions.push(renderOrganizer
                .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON)
                .subscribe(function () { return _this._view.next(DatagridDisplayMode.CALCULATE); }));
            this.subscriptions.push(renderOrganizer
                .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF)
                .subscribe(function () { return _this._view.next(DatagridDisplayMode.DISPLAY); }));
        }
        Object.defineProperty(DisplayModeService.prototype, "view", {
            get: function () {
                return this._view.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DisplayModeService.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        DisplayModeService.ctorParameters = function () { return [
            { type: DatagridRenderOrganizer }
        ]; };
DisplayModeService.ɵfac = function DisplayModeService_Factory(t) { return new (t || DisplayModeService)(ɵngcc0.ɵɵinject(DatagridRenderOrganizer)); };
DisplayModeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DisplayModeService, factory: function (t) { return DisplayModeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisplayModeService, [{
        type: core.Injectable
    }], function () { return [{ type: DatagridRenderOrganizer }]; }, null); })();
        return DisplayModeService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var SelectionType;
    (function (SelectionType) {
        SelectionType[SelectionType["None"] = 0] = "None";
        SelectionType[SelectionType["Single"] = 1] = "Single";
        SelectionType[SelectionType["Multi"] = 2] = "Multi";
    })(SelectionType || (SelectionType = {}));

    var nbSelection = 0;
    var Selection = /** @class */ (function () {
        function Selection(_items, _filters, _zone) {
            var _this = this;
            this._items = _items;
            this._filters = _filters;
            this._zone = _zone;
            this.preserveSelection = false;
            this.prevSelectionRefs = []; // Refs of selected items
            this.lockedRefs = []; // Ref of locked items
            this._selectionType = SelectionType.None;
            /** @deprecated since 2.0, remove in 3.0 */
            this.rowSelectionMode = false;
            /**
             * Ignore items changes in the same change detection cycle.
             */
            // tslint:disable-next-line
            this.debounce = false;
            /**
             * Subscriptions to the other providers changes.
             */
            this.subscriptions = [];
            this._valueCollector = new rxjs.Subject();
            /**
             * The Observable that lets other classes subscribe to selection changes
             */
            this._change = new rxjs.Subject();
            this.id = 'clr-dg-selection' + nbSelection++;
            this.subscriptions.push(this._filters.change.subscribe(function () {
                if (!_this._selectable || _this.preserveSelection) {
                    return;
                }
                _this.clearSelection();
            }));
            this.subscriptions.push(this._items.allChanges.subscribe(function (updatedItems) {
                // Reset the lockedRefs;
                var updateLockedRef = [];
                switch (_this.selectionType) {
                    case SelectionType.None: {
                        break;
                    }
                    case SelectionType.Single: {
                        var newSingle_1;
                        var trackBy_1 = _this._items.trackBy;
                        var selectionUpdated_1 = false;
                        // if the currentSingle has been set before data was loaded, we look up and save the ref from current data set
                        if (_this.currentSingle && !_this.prevSingleSelectionRef) {
                            if (_this._items.all && _this._items.trackBy) {
                                var lookup = _this._items.all.findIndex(function (maybe) { return maybe === _this.currentSingle; });
                                _this.prevSingleSelectionRef = _this._items.trackBy(lookup, _this.currentSingle);
                            }
                        }
                        updatedItems.forEach(function (item, index) {
                            var ref = trackBy_1(index, item);
                            // If one of the updated items is the previously selectedSingle, set it as the new one
                            if (_this.prevSingleSelectionRef === ref) {
                                newSingle_1 = item;
                                selectionUpdated_1 = true;
                            }
                            if (_this.lockedRefs.indexOf(ref) > -1) {
                                updateLockedRef.push(ref);
                            }
                        });
                        // If we're using smart datagrids, we expect all items to be present in the updatedItems array.
                        // Therefore, we should delete the currentSingle if it used to be defined but doesn't exist anymore.
                        // No explicit "delete" is required, since newSingle would be undefined at this point.
                        // Marking it as selectionUpdated here will set currentSingle to undefined below in the setTimeout.
                        if (_this._items.smart && !newSingle_1) {
                            selectionUpdated_1 = true;
                        }
                        // TODO: Discussed this with Eudes and this is fine for now.
                        // But we need to figure out a different pattern for the
                        // child triggering the parent change detection problem.
                        // Using setTimeout for now to fix this.
                        setTimeout(function () {
                            if (selectionUpdated_1) {
                                _this.currentSingle = newSingle_1;
                            }
                        }, 0);
                        break;
                    }
                    case SelectionType.Multi: {
                        var leftOver_1 = _this.current.slice();
                        var trackBy_2 = _this._items.trackBy;
                        var selectionUpdated_2 = false;
                        // if the current has been set before data was loaded, we look up and save the ref from current data set
                        if (_this.current.length > 0 && _this.prevSelectionRefs.length !== _this.current.length) {
                            if (_this._items.all && _this._items.trackBy) {
                                _this.prevSelectionRefs = [];
                                _this.current.forEach(function (item) {
                                    var lookup = _this._items.all.findIndex(function (maybe) { return maybe === item; });
                                    _this.prevSelectionRefs.push(_this._items.trackBy(lookup, item));
                                });
                            }
                        }
                        // Duplicate loop, when the issue is issue#2342 is revisited keep in mind that
                        // we need to go over every updated item and check to see if there are valid to be
                        // locked or not and update it. When only add items that are found in the lockedRefs back.
                        //
                        // The both loops below that goes over updatedItems could be combined into one.
                        updatedItems.forEach(function (item, index) {
                            var ref = trackBy_2(index, item);
                            if (_this.lockedRefs.indexOf(ref) > -1) {
                                updateLockedRef.push(ref);
                            }
                        });
                        // TODO: revisit this when we work on https://github.com/vmware/clarity/issues/2342
                        // currently, the selection is cleared when filter is applied, so the logic inside
                        // the if statement below results in broken behavior.
                        if (leftOver_1.length > 0) {
                            updatedItems.forEach(function (item, index) {
                                var ref = trackBy_2(index, item);
                                // Look in current selected refs array if item is selected, and update actual value
                                var selectedIndex = _this.prevSelectionRefs.indexOf(ref);
                                if (selectedIndex > -1) {
                                    leftOver_1[selectedIndex] = item;
                                    selectionUpdated_2 = true;
                                }
                            });
                            // Filter out any unmatched items if we're using smart datagrids where we expect all items to be
                            // present
                            if (_this._items.smart) {
                                leftOver_1 = leftOver_1.filter(function (selected) { return updatedItems.indexOf(selected) > -1; });
                                if (_this.current.length !== leftOver_1.length) {
                                    selectionUpdated_2 = true;
                                }
                            }
                            // TODO: Discussed this with Eudes and this is fine for now.
                            // But we need to figure out a different pattern for the
                            // child triggering the parent change detection problem.
                            // Using setTimeout for now to fix this.
                            setTimeout(function () {
                                if (selectionUpdated_2) {
                                    _this.current = leftOver_1;
                                }
                            }, 0);
                        }
                        break;
                    }
                    default: {
                        break;
                    }
                }
                // Sync locked items
                _this.lockedRefs = updateLockedRef;
            }));
            this.subscriptions.push(this._valueCollector.pipe(operators.debounceTime(0)).subscribe(function () { return _this.emitChange(); }));
        }
        Selection.prototype.clearSelection = function () {
            this._current = [];
            this.prevSelectionRefs = [];
            this._currentSingle = null;
            this.prevSingleSelectionRef = null;
            this.emitChange();
        };
        Object.defineProperty(Selection.prototype, "selectionType", {
            get: function () {
                return this._selectionType;
            },
            set: function (value) {
                if (value === this.selectionType) {
                    return;
                }
                this._selectionType = value;
                if (value === SelectionType.None) {
                    delete this.current;
                }
                else {
                    this.updateCurrent([], false);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "_selectable", {
            get: function () {
                return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up our subscriptions to other providers
         */
        Selection.prototype.destroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        Object.defineProperty(Selection.prototype, "currentSingle", {
            get: function () {
                return this._currentSingle;
            },
            set: function (value) {
                var _this = this;
                if (value === this._currentSingle) {
                    return;
                }
                this._currentSingle = value;
                if (this._items.all && this._items.trackBy && value) {
                    var lookup = this._items.all.findIndex(function (maybe) { return maybe === value; });
                    this.prevSingleSelectionRef = this._items.trackBy(lookup, value);
                }
                this.emitChange();
                // This setTimeout makes sure that the change is
                // not emitted multiple times in the same change
                // detection cycle.
                this._zone.runOutsideAngular(function () {
                    if (!_this.debounce) {
                        _this.debounce = true;
                        setTimeout(function () { return (_this.debounce = false); });
                    }
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "current", {
            get: function () {
                return this._current;
            },
            set: function (value) {
                this.updateCurrent(value, true);
            },
            enumerable: true,
            configurable: true
        });
        Selection.prototype.updateCurrent = function (value, emit) {
            this._current = value;
            if (emit) {
                this._valueCollector.next(value);
            }
        };
        Selection.prototype.emitChange = function () {
            if (this._selectionType === SelectionType.Single) {
                this._change.next(this.currentSingle);
            }
            else if (this._selectionType === SelectionType.Multi) {
                this._change.next(this.current);
            }
        };
        Object.defineProperty(Selection.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if an item is currently selected
         */
        Selection.prototype.isSelected = function (item) {
            if (this._selectionType === SelectionType.Single) {
                return this.currentSingle === item;
            }
            else if (this._selectionType === SelectionType.Multi) {
                return this.current.indexOf(item) >= 0;
            }
            return false;
        };
        /**
         * Selects an item
         */
        Selection.prototype.selectItem = function (item) {
            this.current = this.current.concat(item);
            if (this._items.trackBy && this._items.all) {
                // Push selected ref onto array
                var lookup = this._items.all.findIndex(function (maybe) { return maybe === item; });
                this.prevSelectionRefs.push(this._items.trackBy(lookup, item));
            }
        };
        /**
         * Deselects an item
         */
        Selection.prototype.deselectItem = function (indexOfItem) {
            this.current = this.current.slice(0, indexOfItem).concat(this.current.slice(indexOfItem + 1));
            if (this._items.trackBy && indexOfItem < this.prevSelectionRefs.length) {
                // Keep selected refs array in sync
                var removedItems_1 = this.prevSelectionRefs.splice(indexOfItem, 1);
                // locked reference is no longer needed (if any)
                this.lockedRefs = this.lockedRefs.filter(function (locked) { return locked !== removedItems_1[0]; });
            }
        };
        /**
         * Selects or deselects an item
         */
        Selection.prototype.setSelected = function (item, selected) {
            switch (this._selectionType) {
                case SelectionType.None:
                    break;
                case SelectionType.Single:
                    // in single selection, set currentSingle method should be used
                    break;
                case SelectionType.Multi:
                    var index = this.current.indexOf(item);
                    if (index >= 0 && !selected) {
                        this.deselectItem(index);
                    }
                    else if (index < 0 && selected) {
                        this.selectItem(item);
                    }
                    break;
                default:
                    break;
            }
        };
        /**
         * Checks if all currently displayed items are selected
         */
        Selection.prototype.isAllSelected = function () {
            var _this = this;
            if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
                return false;
            }
            // make sure to exclude the locked items from the list when counting
            var displayedItems = this._items.displayed.filter(function (item) {
                return _this.isLocked(item) === false;
            });
            var nbDisplayed = displayedItems.length;
            if (nbDisplayed < 1) {
                return false;
            }
            var temp = displayedItems.filter(function (item) { return _this.current.indexOf(item) > -1; });
            return temp.length === displayedItems.length;
        };
        /**
         * Make sure that it could be locked
         *
         * @remark
         * Check also is items.all an array, if not there is no nothing to lock or compare to
         *
         */
        Selection.prototype.canItBeLocked = function () {
            // We depend on the trackBy and all so there are part of the requirment of is item could be locked
            return this._selectionType !== SelectionType.None && Array.isArray(this._items.all);
        };
        /**
         * Lock and unlock item
         */
        Selection.prototype.lockItem = function (item, lock) {
            if (this.canItBeLocked()) {
                var ref_1 = this._items.trackBy(this._items.all.findIndex(function (maybe) { return maybe === item; }), item);
                if (lock === true) {
                    // Add to lockedRef
                    this.lockedRefs.push(ref_1);
                }
                else {
                    // Remove from lockedRef
                    this.lockedRefs = this.lockedRefs.filter(function (lockedItem) { return ref_1 !== lockedItem; });
                }
            }
        };
        /**
         * Check is item locked or not by searcing into lockedRefs for entry
         */
        Selection.prototype.isLocked = function (item) {
            /**
             * The check for selectionType will boost the performence by NOT searching
             * into the array when there is no need for that.
             */
            if (this.canItBeLocked()) {
                var ref = this._items.trackBy(this._items.all.findIndex(function (maybe) { return maybe === item; }), item);
                return this.lockedRefs.indexOf(ref) > -1;
            }
            return false;
        };
        /**
         * Selects or deselects all currently displayed items
         */
        Selection.prototype.toggleAll = function () {
            var _this = this;
            if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
                return;
            }
            /**
             * If every currently displayed item is already selected, we clear them.
             * If at least one item isn't selected, we select every currently displayed item.
             */
            if (this.isAllSelected()) {
                this._items.displayed.forEach(function (item) {
                    var currentIndex = _this.current.indexOf(item);
                    if (currentIndex > -1 && _this.isLocked(item) === false) {
                        _this.deselectItem(currentIndex);
                    }
                });
            }
            else {
                this._items.displayed.forEach(function (item) {
                    if (_this.current.indexOf(item) < 0 && _this.isLocked(item) === false) {
                        _this.selectItem(item);
                    }
                });
            }
        };
        Selection.ctorParameters = function () { return [
            { type: Items },
            { type: FiltersProvider },
            { type: core.NgZone }
        ]; };
Selection.ɵfac = function Selection_Factory(t) { return new (t || Selection)(ɵngcc0.ɵɵinject(Items), ɵngcc0.ɵɵinject(FiltersProvider), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
Selection.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Selection, factory: function (t) { return Selection.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Selection, [{
        type: core.Injectable
    }], function () { return [{ type: Items }, { type: FiltersProvider }, { type: ɵngcc0.NgZone }]; }, null); })();
        return Selection;
    }());

    var WrappedRow = /** @class */ (function () {
        function WrappedRow() {
            this._dynamic = false;
        }
        WrappedRow.prototype.ngAfterViewInit = function () {
            // Create the cells view in memory, not the DOM.
            this.rowView = this.templateRef.createEmbeddedView(null);
        };
        WrappedRow.prototype.ngOnDestroy = function () {
            this.rowView.destroy();
        };
        __decorate([
            core.ViewChild('rowPortal')
        ], WrappedRow.prototype, "templateRef", void 0);
WrappedRow.ɵfac = function WrappedRow_Factory(t) { return new (t || WrappedRow)(); };
WrappedRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WrappedRow, selectors: [["dg-wrapped-row"]], viewQuery: function WrappedRow_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c35, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, ngContentSelectors: _c1, decls: 2, vars: 0, consts: [["rowPortal", ""]], template: function WrappedRow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, WrappedRow_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WrappedRow, [{
        type: core.Component,
        args: [{
                selector: 'dg-wrapped-row',
                template: "\n        <ng-template #rowPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
            }]
    }], function () { return []; }, { templateRef: [{
            type: core.ViewChild,
            args: ['rowPortal']
        }] }); })();
        return WrappedRow;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var nbRow = 0;
    var DatagridIfExpandService = /** @class */ (function (_super) {
        __extends(DatagridIfExpandService, _super);
        function DatagridIfExpandService() {
            var _this = _super.call(this) || this;
            _this.expandableId = '';
            _this._replace = new rxjs.BehaviorSubject(false);
            _this._animate = new rxjs.Subject();
            nbRow++;
            _this.expandableId = 'clr-dg-expandable-row-' + nbRow;
            return _this;
        }
        Object.defineProperty(DatagridIfExpandService.prototype, "expanded", {
            // due to the es5 spec if the set is overridden on base class the getter must also be overridden
            get: function () {
                return this._expanded;
            },
            set: function (value) {
                value = !!value;
                if (value !== this._expanded) {
                    this._expanded = value;
                    this._animate.next();
                    this._expandChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        DatagridIfExpandService.prototype.loadingStateChange = function (state) {
            _super.prototype.loadingStateChange.call(this, state);
            if (state !== exports.ClrLoadingState.LOADING) {
                this._animate.next();
            }
        };
        Object.defineProperty(DatagridIfExpandService.prototype, "replace", {
            get: function () {
                return this._replace.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DatagridIfExpandService.prototype.setReplace = function (replaceValue) {
            this._replace.next(replaceValue);
        };
        Object.defineProperty(DatagridIfExpandService.prototype, "animate", {
            get: function () {
                return this._animate.asObservable();
            },
            enumerable: true,
            configurable: true
        });
DatagridIfExpandService.ɵfac = function DatagridIfExpandService_Factory(t) { return new (t || DatagridIfExpandService)(); };
DatagridIfExpandService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DatagridIfExpandService, factory: function (t) { return DatagridIfExpandService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridIfExpandService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return DatagridIfExpandService;
    }(IfExpandService));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var nbRow$1 = 0;
    var ClrDatagridRow = /** @class */ (function () {
        function ClrDatagridRow(selection, rowActionService, globalExpandable, expand, detailService, displayMode, vcr, renderer, el, commonStrings) {
            var _this = this;
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.globalExpandable = globalExpandable;
            this.expand = expand;
            this.detailService = detailService;
            this.displayMode = displayMode;
            this.vcr = vcr;
            this.renderer = renderer;
            this.el = el;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
            this.expandAnimationTrigger = false;
            this._selected = false;
            this.selectedChanged = new core.EventEmitter(false);
            this.expandedChange = new core.EventEmitter(false);
            this._detailOpenLabel = '';
            this._detailCloseLabel = '';
            this.subscriptions = [];
            this.displayCells = false;
            nbRow$1++;
            this.id = 'clr-dg-row' + nbRow$1;
            this.radioId = 'clr-dg-row-rd' + nbRow$1;
            this.checkboxId = 'clr-dg-row-cb' + nbRow$1;
            this.expandableId = expand.expandableId;
            this.subscriptions.push(rxjs.combineLatest(this.expand.replace, this.expand.expandChange).subscribe(function (_a) {
                var _b = __read(_a, 2), expandReplaceValue = _b[0], expandChangeValue = _b[1];
                if (expandReplaceValue && expandChangeValue) {
                    // replaced and expanding
                    _this.replaced = true;
                    _this.renderer.addClass(_this.el.nativeElement, 'datagrid-row-replaced');
                }
                else {
                    _this.replaced = false;
                    // Handles these cases: not replaced and collapsing & replaced and
                    // collapsing and not replaced and expanding.
                    _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-row-replaced');
                }
            }));
        }
        Object.defineProperty(ClrDatagridRow.prototype, "selected", {
            /**
             * Indicates if the row is selected
             */
            get: function () {
                if (this.selection.selectionType === SelectionType.None) {
                    return this._selected;
                }
                else {
                    return this.selection.isSelected(this.item);
                }
            },
            set: function (value) {
                if (this.selection.selectionType === SelectionType.None) {
                    this._selected = value;
                }
                else {
                    this.selection.setSelected(this.item, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridRow.prototype, "clrDgSelectable", {
            get: function () {
                return !this.selection.isLocked(this.item);
            },
            // By default every item is selectable
            set: function (value) {
                this.selection.lockItem(this.item, value === false);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRow.prototype.toggle = function (selected) {
            if (selected === void 0) { selected = !this.selected; }
            if (selected !== this.selected) {
                this.selected = selected;
                this.selectedChanged.emit(selected);
            }
        };
        Object.defineProperty(ClrDatagridRow.prototype, "expanded", {
            get: function () {
                return this.expand.expanded;
            },
            set: function (value) {
                this.expand.expanded = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRow.prototype.toggleExpand = function () {
            if (this.expand.expandable) {
                this.expandAnimation.updateStartHeight();
                this.expanded = !this.expanded;
                this.expandedChange.emit(this.expanded);
            }
        };
        Object.defineProperty(ClrDatagridRow.prototype, "clrDgDetailOpenLabel", {
            get: function () {
                return this._detailOpenLabel ? this._detailOpenLabel : this.commonStrings.keys.open;
            },
            set: function (label) {
                this._detailOpenLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridRow.prototype, "clrDgDetailCloseLabel", {
            get: function () {
                return this._detailCloseLabel ? this._detailCloseLabel : this.commonStrings.keys.close;
            },
            set: function (label) {
                this._detailCloseLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRow.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.dgCells.changes.subscribe(function () {
                _this.dgCells.forEach(function (cell) {
                    if (!cell._view.destroyed) {
                        _this._scrollableCells.insert(cell._view);
                    }
                });
            });
        };
        ClrDatagridRow.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.subscriptions.push(this.displayMode.view.subscribe(function (viewChange) {
                // Listen for view changes and move cells around depending on the current displayType
                // remove cell views from display view
                for (var i = _this._scrollableCells.length; i > 0; i--) {
                    _this._scrollableCells.detach();
                }
                // remove cell views from calculated view
                for (var i = _this._calculatedCells.length; i > 0; i--) {
                    _this._calculatedCells.detach();
                }
                if (viewChange === DatagridDisplayMode.CALCULATE) {
                    _this.displayCells = false;
                    _this.dgCells.forEach(function (cell) {
                        if (!cell._view.destroyed) {
                            _this._calculatedCells.insert(cell._view);
                        }
                    });
                }
                else {
                    _this.displayCells = true;
                    _this.dgCells.forEach(function (cell) {
                        if (!cell._view.destroyed) {
                            _this._scrollableCells.insert(cell._view);
                        }
                    });
                }
            }), this.expand.animate.subscribe(function () {
                _this.expandAnimationTrigger = !_this.expandAnimationTrigger;
            }));
        };
        ClrDatagridRow.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDatagridRow.prototype.ngOnInit = function () {
            this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
        };
        Object.defineProperty(ClrDatagridRow.prototype, "_view", {
            get: function () {
                return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRow.ctorParameters = function () { return [
            { type: Selection },
            { type: RowActionService },
            { type: ExpandableRowsCount },
            { type: DatagridIfExpandService },
            { type: DetailService },
            { type: DisplayModeService },
            { type: core.ViewContainerRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.ViewChild(ClrExpandableAnimation)
        ], ClrDatagridRow.prototype, "expandAnimation", void 0);
        __decorate([
            core.Input('clrDgItem')
        ], ClrDatagridRow.prototype, "item", void 0);
        __decorate([
            core.Input('clrDgSelected')
        ], ClrDatagridRow.prototype, "selected", null);
        __decorate([
            core.Input('clrDgSelectable')
        ], ClrDatagridRow.prototype, "clrDgSelectable", null);
        __decorate([
            core.Output('clrDgSelectedChange')
        ], ClrDatagridRow.prototype, "selectedChanged", void 0);
        __decorate([
            core.Input('clrDgExpanded')
        ], ClrDatagridRow.prototype, "expanded", null);
        __decorate([
            core.Output('clrDgExpandedChange')
        ], ClrDatagridRow.prototype, "expandedChange", void 0);
        __decorate([
            core.ViewChild('detailButton')
        ], ClrDatagridRow.prototype, "detailButton", void 0);
        __decorate([
            core.Input()
        ], ClrDatagridRow.prototype, "clrDgDetailOpenLabel", null);
        __decorate([
            core.Input()
        ], ClrDatagridRow.prototype, "clrDgDetailCloseLabel", null);
        __decorate([
            core.ContentChildren(ClrDatagridCell)
        ], ClrDatagridRow.prototype, "dgCells", void 0);
        __decorate([
            core.ViewChild('stickyCells', { read: core.ViewContainerRef })
        ], ClrDatagridRow.prototype, "_stickyCells", void 0);
        __decorate([
            core.ViewChild('scrollableCells', { read: core.ViewContainerRef })
        ], ClrDatagridRow.prototype, "_scrollableCells", void 0);
        __decorate([
            core.ViewChild('calculatedCells', { read: core.ViewContainerRef })
        ], ClrDatagridRow.prototype, "_calculatedCells", void 0);
ClrDatagridRow.ɵfac = function ClrDatagridRow_Factory(t) { return new (t || ClrDatagridRow)(ɵngcc0.ɵɵdirectiveInject(Selection), ɵngcc0.ɵɵdirectiveInject(RowActionService), ɵngcc0.ɵɵdirectiveInject(ExpandableRowsCount), ɵngcc0.ɵɵdirectiveInject(DatagridIfExpandService), ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(DisplayModeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrDatagridRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridRow, selectors: [["clr-dg-row"]], contentQueries: function ClrDatagridRow_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridCell, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dgCells = _t);
    } }, viewQuery: function ClrDatagridRow_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ClrExpandableAnimation, true);
        ɵngcc0.ɵɵviewQuery(_c36, true);
        ɵngcc0.ɵɵviewQuery(_c37, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c38, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c39, true, core.ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expandAnimation = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.detailButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._stickyCells = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._scrollableCells = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._calculatedCells = _t.first);
    } }, hostAttrs: ["role", "rowgroup"], hostVars: 5, hostBindings: function ClrDatagridRow_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-owns", ctx.id);
        ɵngcc0.ɵɵclassProp("datagrid-row", true)("datagrid-selected", ctx.selected);
    } }, inputs: { selected: ["clrDgSelected", "selected"], clrDgSelectable: "clrDgSelectable", expanded: ["clrDgExpanded", "expanded"], clrDgDetailOpenLabel: "clrDgDetailOpenLabel", clrDgDetailCloseLabel: "clrDgDetailCloseLabel", item: ["clrDgItem", "item"] }, outputs: { selectedChanged: "clrDgSelectedChange", expandedChange: "clrDgExpandedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            DatagridIfExpandService,
            { provide: IfExpandService, useExisting: DatagridIfExpandService },
            { provide: LoadingListener, useExisting: DatagridIfExpandService },
        ])], ngContentSelectors: _c43, decls: 9, vars: 3, consts: [["class", "datagrid-row-clickable", 4, "ngIf"], [3, "clrExpandTrigger", 4, "ngIf"], [4, "ngIf"], ["detail", ""], ["rowContent", ""], ["calculatedCells", ""], [1, "datagrid-row-clickable"], [3, "clrExpandTrigger"], [3, "ngTemplateOutlet"], ["role", "row", 1, "datagrid-row-master", "datagrid-row-flex", 3, "id"], [1, "datagrid-row-sticky"], ["stickyCells", ""], ["class", "datagrid-select datagrid-fixed-column datagrid-cell", "role", "gridcell", 3, "ngClass", 4, "ngIf"], ["class", "datagrid-row-actions datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], ["class", "datagrid-expandable-caret datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], ["class", "datagrid-detail-caret datagrid-fixed-column datagrid-cell", 4, "ngIf"], [1, "datagrid-row-scrollable", 3, "ngClass"], [1, "datagrid-scrolling-cells"], ["scrollableCells", ""], ["role", "gridcell", 1, "datagrid-select", "datagrid-fixed-column", "datagrid-cell", 3, "ngClass"], ["clrCheckbox", "", "type", "checkbox", 3, "ngModel", "id", "ngModelChange"], ["type", "radio", "clrRadio", "", 3, "id", "name", "value", "ngModel", "checked", "ngModelChange"], ["role", "gridcell", 1, "datagrid-row-actions", "datagrid-fixed-column", "datagrid-cell"], ["role", "gridcell", 1, "datagrid-expandable-caret", "datagrid-fixed-column", "datagrid-cell"], ["type", "button", "class", "datagrid-expandable-caret-button", 3, "click", 4, "ngIf"], ["clrSmall", "", 4, "ngIf"], ["type", "button", 1, "datagrid-expandable-caret-button", 3, "click"], ["shape", "caret", 1, "datagrid-expandable-caret-icon"], ["clrSmall", ""], [1, "datagrid-detail-caret", "datagrid-fixed-column", "datagrid-cell"], ["type", "button", "aria-haspopup", "dialog", 1, "datagrid-detail-caret-button", 3, "click"], ["detailButton", ""], ["shape", "angle-double", 1, "datagrid-detail-caret-icon"]], template: function ClrDatagridRow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c42);
        ɵngcc0.ɵɵtemplate(0, ClrDatagridRow_label_0_Template, 3, 2, "label", 0);
        ɵngcc0.ɵɵtemplate(1, ClrDatagridRow_clr_expandable_animation_1_Template, 2, 2, "clr-expandable-animation", 1);
        ɵngcc0.ɵɵtemplate(2, ClrDatagridRow_2_Template, 1, 1, undefined, 2);
        ɵngcc0.ɵɵtemplate(3, ClrDatagridRow_ng_template_3_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, ClrDatagridRow_ng_template_5_Template, 16, 13, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainer(7, null, 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection.rowSelectionMode);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.selection.rowSelectionMode && ctx.expand.expandable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.selection.rowSelectionMode && !ctx.expand.expandable);
    } }, directives: [ɵngcc1.NgIf, ClrLabel,
        ClrExpandableAnimation, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass, ɵngcc2.CheckboxControlValueAccessor, ClrCheckbox, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ɵngcc2.RadioControlValueAccessor, ɵngcc2.DefaultValueAccessor, ClrRadio,
        ClrIconCustomTag,
        ClrSpinner], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridRow, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-row',
                template: "<!--\n  We need to wrap the #rowContent in label element if we are in rowSelectionMode.\n  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.\n-->\n<label class=\"datagrid-row-clickable\" *ngIf=\"selection.rowSelectionMode\">\n  <clr-expandable-animation [clrExpandTrigger]=\"expandAnimationTrigger\" *ngIf=\"expand.expandable\">\n    <ng-template [ngTemplateOutlet]=\"rowContent\"></ng-template>\n  </clr-expandable-animation>\n  <ng-template [ngTemplateOutlet]=\"rowContent\" *ngIf=\"!expand.expandable\"></ng-template>\n</label>\n\n<clr-expandable-animation *ngIf=\"!selection.rowSelectionMode && expand.expandable\" [clrExpandTrigger]=\"expandAnimationTrigger\">\n  <ng-template [ngTemplateOutlet]=\"rowContent\"></ng-template>\n</clr-expandable-animation>\n\n<ng-template *ngIf=\"!selection.rowSelectionMode && !expand.expandable\" [ngTemplateOutlet]=\"rowContent\"></ng-template>\n\n<!--\n    We need the \"project into template\" hacks because we need this in 2 different places\n    depending on whether the details replace the row or not.\n-->\n<ng-template #detail>\n  <ng-content select=\"clr-dg-row-detail\"></ng-content>\n</ng-template>\n\n<ng-template #rowContent>\n  <div role=\"row\" [id]=\"id\" class=\"datagrid-row-master datagrid-row-flex\" [class.datagrid-row-detail-open]=\"detailService.isRowOpen(item)\">\n  <div class=\"datagrid-row-sticky\">\n      <!-- Sticky elements here -->\n      <ng-container #stickyCells>\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\"\n             [ngClass]=\"{ 'clr-form-control-disabled': !clrDgSelectable }\"\n             role=\"gridcell\">\n\n          <input clrCheckbox type=\"checkbox\" [ngModel]=\"selected\" (ngModelChange)=\"toggle($event)\" [id]=\"checkboxId\"\n                 [attr.disabled]=\"clrDgSelectable ? null : true\"\n                 [attr.aria-disabled]=\"clrDgSelectable ? null : true\"\n                 [attr.aria-label]=\"commonStrings.keys.select\">\n        </div>\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\" role=\"gridcell\"\n             [ngClass]=\"{ 'clr-form-control-disabled': !clrDgSelectable }\"\n        >\n          <!-- TODO: it would be better if in addition to the generic \"Select\" label, we could add aria-labelledby\n          to label the radio by the first cell in the row (typically an id or name).\n          It's pretty easy to label it with the whole row since we already have an id for it, but in most\n          cases the row is far too long to serve as a label, the screenreader reads every single cell content. -->\n          <input type=\"radio\" clrRadio [id]=\"radioId\" [name]=\"selection.id + '-radio'\" [value]=\"item\"\n                 [(ngModel)]=\"selection.currentSingle\" [checked]=\"selection.currentSingle === item\"\n                 [attr.disabled]=\"clrDgSelectable ? null : true\"\n                 [attr.aria-disabled]=\"clrDgSelectable ? null : true\"\n                 [attr.aria-label]=\"commonStrings.keys.select\">\n        </div>\n        <div *ngIf=\"rowActionService.hasActionableRow\"\n             class=\"datagrid-row-actions datagrid-fixed-column datagrid-cell\" role=\"gridcell\">\n          <ng-content select=\"clr-dg-action-overflow\"></ng-content>\n        </div>\n        <div *ngIf=\"globalExpandable.hasExpandableRow\"\n             class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\" role=\"gridcell\">\n          <ng-container *ngIf=\"expand.expandable\">\n            <button\n              *ngIf=\"!expand.loading\"\n              (click)=\"toggleExpand()\"\n              type=\"button\"\n              class=\"datagrid-expandable-caret-button\"\n              [attr.aria-expanded]=\"expand.expanded\"\n              [attr.aria-label]=\"expand.expanded ? clrDgDetailCloseLabel : clrDgDetailOpenLabel\"\n              [attr.aria-controls]=\"expandableId\"\n              >\n              <clr-icon shape=\"caret\"\n                        class=\"datagrid-expandable-caret-icon\"\n                        [attr.dir]=\"expand.expanded ? 'down' : 'right'\"\n                        [attr.title]=\"expand.expanded ? commonStrings.keys.collapse : commonStrings.keys.expand\"></clr-icon>\n            </button>\n            <clr-spinner *ngIf=\"expand.loading\" clrSmall>{{ commonStrings.keys.loading }}</clr-spinner>\n          </ng-container>\n        </div>\n        <div *ngIf=\"detailService.enabled\"\n             class=\"datagrid-detail-caret datagrid-fixed-column datagrid-cell\">\n          <button (click)=\"detailService.toggle(item, detailButton)\" type=\"button\" #detailButton class=\"datagrid-detail-caret-button\"\n                  [class.is-open]=\"detailService.isRowOpen(item)\" [attr.aria-label]=\"detailService.isOpen ? clrDgDetailCloseLabel : clrDgDetailOpenLabel\"\n                  [attr.aria-expanded]=\"detailService.isOpen\" [attr.aria-controls]=\"detailService.id\" aria-haspopup=\"dialog\">\n            <clr-icon shape=\"angle-double\"\n                      [attr.dir]=\"detailService.isRowOpen(item) ? 'left' : 'right'\"\n                      class=\"datagrid-detail-caret-icon\"\n                      [attr.title]=\"detailService.isRowOpen(item) ? commonStrings.keys.close: commonStrings.keys.open\"></clr-icon>\n          </button>\n        </div>\n      </ng-container> <!-- placeholder for projecting other sticky cells as pinned-->\n    </div>\n    <div class=\"datagrid-row-scrollable\" [ngClass]=\"{'is-replaced': replaced && expanded}\">\n      <div class=\"datagrid-scrolling-cells\">\n        <ng-content select=\"clr-dg-cell\"></ng-content>\n        <ng-container #scrollableCells></ng-container>\n      </div>\n      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->\n      <ng-template *ngIf=\"replaced && !expand.loading\"\n                   [ngTemplateOutlet]=\"detail\"></ng-template>\n      <ng-template *ngIf=\"!replaced && !expand.loading\"\n                   [ngTemplateOutlet]=\"detail\"></ng-template>\n    </div>\n  </div>\n</ng-template>\n\n<ng-container #calculatedCells></ng-container>\n",
                host: {
                    '[class.datagrid-row]': 'true',
                    '[class.datagrid-selected]': 'selected',
                    '[attr.aria-owns]': 'id',
                    role: 'rowgroup'
                },
                providers: [
                    DatagridIfExpandService,
                    { provide: IfExpandService, useExisting: DatagridIfExpandService },
                    { provide: LoadingListener, useExisting: DatagridIfExpandService },
                ]
            }]
    }], function () { return [{ type: Selection }, { type: RowActionService }, { type: ExpandableRowsCount }, { type: DatagridIfExpandService }, { type: DetailService }, { type: DisplayModeService }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ClrCommonStringsService }]; }, { selectedChanged: [{
            type: core.Output,
            args: ['clrDgSelectedChange']
        }], expandedChange: [{
            type: core.Output,
            args: ['clrDgExpandedChange']
        }], selected: [{
            type: core.Input,
            args: ['clrDgSelected']
        }], clrDgSelectable: [{
            type: core.Input,
            args: ['clrDgSelectable']
        }], expanded: [{
            type: core.Input,
            args: ['clrDgExpanded']
        }], clrDgDetailOpenLabel: [{
            type: core.Input
        }], clrDgDetailCloseLabel: [{
            type: core.Input
        }], expandAnimation: [{
            type: core.ViewChild,
            args: [ClrExpandableAnimation]
        }], item: [{
            type: core.Input,
            args: ['clrDgItem']
        }], detailButton: [{
            type: core.ViewChild,
            args: ['detailButton']
        }], dgCells: [{
            type: core.ContentChildren,
            args: [ClrDatagridCell]
        }], _stickyCells: [{
            type: core.ViewChild,
            args: ['stickyCells', { read: core.ViewContainerRef }]
        }], _scrollableCells: [{
            type: core.ViewChild,
            args: ['scrollableCells', { read: core.ViewContainerRef }]
        }], _calculatedCells: [{
            type: core.ViewChild,
            args: ['calculatedCells', { read: core.ViewContainerRef }]
        }] }); })();
        return ClrDatagridRow;
    }());

    /**
     * This provider aggregates state changes from the various providers of the Datagrid
     */
    var StateProvider = /** @class */ (function () {
        function StateProvider(filters, sort, page, debouncer) {
            var _this = this;
            this.filters = filters;
            this.sort = sort;
            this.page = page;
            this.debouncer = debouncer;
            /**
             * The Observable that lets other classes subscribe to global state changes
             */
            this.change = this.debouncer.change.pipe(operators.map(function () { return _this.state; }));
        }
        Object.defineProperty(StateProvider.prototype, "state", {
            /*
               * By making this a getter, we open the possibility for a setter in the future.
               * It's been requested a couple times.
               */
            get: function () {
                var e_1, _a;
                var state = {};
                if (this.page.size > 0) {
                    state.page = {
                        from: this.page.firstItem,
                        to: this.page.lastItem,
                        size: this.page.size,
                        current: this.page.current,
                    };
                }
                if (this.sort.comparator) {
                    if (this.sort.comparator instanceof DatagridPropertyComparator) {
                        /*
                                 * Special case for the default object property comparator,
                                 * we give the property name instead of the actual comparator.
                                 */
                        state.sort = { by: this.sort.comparator.prop, reverse: this.sort.reverse };
                    }
                    else {
                        state.sort = { by: this.sort.comparator, reverse: this.sort.reverse };
                    }
                }
                var activeFilters = this.filters.getActiveFilters();
                if (activeFilters.length > 0) {
                    state.filters = [];
                    try {
                        for (var activeFilters_1 = __values(activeFilters), activeFilters_1_1 = activeFilters_1.next(); !activeFilters_1_1.done; activeFilters_1_1 = activeFilters_1.next()) {
                            var filter = activeFilters_1_1.value;
                            if (filter.state) {
                                state.filters.push(filter.state);
                            }
                            else {
                                state.filters.push(filter);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (activeFilters_1_1 && !activeFilters_1_1.done && (_a = activeFilters_1.return)) _a.call(activeFilters_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return state;
            },
            enumerable: true,
            configurable: true
        });
        StateProvider.ctorParameters = function () { return [
            { type: FiltersProvider },
            { type: Sort },
            { type: Page },
            { type: StateDebouncer }
        ]; };
StateProvider.ɵfac = function StateProvider_Factory(t) { return new (t || StateProvider)(ɵngcc0.ɵɵinject(FiltersProvider), ɵngcc0.ɵɵinject(Sort), ɵngcc0.ɵɵinject(Page), ɵngcc0.ɵɵinject(StateDebouncer)); };
StateProvider.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: StateProvider, factory: function (t) { return StateProvider.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StateProvider, [{
        type: core.Injectable
    }], function () { return [{ type: FiltersProvider }, { type: Sort }, { type: Page }, { type: StateDebouncer }]; }, null); })();
        return StateProvider;
    }());

    /**
     * @description
     * Internal datagrid service that holds a reference to the clr-dg-table element and exposes a method to get height.
     */
    var TableSizeService = /** @class */ (function () {
        function TableSizeService(platformId) {
            this.platformId = platformId;
        }
        Object.defineProperty(TableSizeService.prototype, "tableRef", {
            get: function () {
                return this._tableRef;
            },
            set: function (element) {
                this._tableRef = element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableSizeService.prototype, "table", {
            set: function (table) {
                if (common.isPlatformBrowser(this.platformId) && table.nativeElement) {
                    this.tableRef = table.nativeElement.querySelector('.datagrid-table');
                }
            },
            enumerable: true,
            configurable: true
        });
        // Used when resizing columns to show the column border being dragged.
        TableSizeService.prototype.getColumnDragHeight = function () {
            if (!this.tableRef) {
                return;
            }
            return this.tableRef.clientHeight + "px";
        };
        TableSizeService.ctorParameters = function () { return [
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        TableSizeService = __decorate([ __param(0, core.Inject(core.PLATFORM_ID))
        ], TableSizeService);
TableSizeService.ɵfac = function TableSizeService_Factory(t) { return new (t || TableSizeService)(ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
TableSizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TableSizeService, factory: function (t) { return TableSizeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TableSizeService, [{
        type: core.Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return TableSizeService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DatagridColumnChanges;
    (function (DatagridColumnChanges) {
        DatagridColumnChanges[DatagridColumnChanges["WIDTH"] = 0] = "WIDTH";
        DatagridColumnChanges[DatagridColumnChanges["HIDDEN"] = 1] = "HIDDEN";
    })(DatagridColumnChanges || (DatagridColumnChanges = {}));
    var ɵ1 = function (key) { return DatagridColumnChanges[key]; }, ɵ0 = function (key) { return key === parseInt(key, 10); };
    var ALL_COLUMN_CHANGES = Object.keys(DatagridColumnChanges)
        .map(ɵ1)
        .filter(ɵ0); // extracts only integer keys

    var ColumnsService = /** @class */ (function () {
        function ColumnsService() {
            this.columns = [];
            this._cache = [];
        }
        ColumnsService.prototype.cache = function () {
            this._cache = this.columns.map(function (subject) {
                var value = __assign({}, subject.value);
                delete value.changes;
                return value;
            });
        };
        ColumnsService.prototype.hasCache = function () {
            return !!this._cache.length;
        };
        ColumnsService.prototype.resetToLastCache = function () {
            var _this = this;
            this._cache.forEach(function (state, index) {
                // Just emit the exact value from the cache
                _this.columns[index].next(__assign(__assign({}, state), { changes: ALL_COLUMN_CHANGES }));
            });
            this._cache = [];
        };
        Object.defineProperty(ColumnsService.prototype, "columnStates", {
            get: function () {
                return this.columns.map(function (column) { return column.value; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnsService.prototype, "hasHideableColumns", {
            get: function () {
                return this.columnStates.filter(function (state) { return state.hideable; }).length > 0;
            },
            enumerable: true,
            configurable: true
        });
        // Helper method to emit a change to a column only when there is an actual diff to process for that column
        ColumnsService.prototype.emitStateChangeAt = function (columnIndex, diff) {
            if (!this.columns[columnIndex]) {
                return;
            }
            this.emitStateChange(this.columns[columnIndex], diff);
        };
        ColumnsService.prototype.emitStateChange = function (column, diff) {
            column.next(__assign(__assign({}, column.value), diff));
        };
ColumnsService.ɵfac = function ColumnsService_Factory(t) { return new (t || ColumnsService)(); };
ColumnsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnsService, factory: function (t) { return ColumnsService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnsService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ColumnsService;
    }());

    var ClrDatagrid = /** @class */ (function () {
        function ClrDatagrid(organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, detailService, datagridId, el, page, commonStrings) {
            this.organizer = organizer;
            this.items = items;
            this.expandableRows = expandableRows;
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.stateProvider = stateProvider;
            this.displayMode = displayMode;
            this.renderer = renderer;
            this.detailService = detailService;
            this.el = el;
            this.page = page;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
            /**
             * Output emitted whenever the data needs to be refreshed, based on user action or external ones
             */
            this.refresh = new core.EventEmitter(false);
            this.selectedChanged = new core.EventEmitter(false);
            this.singleSelectedChanged = new core.EventEmitter(false);
            this.clrDgSingleSelectionAriaLabel = this.commonStrings.keys.singleSelectionAriaLabel;
            this.clrDgSingleActionableAriaLabel = this.commonStrings.keys.singleActionableAriaLabel;
            this.clrDetailExpandableAriaLabel = this.commonStrings.keys.detailExpandableAriaLabel;
            // Allows disabling of the auto focus on page/state changes (excludes focus management inside of popups)
            this.clrDgDisablePageFocus = false;
            /**
             * Subscriptions to all the services and queries changes
             */
            this._subscriptions = [];
            this.detailService.id = datagridId;
        }
        Object.defineProperty(ClrDatagrid.prototype, "loading", {
            /**
             * Freezes the datagrid while data is loading
             */
            get: function () {
                return this.items.loading;
            },
            set: function (value) {
                this.items.loading = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Public method to re-trigger the computation of displayed items manually
         */
        ClrDatagrid.prototype.dataChanged = function () {
            this.items.refresh();
        };
        Object.defineProperty(ClrDatagrid.prototype, "selected", {
            /**
             * Array of all selected items
             */
            set: function (value) {
                if (value) {
                    this.selection.selectionType = SelectionType.Multi;
                }
                else {
                    this.selection.selectionType = SelectionType.None;
                }
                this.selection.updateCurrent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "singleSelected", {
            /**
             * Selected item in single-select mode
             */
            set: function (value) {
                this.selection.selectionType = SelectionType.Single;
                // the clrDgSingleSelected is updated in one of two cases:
                // 1. an explicit value is passed
                // 2. is being set to null or undefined, where previously it had a value
                if (value) {
                    this.selection.currentSingle = value;
                }
                else if (this.selection.currentSingle) {
                    this.selection.currentSingle = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "clrDgPreserveSelection", {
            set: function (state) {
                this.selection.preserveSelection = state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "rowSelectionMode", {
            /**
             * @deprecated since 2.0, remove in 3.0
             *
             * Selection/Deselection on row click mode
             */
            set: function (value) {
                this.selection.rowSelectionMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "allSelected", {
            /**
             * Indicates if all currently displayed items are selected
             */
            get: function () {
                return this.selection.isAllSelected();
            },
            /**
             * Selects/deselects all currently displayed items
             * @param value
             */
            set: function (value) {
                /**
                 * This is a setter but we ignore the value.
                 * It's strange, but it lets us have an indeterminate state where only
                 * some of the items are selected.
                 */
                this.selection.toggleAll();
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagrid.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.items.smart) {
                this.items.all = this.rows.map(function (row) { return row.item; });
            }
            this._subscriptions.push(this.rows.changes.subscribe(function () {
                if (!_this.items.smart) {
                    _this.items.all = _this.rows.map(function (row) { return row.item; });
                }
                // Remove any projected rows from the displayedRows container
                // Necessary with Ivy off. See https://github.com/vmware/clarity/issues/4692
                for (var i = _this._displayedRows.length - 1; i >= 0; i--) {
                    if (_this._displayedRows.get(i).destroyed) {
                        _this._displayedRows.remove(i);
                    }
                }
                _this.rows.forEach(function (row) {
                    _this._displayedRows.insert(row._view);
                });
                // Try to update only when there is something cached and its open.
                if (_this.detailService.state && _this.detailService.isOpen) {
                    var foundRow = _this.rows.find(function (row, index) {
                        return _this.items.trackBy(index, row.item) === _this.items.trackBy(index, _this.detailService.state);
                    });
                    /**
                     * Reopen updated row or close it
                     */
                    foundRow ? _this.detailService.open(foundRow.item, foundRow.detailButton) : _this.detailService.close();
                }
            }));
        };
        /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         */
        ClrDatagrid.prototype.ngAfterViewInit = function () {
            var _this = this;
            // TODO: determine if we can get rid of provider wiring in view init so that subscriptions can be done earlier
            this.refresh.emit(this.stateProvider.state);
            this._subscriptions.push(this.stateProvider.change.subscribe(function (state) { return _this.refresh.emit(state); }), this.selection.change.subscribe(function (s) {
                if (_this.selection.selectionType === SelectionType.Single) {
                    _this.singleSelectedChanged.emit(s);
                }
                else if (_this.selection.selectionType === SelectionType.Multi) {
                    _this.selectedChanged.emit(s);
                }
            }), this.page.change.subscribe(function () {
                if (!_this.clrDgDisablePageFocus) {
                    _this.datagridTable.nativeElement.focus();
                }
            }), 
            // A subscription that listens for displayMode changes on the datagrid
            this.displayMode.view.subscribe(function (viewChange) {
                // Remove any projected columns from the projectedDisplayColumns container
                for (var i = _this._projectedDisplayColumns.length; i > 0; i--) {
                    _this._projectedDisplayColumns.detach();
                }
                // Remove any projected columns from the projectedCalculationColumns container
                for (var i = _this._projectedCalculationColumns.length; i > 0; i--) {
                    _this._projectedCalculationColumns.detach();
                }
                // Remove any projected rows from the calculationRows container
                for (var i = _this._calculationRows.length; i > 0; i--) {
                    _this._calculationRows.detach();
                }
                // Remove any projected rows from the displayedRows container
                for (var i = _this._displayedRows.length; i > 0; i--) {
                    _this._displayedRows.detach();
                }
                if (viewChange === DatagridDisplayMode.DISPLAY) {
                    // Set state, style for the datagrid to DISPLAY and insert row & columns into containers
                    _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                    _this.columns.forEach(function (column) {
                        _this._projectedDisplayColumns.insert(column._view);
                    });
                    _this.rows.forEach(function (row) {
                        _this._displayedRows.insert(row._view);
                    });
                }
                else {
                    // Set state, style for the datagrid to CALCULATE and insert row & columns into containers
                    _this.renderer.addClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                    _this.columns.forEach(function (column) {
                        _this._projectedCalculationColumns.insert(column._view);
                    });
                    _this.rows.forEach(function (row) {
                        _this._calculationRows.insert(row._view);
                    });
                }
            }));
        };
        ClrDatagrid.prototype.ngOnDestroy = function () {
            this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDatagrid.prototype.resize = function () {
            this.organizer.resize();
        };
        ClrDatagrid.ctorParameters = function () { return [
            { type: DatagridRenderOrganizer },
            { type: Items },
            { type: ExpandableRowsCount },
            { type: Selection },
            { type: RowActionService },
            { type: StateProvider },
            { type: DisplayModeService },
            { type: core.Renderer2 },
            { type: DetailService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: core.ElementRef },
            { type: Page },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.Input('clrDgLoading')
        ], ClrDatagrid.prototype, "loading", null);
        __decorate([
            core.Output('clrDgRefresh')
        ], ClrDatagrid.prototype, "refresh", void 0);
        __decorate([
            core.ContentChild(ClrDatagridItems)
        ], ClrDatagrid.prototype, "iterator", void 0);
        __decorate([
            core.Input('clrDgSelected')
        ], ClrDatagrid.prototype, "selected", null);
        __decorate([
            core.Output('clrDgSelectedChange')
        ], ClrDatagrid.prototype, "selectedChanged", void 0);
        __decorate([
            core.Input('clrDgSingleSelected')
        ], ClrDatagrid.prototype, "singleSelected", null);
        __decorate([
            core.Output('clrDgSingleSelectedChange')
        ], ClrDatagrid.prototype, "singleSelectedChanged", void 0);
        __decorate([
            core.Input()
        ], ClrDatagrid.prototype, "clrDgSingleSelectionAriaLabel", void 0);
        __decorate([
            core.Input()
        ], ClrDatagrid.prototype, "clrDgSingleActionableAriaLabel", void 0);
        __decorate([
            core.Input()
        ], ClrDatagrid.prototype, "clrDetailExpandableAriaLabel", void 0);
        __decorate([
            core.Input()
        ], ClrDatagrid.prototype, "clrDgDisablePageFocus", void 0);
        __decorate([
            core.Input()
        ], ClrDatagrid.prototype, "clrDgPreserveSelection", null);
        __decorate([
            core.Input('clrDgRowSelection')
        ], ClrDatagrid.prototype, "rowSelectionMode", null);
        __decorate([
            core.ContentChild(ClrDatagridPlaceholder)
        ], ClrDatagrid.prototype, "placeholder", void 0);
        __decorate([
            core.ContentChildren(ClrDatagridColumn)
        ], ClrDatagrid.prototype, "columns", void 0);
        __decorate([
            core.ContentChildren(ClrDatagridRow)
        ], ClrDatagrid.prototype, "rows", void 0);
        __decorate([
            core.ViewChild('scrollableColumns', { read: core.ViewContainerRef })
        ], ClrDatagrid.prototype, "scrollableColumns", void 0);
        __decorate([
            core.ViewChild('datagridTable', { read: core.ElementRef })
        ], ClrDatagrid.prototype, "datagridTable", void 0);
        __decorate([
            core.ViewChild('projectedDisplayColumns', { read: core.ViewContainerRef })
        ], ClrDatagrid.prototype, "_projectedDisplayColumns", void 0);
        __decorate([
            core.ViewChild('projectedCalculationColumns', { read: core.ViewContainerRef })
        ], ClrDatagrid.prototype, "_projectedCalculationColumns", void 0);
        __decorate([
            core.ViewChild('displayedRows', { read: core.ViewContainerRef })
        ], ClrDatagrid.prototype, "_displayedRows", void 0);
        __decorate([
            core.ViewChild('calculationRows', { read: core.ViewContainerRef })
        ], ClrDatagrid.prototype, "_calculationRows", void 0);
        ClrDatagrid = __decorate([ __param(9, core.Inject(UNIQUE_ID))
        ], ClrDatagrid);
ClrDatagrid.ɵfac = function ClrDatagrid_Factory(t) { return new (t || ClrDatagrid)(ɵngcc0.ɵɵdirectiveInject(DatagridRenderOrganizer), ɵngcc0.ɵɵdirectiveInject(Items), ɵngcc0.ɵɵdirectiveInject(ExpandableRowsCount), ɵngcc0.ɵɵdirectiveInject(Selection), ɵngcc0.ɵɵdirectiveInject(RowActionService), ɵngcc0.ɵɵdirectiveInject(StateProvider), ɵngcc0.ɵɵdirectiveInject(DisplayModeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(Page), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrDatagrid.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagrid, selectors: [["clr-datagrid"]], contentQueries: function ClrDatagrid_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridItems, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridPlaceholder, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridColumn, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridRow, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iterator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholder = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rows = _t);
    } }, viewQuery: function ClrDatagrid_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c44, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c45, true, core.ElementRef);
        ɵngcc0.ɵɵviewQuery(_c46, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c47, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c48, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c49, true, core.ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollableColumns = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datagridTable = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._projectedDisplayColumns = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._projectedCalculationColumns = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._displayedRows = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._calculationRows = _t.first);
    } }, hostVars: 4, hostBindings: function ClrDatagrid_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-host", true)("datagrid-detail-open", ctx.detailService.isOpen);
    } }, inputs: { clrDgSingleSelectionAriaLabel: "clrDgSingleSelectionAriaLabel", clrDgSingleActionableAriaLabel: "clrDgSingleActionableAriaLabel", clrDetailExpandableAriaLabel: "clrDetailExpandableAriaLabel", clrDgDisablePageFocus: "clrDgDisablePageFocus", loading: ["clrDgLoading", "loading"], selected: ["clrDgSelected", "selected"], singleSelected: ["clrDgSingleSelected", "singleSelected"], clrDgPreserveSelection: "clrDgPreserveSelection", rowSelectionMode: ["clrDgRowSelection", "rowSelectionMode"] }, outputs: { refresh: "clrDgRefresh", selectedChanged: "clrDgSelectedChange", singleSelectedChanged: "clrDgSingleSelectedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            Selection,
            Sort,
            FiltersProvider,
            Page,
            Items,
            DatagridRenderOrganizer,
            RowActionService,
            ExpandableRowsCount,
            StateDebouncer,
            DetailService,
            UNIQUE_ID_PROVIDER,
            StateProvider,
            TableSizeService,
            ColumnsService,
            DisplayModeService,
        ])], ngContentSelectors: _c51, decls: 32, vars: 7, consts: [[1, "datagrid-outer-wrapper"], [1, "datagrid-inner-wrapper"], [1, "datagrid"], ["datagrid", ""], [1, "datagrid-table-wrapper"], ["role", "grid", "tabindex", "-1", 1, "datagrid-table"], ["datagridTable", ""], ["role", "rowgroup", 1, "datagrid-header"], ["role", "row", 1, "datagrid-row"], [1, "datagrid-row-master", "datagrid-row-flex"], [1, "datagrid-row-sticky"], ["role", "columnheader", "class", "datagrid-column datagrid-select datagrid-fixed-column", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-row-actions datagrid-fixed-column", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-expandable-caret datagrid-fixed-column", 4, "ngIf"], [1, "datagrid-row-scrollable"], ["projectedDisplayColumns", ""], ["displayedRows", ""], [4, "ngIf"], ["class", "datagrid-spinner", 4, "ngIf"], [1, "datagrid-calculation-table"], [1, "datagrid-calculation-header"], ["projectedCalculationColumns", ""], ["calculationRows", ""], ["role", "columnheader", 1, "datagrid-column", "datagrid-select", "datagrid-fixed-column"], [1, "datagrid-column-title"], ["clrCheckbox", "", "type", "checkbox", 3, "ngModel", "ngModelChange"], [1, "datagrid-column-separator"], ["role", "columnheader", 1, "datagrid-column", "datagrid-row-actions", "datagrid-fixed-column"], ["role", "columnheader", 1, "datagrid-column", "datagrid-expandable-caret", "datagrid-fixed-column"], [1, "datagrid-spinner"], ["clrMedium", ""]], template: function ClrDatagrid_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c50);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2, 3);
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5, 6);
        ɵngcc0.ɵɵelementStart(8, "div", 7);
        ɵngcc0.ɵɵelementStart(9, "div", 8);
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelementStart(11, "div", 10);
        ɵngcc0.ɵɵtemplate(12, ClrDatagrid_div_12_Template, 4, 2, "div", 11);
        ɵngcc0.ɵɵtemplate(13, ClrDatagrid_div_13_Template, 2, 1, "div", 11);
        ɵngcc0.ɵɵtemplate(14, ClrDatagrid_div_14_Template, 2, 1, "div", 12);
        ɵngcc0.ɵɵtemplate(15, ClrDatagrid_div_15_Template, 2, 1, "div", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "div", 14);
        ɵngcc0.ɵɵelementContainer(17, null, 15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(19, null, 16);
        ɵngcc0.ɵɵprojection(21, 1);
        ɵngcc0.ɵɵtemplate(22, ClrDatagrid_clr_dg_placeholder_22_Template, 1, 0, "clr-dg-placeholder", 17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(23, 2);
        ɵngcc0.ɵɵtemplate(24, ClrDatagrid_div_24_Template, 3, 0, "div", 18);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(25, 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(26, "div", 19);
        ɵngcc0.ɵɵelementStart(27, "div", 20);
        ɵngcc0.ɵɵelementContainer(28, null, 21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(30, null, 22);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.detailService.isOpen ? true : null);
        ɵngcc0.ɵɵadvance(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Multi);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Single);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowActionService.hasActionableRow);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expandableRows.hasExpandableRow || ctx.detailService.enabled);
        ɵngcc0.ɵɵadvance(7);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.CheckboxControlValueAccessor, ClrCheckbox, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ClrDatagridPlaceholder,
        ClrSpinner], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagrid, [{
        type: core.Component,
        args: [{
                selector: 'clr-datagrid',
                template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select=\"clr-dg-action-bar\"></ng-content>\n<div class=\"datagrid-outer-wrapper\">\n  <div class=\"datagrid-inner-wrapper\">\n    <div class=\"datagrid\" #datagrid [attr.aria-hidden]=\"detailService.isOpen ? true : null\">\n      <div class=\"datagrid-table-wrapper\">\n        <div role=\"grid\" class=\"datagrid-table\" tabindex=\"-1\" #datagridTable>\n          <div role=\"rowgroup\" class=\"datagrid-header\">\n            <div role=\"row\" class=\"datagrid-row\">\n              <div class=\"datagrid-row-master datagrid-row-flex\">\n                <div class=\"datagrid-row-sticky\">\n                  <!--header for datagrid where you can select multiple rows -->\n                  <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                       *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n                            <span class=\"datagrid-column-title\">\n                                <input clrCheckbox type=\"checkbox\" [(ngModel)]=\"allSelected\"\n                                       [attr.aria-label]=\"commonStrings.keys.selectAll\">\n                            </span>\n                    <div class=\"datagrid-column-separator\"></div>\n                  </div>\n                  <!-- header for datagrid where you can select one row only -->\n                  <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                       *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\"\n                       [attr.aria-label]=\"clrDgSingleSelectionAriaLabel\">\n                    <div class=\"datagrid-column-separator\"></div>\n                  </div>\n                  <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                  <div role=\"columnheader\" class=\"datagrid-column datagrid-row-actions datagrid-fixed-column\"\n                       *ngIf=\"rowActionService.hasActionableRow\" [attr.aria-label]=\"clrDgSingleActionableAriaLabel\">\n                    <div class=\"datagrid-column-separator\"></div>\n                  </div>\n                  <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                  <div role=\"columnheader\" class=\"datagrid-column datagrid-expandable-caret datagrid-fixed-column\"\n                       *ngIf=\"expandableRows.hasExpandableRow || detailService.enabled\" [attr.aria-label]=\"clrDetailExpandableAriaLabel\">\n                    <div class=\"datagrid-column-separator\"></div>\n                  </div>\n                </div>\n                <div class=\"datagrid-row-scrollable\">\n                  <ng-container #projectedDisplayColumns></ng-container>\n                </div>\n              </div>\n            </div>\n          </div>\n          <ng-container #displayedRows></ng-container>\n          <!-- Custom placeholder overrides the default empty one -->\n          <ng-content select=\"clr-dg-placeholder\"></ng-content>\n          <clr-dg-placeholder *ngIf=\"!placeholder\"></clr-dg-placeholder>\n        </div>\n      </div>\n    </div>\n    <ng-content select=\"clr-dg-footer\"></ng-content>\n    <div class=\"datagrid-spinner\" *ngIf=\"loading\">\n      <clr-spinner clrMedium>Loading</clr-spinner>\n    </div>\n  </div>\n  <ng-content select=\"[clrIfDetail],clr-dg-detail\"></ng-content>\n</div>\n\n<div class=\"datagrid-calculation-table\">\n  <div class=\"datagrid-calculation-header\">\n    <ng-container #projectedCalculationColumns></ng-container>\n  </div>\n  <ng-container #calculationRows></ng-container>\n</div>\n",
                providers: [
                    Selection,
                    Sort,
                    FiltersProvider,
                    Page,
                    Items,
                    DatagridRenderOrganizer,
                    RowActionService,
                    ExpandableRowsCount,
                    StateDebouncer,
                    DetailService,
                    UNIQUE_ID_PROVIDER,
                    StateProvider,
                    TableSizeService,
                    ColumnsService,
                    DisplayModeService,
                ],
                host: {
                    '[class.datagrid-host]': 'true',
                    '[class.datagrid-detail-open]': 'detailService.isOpen'
                }
            }]
    }], function () { return [{ type: DatagridRenderOrganizer }, { type: Items }, { type: ExpandableRowsCount }, { type: Selection }, { type: RowActionService }, { type: StateProvider }, { type: DisplayModeService }, { type: ɵngcc0.Renderer2 }, { type: DetailService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: Page }, { type: ClrCommonStringsService }]; }, { refresh: [{
            type: core.Output,
            args: ['clrDgRefresh']
        }], selectedChanged: [{
            type: core.Output,
            args: ['clrDgSelectedChange']
        }], singleSelectedChanged: [{
            type: core.Output,
            args: ['clrDgSingleSelectedChange']
        }], clrDgSingleSelectionAriaLabel: [{
            type: core.Input
        }], clrDgSingleActionableAriaLabel: [{
            type: core.Input
        }], clrDetailExpandableAriaLabel: [{
            type: core.Input
        }], clrDgDisablePageFocus: [{
            type: core.Input
        }], loading: [{
            type: core.Input,
            args: ['clrDgLoading']
        }], selected: [{
            type: core.Input,
            args: ['clrDgSelected']
        }], singleSelected: [{
            type: core.Input,
            args: ['clrDgSingleSelected']
        }], clrDgPreserveSelection: [{
            type: core.Input
        }], rowSelectionMode: [{
            type: core.Input,
            args: ['clrDgRowSelection']
        }], iterator: [{
            type: core.ContentChild,
            args: [ClrDatagridItems]
        }], placeholder: [{
            type: core.ContentChild,
            args: [ClrDatagridPlaceholder]
        }], columns: [{
            type: core.ContentChildren,
            args: [ClrDatagridColumn]
        }], rows: [{
            type: core.ContentChildren,
            args: [ClrDatagridRow]
        }], scrollableColumns: [{
            type: core.ViewChild,
            args: ['scrollableColumns', { read: core.ViewContainerRef }]
        }], datagridTable: [{
            type: core.ViewChild,
            args: ['datagridTable', { read: core.ElementRef }]
        }], _projectedDisplayColumns: [{
            type: core.ViewChild,
            args: ['projectedDisplayColumns', { read: core.ViewContainerRef }]
        }], _projectedCalculationColumns: [{
            type: core.ViewChild,
            args: ['projectedCalculationColumns', { read: core.ViewContainerRef }]
        }], _displayedRows: [{
            type: core.ViewChild,
            args: ['displayedRows', { read: core.ViewContainerRef }]
        }], _calculationRows: [{
            type: core.ViewChild,
            args: ['calculationRows', { read: core.ViewContainerRef }]
        }] }); })();
        return ClrDatagrid;
    }());

    var ClrDatagridActionBar = /** @class */ (function () {
        function ClrDatagridActionBar() {
        }
ClrDatagridActionBar.ɵfac = function ClrDatagridActionBar_Factory(t) { return new (t || ClrDatagridActionBar)(); };
ClrDatagridActionBar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridActionBar, selectors: [["clr-dg-action-bar"]], hostVars: 2, hostBindings: function ClrDatagridActionBar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-action-bar", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrDatagridActionBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridActionBar, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-action-bar',
                template: "\n        <ng-content></ng-content>\n    ",
                host: { '[class.datagrid-action-bar]': 'true' }
            }]
    }], function () { return []; }, null); })();
        return ClrDatagridActionBar;
    }());

    var clrDgActionId = 0;
    var ClrDatagridActionOverflow = /** @class */ (function () {
        function ClrDatagridActionOverflow(rowActionService, commonStrings, platformId, zone, smartToggleService, popoverId) {
            var _this = this;
            this.rowActionService = rowActionService;
            this.commonStrings = commonStrings;
            this.platformId = platformId;
            this.zone = zone;
            this.smartToggleService = smartToggleService;
            this.popoverId = popoverId;
            this.subscriptions = [];
            this.smartPosition = {
                axis: exports.ClrAxis.HORIZONTAL,
                side: exports.ClrSide.AFTER,
                anchor: exports.ClrAlignment.CENTER,
                content: exports.ClrAlignment.CENTER,
            };
            this._open = false;
            this.openChange = new core.EventEmitter(false);
            this.rowActionService.register();
            this.subscriptions.push(this.smartToggleService.openChange.subscribe(function (openState) {
                _this.open = openState;
                if (openState) {
                    _this.focusFirstButton();
                }
            }));
            this.popoverId = 'clr-action-menu' + clrDgActionId++;
        }
        ClrDatagridActionOverflow.prototype.ngOnDestroy = function () {
            this.rowActionService.unregister();
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDatagridActionOverflow.prototype.closeOverflowContent = function (event) {
            this.smartToggleService.toggleWithEvent(event);
        };
        Object.defineProperty(ClrDatagridActionOverflow.prototype, "open", {
            get: function () {
                return this._open;
            },
            set: function (open) {
                var openState = !!open;
                if (!!openState !== this.open) {
                    // prevents chocolate mess
                    this.smartToggleService.open = openState;
                    this.openChange.emit(openState);
                    this._open = openState;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridActionOverflow.prototype.focusFirstButton = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.zone.runOutsideAngular(function () {
                    setTimeout(function () {
                        var firstButton = document.querySelector('button.action-item');
                        if (firstButton) {
                            firstButton.focus();
                        }
                    });
                });
            }
        };
        ClrDatagridActionOverflow.ctorParameters = function () { return [
            { type: RowActionService },
            { type: ClrCommonStringsService },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: core.NgZone },
            { type: ClrPopoverToggleService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        __decorate([
            core.Input('clrDgActionOverflowOpen')
        ], ClrDatagridActionOverflow.prototype, "open", null);
        __decorate([
            core.Output('clrDgActionOverflowOpenChange')
        ], ClrDatagridActionOverflow.prototype, "openChange", void 0);
        ClrDatagridActionOverflow = __decorate([ __param(2, core.Inject(core.PLATFORM_ID)),
            __param(5, core.Inject(UNIQUE_ID))
        ], ClrDatagridActionOverflow);
ClrDatagridActionOverflow.ɵfac = function ClrDatagridActionOverflow_Factory(t) { return new (t || ClrDatagridActionOverflow)(ɵngcc0.ɵɵdirectiveInject(RowActionService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrDatagridActionOverflow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridActionOverflow, selectors: [["clr-dg-action-overflow"]], inputs: { open: ["clrDgActionOverflowOpen", "open"] }, outputs: { openChange: "clrDgActionOverflowOpenChange" }, features: [ɵngcc0.ɵɵProvidersFeature([UNIQUE_ID_PROVIDER, ClrPopoverToggleService, ClrPopoverEventsService, ClrPopoverPositionService])], ngContentSelectors: _c1, decls: 4, vars: 8, consts: [["type", "button", "role", "button", "aria-haspopup", "true", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "datagrid-action-toggle"], ["anchor", ""], ["shape", "ellipsis-vertical"], ["class", "datagrid-action-overflow", "role", "menu", "clrFocusTrap", "", 3, "id", "click", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "menu", "clrFocusTrap", "", 1, "datagrid-action-overflow", 3, "id", "click"]], template: function ClrDatagridActionOverflow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵelement(2, "clr-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ClrDatagridActionOverflow_div_3_Template, 2, 3, "div", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-controls", ctx.popoverId)("aria-expanded", ctx.open)("aria-label", ctx.commonStrings.keys.rowActions);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.rowActions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    } }, directives: [ClrPopoverAnchor,
        ClrPopoverOpenCloseButton,
        ClrIconCustomTag,
        ClrPopoverContent,
        FocusTrapDirective], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridActionOverflow, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-action-overflow',
                providers: [UNIQUE_ID_PROVIDER, ClrPopoverToggleService, ClrPopoverEventsService, ClrPopoverPositionService],
                template: "\n      <button class=\"datagrid-action-toggle\"\n              type=\"button\"\n              role=\"button\"\n              aria-haspopup=\"true\"\n              #anchor\n              [attr.aria-controls]=\"popoverId\"\n              [attr.aria-expanded]=\"open\"\n              [attr.aria-label]=\"commonStrings.keys.rowActions\"\n              clrPopoverAnchor\n              clrPopoverOpenCloseButton>\n          <clr-icon shape=\"ellipsis-vertical\" [attr.title]=\"commonStrings.keys.rowActions\"></clr-icon>\n      </button>\n\n      <div class=\"datagrid-action-overflow\"\n           role=\"menu\"\n           [id]=\"popoverId\"\n           [attr.aria-hidden]=\"!open\"\n           [attr.id]=\"popoverId\"\n           clrFocusTrap\n           (click)=\"closeOverflowContent($event)\"\n           *clrPopoverContent=\"open at smartPosition; outsideClickToClose: true; scrollToClose: true\">\n          <ng-content></ng-content>\n      </div>\n  "
            }]
    }], function () { return [{ type: RowActionService }, { type: ClrCommonStringsService }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: ɵngcc0.NgZone }, { type: ClrPopoverToggleService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, { openChange: [{
            type: core.Output,
            args: ['clrDgActionOverflowOpenChange']
        }], open: [{
            type: core.Input,
            args: ['clrDgActionOverflowOpen']
        }] }); })();
        return ClrDatagridActionOverflow;
    }());

    var MIN_COLUMN_WIDTH = 96;
    // This service allows DatagridHeaderRenderer and ClrDatagridColumnSeparator
    // to share column resize data with each other.
    var ColumnResizerService = /** @class */ (function () {
        function ColumnResizerService(el, domAdapter, organizer) {
            this.el = el;
            this.domAdapter = domAdapter;
            this.organizer = organizer;
            this._resizedBy = 0;
        }
        Object.defineProperty(ColumnResizerService.prototype, "resizedBy", {
            get: function () {
                return this._resizedBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnResizerService.prototype, "minColumnWidth", {
            get: function () {
                return this.domAdapter.minWidth(this.el.nativeElement) || MIN_COLUMN_WIDTH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnResizerService.prototype, "maxResizeRange", {
            get: function () {
                return this.widthBeforeResize - this.minColumnWidth;
            },
            enumerable: true,
            configurable: true
        });
        ColumnResizerService.prototype.startResize = function () {
            this._resizedBy = 0;
            this.isWithinMaxResizeRange = true;
            this.widthBeforeResize = this.domAdapter.clientRect(this.el.nativeElement).width;
        };
        ColumnResizerService.prototype.endResize = function () {
            this.organizer.resize();
        };
        Object.defineProperty(ColumnResizerService.prototype, "widthAfterResize", {
            get: function () {
                return this.widthBeforeResize + this._resizedBy;
            },
            enumerable: true,
            configurable: true
        });
        ColumnResizerService.prototype.calculateResize = function (event) {
            var moveX = event.dragPosition.moveX;
            // returns the resize amount within the allowed range
            if (moveX < -this.maxResizeRange) {
                this._resizedBy = -this.maxResizeRange;
                this.isWithinMaxResizeRange = false;
            }
            else {
                this._resizedBy = moveX;
                this.isWithinMaxResizeRange = true;
            }
        };
        ColumnResizerService.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: DomAdapter },
            { type: DatagridRenderOrganizer }
        ]; };
ColumnResizerService.ɵfac = function ColumnResizerService_Factory(t) { return new (t || ColumnResizerService)(ɵngcc0.ɵɵinject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinject(DomAdapter), ɵngcc0.ɵɵinject(DatagridRenderOrganizer)); };
ColumnResizerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnResizerService, factory: function (t) { return ColumnResizerService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnResizerService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DomAdapter }, { type: DatagridRenderOrganizer }]; }, null); })();
        return ColumnResizerService;
    }());

    var ClrDatagridColumnSeparator = /** @class */ (function () {
        // Every column draggable separator should have its own unique ID
        // in order to not conflict with other draggables/droppables.
        function ClrDatagridColumnSeparator(columnResizerService, renderer, tableSizeService, document, columnSeparatorId) {
            this.columnResizerService = columnResizerService;
            this.renderer = renderer;
            this.tableSizeService = tableSizeService;
            this.document = document;
            this.columnSeparatorId = columnSeparatorId;
        }
        ClrDatagridColumnSeparator.prototype.showTracker = function (resizeTrackerEl) {
            this.columnResizerService.startResize();
            var tableHeight = this.tableSizeService.getColumnDragHeight();
            this.renderer.setStyle(resizeTrackerEl, 'height', tableHeight);
            this.renderer.setStyle(resizeTrackerEl, 'display', 'block');
        };
        ClrDatagridColumnSeparator.prototype.moveTracker = function (event, resizeTrackerEl) {
            this.columnResizerService.calculateResize(event);
            this.renderer.setStyle(resizeTrackerEl, 'transform', "translateX(" + this.columnResizerService.resizedBy + "px)");
            this.renderer.setStyle(this.document.body, 'cursor', 'col-resize');
            this.redFlagTracker(resizeTrackerEl);
        };
        ClrDatagridColumnSeparator.prototype.hideTracker = function (resizeTrackerEl) {
            this.columnResizerService.endResize();
            this.renderer.setStyle(resizeTrackerEl, 'display', 'none');
            this.renderer.setStyle(resizeTrackerEl, 'transform', "translateX(0px)");
            this.renderer.setStyle(this.document.body, 'cursor', 'auto');
        };
        ClrDatagridColumnSeparator.prototype.redFlagTracker = function (resizeTrackerEl) {
            var isWithinMaxResizeRange;
            // @TODO(JEREMY) Review this, it will always be true because above is always null
            if (isWithinMaxResizeRange !== this.columnResizerService.isWithinMaxResizeRange) {
                isWithinMaxResizeRange = this.columnResizerService.isWithinMaxResizeRange;
                if (!isWithinMaxResizeRange) {
                    this.renderer.addClass(resizeTrackerEl, 'exceeded-max');
                }
                else {
                    this.renderer.removeClass(resizeTrackerEl, 'exceeded-max');
                }
            }
        };
        ClrDatagridColumnSeparator.ctorParameters = function () { return [
            { type: ColumnResizerService },
            { type: core.Renderer2 },
            { type: TableSizeService },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        ClrDatagridColumnSeparator = __decorate([ __param(3, core.Inject(common.DOCUMENT)),
            __param(4, core.Inject(UNIQUE_ID))
        ], ClrDatagridColumnSeparator);
ClrDatagridColumnSeparator.ɵfac = function ClrDatagridColumnSeparator_Factory(t) { return new (t || ClrDatagridColumnSeparator)(ɵngcc0.ɵɵdirectiveInject(ColumnResizerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TableSizeService), ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrDatagridColumnSeparator.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridColumnSeparator, selectors: [["clr-dg-column-separator"]], hostVars: 2, hostBindings: function ClrDatagridColumnSeparator_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-column-separator", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([UNIQUE_ID_PROVIDER])], decls: 3, vars: 1, consts: [["aria-hidden", "true", "clrDraggable", "", 1, "datagrid-column-handle", 3, "clrGroup", "clrDragStart", "clrDragMove", "clrDragEnd"], [1, "datagrid-column-resize-tracker"], ["resizeTrackerEl", ""]], template: function ClrDatagridColumnSeparator_Template(rf, ctx) { if (rf & 1) {
        var _r1 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("clrDragStart", function ClrDatagridColumnSeparator_Template_div_clrDragStart_0_listener() { ɵngcc0.ɵɵrestoreView(_r1); var _r0 = ɵngcc0.ɵɵreference(2); return ctx.showTracker(_r0); })("clrDragMove", function ClrDatagridColumnSeparator_Template_div_clrDragMove_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1); var _r0 = ɵngcc0.ɵɵreference(2); return ctx.moveTracker($event, _r0); })("clrDragEnd", function ClrDatagridColumnSeparator_Template_div_clrDragEnd_0_listener() { ɵngcc0.ɵɵrestoreView(_r1); var _r0 = ɵngcc0.ɵɵreference(2); return ctx.hideTracker(_r0); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(1, "div", 1, 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("clrGroup", ctx.columnSeparatorId);
    } }, directives: [ClrDraggable], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridColumnSeparator, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-column-separator',
                template: "\n    <div class=\"datagrid-column-handle\" aria-hidden=\"true\"\n      clrDraggable \n      [clrGroup]=\"columnSeparatorId\" \n      (clrDragStart)=\"showTracker(resizeTrackerEl)\" \n      (clrDragMove)=\"moveTracker($event, resizeTrackerEl)\" \n      (clrDragEnd)=\"hideTracker(resizeTrackerEl)\"></div>\n    <div class=\"datagrid-column-resize-tracker\" #resizeTrackerEl></div>\n    ",
                host: {
                    '[class.datagrid-column-separator]': 'true'
                },
                providers: [UNIQUE_ID_PROVIDER]
            }]
    }], function () { return [{ type: ColumnResizerService }, { type: ɵngcc0.Renderer2 }, { type: TableSizeService }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, null); })();
        return ClrDatagridColumnSeparator;
    }());

    var ClrDatagridColumnToggleTitle = /** @class */ (function () {
        /** @deprecated since 2.0, remove in 3.0 */
        function ClrDatagridColumnToggleTitle() {
        }
ClrDatagridColumnToggleTitle.ɵfac = function ClrDatagridColumnToggleTitle_Factory(t) { return new (t || ClrDatagridColumnToggleTitle)(); };
ClrDatagridColumnToggleTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridColumnToggleTitle, selectors: [["clr-dg-column-toggle-title"]], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrDatagridColumnToggleTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridColumnToggleTitle, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-column-toggle-title',
                template: "<ng-content></ng-content>"
            }]
    }], function () { return []; }, null); })();
        return ClrDatagridColumnToggleTitle;
    }());

    var ClrDatagridColumnToggleButton = /** @class */ (function () {
        function ClrDatagridColumnToggleButton(columnsService) {
            this.columnsService = columnsService;
            this.allSelected = new core.EventEmitter();
        }
        Object.defineProperty(ClrDatagridColumnToggleButton.prototype, "clrAllSelected", {
            get: function () {
                return this.allSelected.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumnToggleButton.prototype.hideableColumns = function () {
            return this.columnsService.columns.filter(function (column) { return column.value.hideable; });
        };
        Object.defineProperty(ClrDatagridColumnToggleButton.prototype, "allHideablesVisible", {
            get: function () {
                return this.hideableColumns().filter(function (column) { return column.value.hidden; }).length === 0;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumnToggleButton.prototype.selectAll = function () {
            var _this = this;
            this.hideableColumns().forEach(function (hideableColumn) {
                return _this.columnsService.emitStateChange(hideableColumn, {
                    hidden: false,
                    changes: [DatagridColumnChanges.HIDDEN],
                });
            });
            this.allSelected.next(true);
        };
        ClrDatagridColumnToggleButton.ctorParameters = function () { return [
            { type: ColumnsService }
        ]; };
        __decorate([
            core.Output('clrAllSelected')
        ], ClrDatagridColumnToggleButton.prototype, "clrAllSelected", null);
ClrDatagridColumnToggleButton.ɵfac = function ClrDatagridColumnToggleButton_Factory(t) { return new (t || ClrDatagridColumnToggleButton)(ɵngcc0.ɵɵdirectiveInject(ColumnsService)); };
ClrDatagridColumnToggleButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridColumnToggleButton, selectors: [["clr-dg-column-toggle-button"]], outputs: { clrAllSelected: "clrAllSelected" }, ngContentSelectors: _c1, decls: 2, vars: 1, consts: [["type", "button", 1, "btn", "btn-sm", "btn-link", "switch-button", 3, "disabled", "click"]], template: function ClrDatagridColumnToggleButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ClrDatagridColumnToggleButton_Template_button_click_0_listener() { return ctx.selectAll(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("disabled", ctx.allHideablesVisible);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridColumnToggleButton, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-column-toggle-button',
                template: "\n    <button class=\"btn btn-sm btn-link switch-button\"\n            (click)=\"selectAll()\"\n            [disabled]=\"allHideablesVisible\"\n            type=\"button\">\n      <ng-content></ng-content>\n    </button>\n  "
            }]
    }], function () { return [{ type: ColumnsService }]; }, { clrAllSelected: [{
            type: core.Output,
            args: ['clrAllSelected']
        }] }); })();
        return ClrDatagridColumnToggleButton;
    }());

    var ClrDatagridColumnToggle = /** @class */ (function () {
        function ClrDatagridColumnToggle(commonStrings, columnsService, columnSwitchId, platformId, zone, popoverId) {
            this.commonStrings = commonStrings;
            this.columnsService = columnsService;
            this.columnSwitchId = columnSwitchId;
            this.platformId = platformId;
            this.zone = zone;
            this.popoverId = popoverId;
            // Smart Popover
            this.smartPosition = {
                axis: exports.ClrAxis.VERTICAL,
                side: exports.ClrSide.BEFORE,
                anchor: exports.ClrAlignment.START,
                content: exports.ClrAlignment.START,
            };
        }
        Object.defineProperty(ClrDatagridColumnToggle.prototype, "allColumnsVisible", {
            get: function () {
                return this._allColumnsVisible;
            },
            set: function (value) {
                this._allColumnsVisible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumnToggle.prototype, "hideableColumnStates", {
            get: function () {
                var hideables = this.columnsService.columns.filter(function (column) { return column.value.hideable; });
                return hideables.map(function (column) { return column.value; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumnToggle.prototype, "hasOnlyOneVisibleColumn", {
            get: function () {
                var nbNonHideableColumns = this.columnsService.columns.length - this.hideableColumnStates.length;
                // this should only return true when there is no non-hideable columns.
                return (nbNonHideableColumns === 0 && this.hideableColumnStates.filter(function (columnState) { return !columnState.hidden; }).length === 1);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumnToggle.prototype.toggleColumnState = function (columnState, event) {
            var columnToToggle = this.columnsService.columns.filter(function (column) { return column.value === columnState; })[0];
            this.columnsService.emitStateChange(columnToToggle, {
                hidden: event,
                changes: [DatagridColumnChanges.HIDDEN],
            });
        };
        ClrDatagridColumnToggle.prototype.toggleSwitchPanel = function () {
            var _this = this;
            this.openState = !this.openState;
            if (this.openState && common.isPlatformBrowser(this.platformId) && this.menuDescriptionElement) {
                this.zone.runOutsideAngular(function () {
                    setTimeout(function () {
                        _this.menuDescriptionElement.nativeElement.focus();
                    });
                });
            }
        };
        ClrDatagridColumnToggle.prototype.allColumnsSelected = function () {
            this.allSelectedElement.nativeElement.focus();
        };
        // Without tracking the checkboxes get rerendered on model update, which leads
        // to loss of focus after checkbox toggle.
        ClrDatagridColumnToggle.prototype.trackByFn = function (index) {
            return index;
        };
        ClrDatagridColumnToggle.ctorParameters = function () { return [
            { type: ClrCommonStringsService },
            { type: ColumnsService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: core.NgZone },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        __decorate([
            core.ContentChild(ClrDatagridColumnToggleTitle)
        ], ClrDatagridColumnToggle.prototype, "customToggleTitle", void 0);
        __decorate([
            core.ContentChild(ClrDatagridColumnToggleButton)
        ], ClrDatagridColumnToggle.prototype, "customToggleButton", void 0);
        __decorate([
            core.ViewChild('menuDescription', { read: core.ElementRef })
        ], ClrDatagridColumnToggle.prototype, "menuDescriptionElement", void 0);
        __decorate([
            core.ViewChild('allSelected', { read: core.ElementRef })
        ], ClrDatagridColumnToggle.prototype, "allSelectedElement", void 0);
        ClrDatagridColumnToggle = __decorate([ __param(2, core.Inject(UNIQUE_ID)),
            __param(3, core.Inject(core.PLATFORM_ID)),
            __param(5, core.Inject(UNIQUE_ID))
        ], ClrDatagridColumnToggle);
ClrDatagridColumnToggle.ɵfac = function ClrDatagridColumnToggle_Factory(t) { return new (t || ClrDatagridColumnToggle)(ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ColumnsService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrDatagridColumnToggle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridColumnToggle, selectors: [["clr-dg-column-toggle"]], contentQueries: function ClrDatagridColumnToggle_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridColumnToggleTitle, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridColumnToggleButton, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customToggleTitle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customToggleButton = _t.first);
    } }, viewQuery: function ClrDatagridColumnToggle_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c52, true, core.ElementRef);
        ɵngcc0.ɵɵviewQuery(_c53, true, core.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuDescriptionElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.allSelectedElement = _t.first);
    } }, hostVars: 4, hostBindings: function ClrDatagridColumnToggle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("column-switch-wrapper", true)("active", ctx.openState);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([UNIQUE_ID_PROVIDER, ClrPopoverEventsService, ClrPopoverPositionService, ClrPopoverToggleService])], ngContentSelectors: _c55, decls: 3, vars: 7, consts: [["role", "button", "type", "button", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "btn", "btn-sm", "btn-link", "column-toggle--action"], ["shape", "view-columns"], ["class", "column-switch", "role", "dialog", "clrFocusTrap", "", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "dialog", "clrFocusTrap", "", 1, "column-switch", 3, "id"], [1, "switch-header"], ["tabindex", "-1", 1, "clr-sr-only"], ["menuDescription", ""], ["allSelected", ""], [4, "ngIf"], ["clrPopoverCloseButton", "", "type", "button", 1, "btn", "btn-sm", "btn-link", "toggle-switch-close-button"], ["shape", "close"], [1, "switch-content", "list-unstyled"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "switch-footer"], [3, "clrAllSelected", 4, "ngIf"], ["clrCheckbox", "", "type", "checkbox", 3, "disabled", "ngModel", "ngModelChange"], [3, "ngTemplateOutlet"], [3, "clrAllSelected"]], template: function ClrDatagridColumnToggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c54);
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelement(1, "clr-icon", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, ClrDatagridColumnToggle_div_2_Template, 17, 9, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-controls", ctx.popoverId)("aria-owns", ctx.popoverId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.pickColumns);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("clrPopoverContent", ctx.openState)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    } }, directives: function () { return [ClrPopoverAnchor,
        ClrPopoverOpenCloseButton,
        ClrIconCustomTag,
        ClrPopoverContent,
        FocusTrapDirective, ɵngcc1.NgIf, ClrPopoverCloseButton, ɵngcc1.NgForOf, ClrDatagridItemsTrackBy,
        ClrCheckboxWrapper, ɵngcc2.CheckboxControlValueAccessor, ClrCheckbox, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ClrLabel, ɵngcc1.NgTemplateOutlet, ClrDatagridColumnToggleButton]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridColumnToggle, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-column-toggle',
                template: "    \n      <button\n              role=\"button\"\n              type=\"button\"\n              class=\"btn btn-sm btn-link column-toggle--action\"\n              clrPopoverAnchor\n              clrPopoverOpenCloseButton\n              [attr.aria-controls]=\"popoverId\"\n              [attr.aria-owns]=\"popoverId\">\n          <clr-icon shape=\"view-columns\" [attr.title]=\"commonStrings.keys.pickColumns\"></clr-icon>\n      </button>\n      <div class=\"column-switch\"\n           role=\"dialog\"\n           [id]=\"popoverId\"\n           clrFocusTrap\n           *clrPopoverContent=\"openState at smartPosition; outsideClickToClose: true; scrollToClose: true\">\n          <div class=\"switch-header\">\n              <div class=\"clr-sr-only\" tabindex=\"-1\" #menuDescription>{{commonStrings.keys.showColumnsMenuDescription}}</div>\n              <div class=\"clr-sr-only\" tabindex=\"-1\" #allSelected>{{commonStrings.keys.allColumnsSelected}}</div>\n              <ng-container *ngIf=\"!customToggleTitle\">{{commonStrings.keys.showColumns}}</ng-container>\n              <ng-content select=\"clr-dg-column-toggle-title\"></ng-content>\n              <button class=\"btn btn-sm btn-link toggle-switch-close-button\"\n                      clrPopoverCloseButton\n                      type=\"button\"\n                      [attr.aria-label]=\"commonStrings.keys.close\">\n                  <clr-icon shape=\"close\" \n                            [attr.title]=\"commonStrings.keys.close\"></clr-icon>\n              </button>\n          </div>\n          <ul class=\"switch-content list-unstyled\">\n              <li *ngFor=\"let columnState of hideableColumnStates;trackBy: trackByFn\">\n                  <clr-checkbox-wrapper>\n                      <input clrCheckbox type=\"checkbox\"\n                             [disabled]=\"hasOnlyOneVisibleColumn && !columnState.hidden\"\n                             [ngModel]=\"!columnState.hidden\"\n                             (ngModelChange)=\"toggleColumnState(columnState, !$event)\">\n                      <label>\n                          <ng-template [ngTemplateOutlet]=\"columnState.titleTemplateRef\"></ng-template>\n                      </label>\n                  </clr-checkbox-wrapper>\n              </li>\n          </ul>\n          <div class=\"switch-footer\">\n              <ng-content select=\"clr-dg-column-toggle-button\"></ng-content>\n              <clr-dg-column-toggle-button *ngIf=\"!customToggleButton\" (clrAllSelected)=\"allColumnsSelected()\">\n                  {{commonStrings.keys.selectAll}}\n              </clr-dg-column-toggle-button>\n          </div>\n      </div>\n  ",
                host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'openState' },
                providers: [UNIQUE_ID_PROVIDER, ClrPopoverEventsService, ClrPopoverPositionService, ClrPopoverToggleService]
            }]
    }], function () { return [{ type: ClrCommonStringsService }, { type: ColumnsService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, { customToggleTitle: [{
            type: core.ContentChild,
            args: [ClrDatagridColumnToggleTitle]
        }], customToggleButton: [{
            type: core.ContentChild,
            args: [ClrDatagridColumnToggleButton]
        }], menuDescriptionElement: [{
            type: core.ViewChild,
            args: ['menuDescription', { read: core.ElementRef }]
        }], allSelectedElement: [{
            type: core.ViewChild,
            args: ['allSelected', { read: core.ElementRef }]
        }] }); })();
        return ClrDatagridColumnToggle;
    }());

    /*
     * I don't think this deserves to be in IfExpanded itself,
     * so I'm adding a second directive on the same selector for now just for the datagrid
     */
    var DatagridDetailRegisterer = /** @class */ (function () {
        function DatagridDetailRegisterer(expandableRowsCount) {
            this.expandableRowsCount = expandableRowsCount;
            if (this.expandableRowsCount) {
                this.expandableRowsCount.register();
            }
        }
        DatagridDetailRegisterer.prototype.ngOnDestroy = function () {
            if (this.expandableRowsCount) {
                this.expandableRowsCount.unregister();
            }
        };
        DatagridDetailRegisterer.ctorParameters = function () { return [
            { type: ExpandableRowsCount, decorators: [{ type: core.Optional }] }
        ]; };
        DatagridDetailRegisterer = __decorate([ __param(0, core.Optional())
        ], DatagridDetailRegisterer);
DatagridDetailRegisterer.ɵfac = function DatagridDetailRegisterer_Factory(t) { return new (t || DatagridDetailRegisterer)(ɵngcc0.ɵɵdirectiveInject(ExpandableRowsCount, 8)); };
DatagridDetailRegisterer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridDetailRegisterer, selectors: [["", "clrIfExpanded", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridDetailRegisterer, [{
        type: core.Directive,
        args: [{ selector: '[clrIfExpanded]' }]
    }], function () { return [{ type: ExpandableRowsCount, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return DatagridDetailRegisterer;
    }());

    var ClrDatagridDetailHeader = /** @class */ (function () {
        function ClrDatagridDetailHeader(detailService, commonStrings) {
            this.detailService = detailService;
            this.commonStrings = commonStrings;
        }
        Object.defineProperty(ClrDatagridDetailHeader.prototype, "titleId", {
            get: function () {
                return this.detailService.id + "-title";
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridDetailHeader.ctorParameters = function () { return [
            { type: DetailService },
            { type: ClrCommonStringsService }
        ]; };
ClrDatagridDetailHeader.ɵfac = function ClrDatagridDetailHeader_Factory(t) { return new (t || ClrDatagridDetailHeader)(ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrDatagridDetailHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridDetailHeader, selectors: [["clr-dg-detail-header"]], hostVars: 2, hostBindings: function ClrDatagridDetailHeader_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-detail-header", true);
    } }, ngContentSelectors: _c1, decls: 5, vars: 2, consts: [["clrFocusOnViewInit", "", 1, "datagrid-detail-header-title", 3, "id"], [1, "datagrid-detail-pane-close"], ["type", "button", 1, "btn", "btn-link", 3, "click"], ["size", "24", "shape", "times"]], template: function ClrDatagridDetailHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "button", 2);
        ɵngcc0.ɵɵlistener("click", function ClrDatagridDetailHeader_Template_button_click_3_listener() { return ctx.detailService.close(); });
        ɵngcc0.ɵɵelement(4, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.titleId);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.close);
    } }, directives: [ClrFocusOnViewInit,
        ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridDetailHeader, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-detail-header',
                host: {
                    '[class.datagrid-detail-header]': 'true'
                },
                template: "\n    <div class=\"datagrid-detail-header-title\" clrFocusOnViewInit [id]=\"titleId\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"datagrid-detail-pane-close\">\n      <button type=\"button\" \n              class=\"btn btn-link\" \n              (click)=\"detailService.close()\" \n              [attr.aria-label]=\"commonStrings.keys.close\">\n        <clr-icon size=\"24\" shape=\"times\"></clr-icon>\n      </button>\n    </div>\n  "
            }]
    }], function () { return [{ type: DetailService }, { type: ClrCommonStringsService }]; }, null); })();
        return ClrDatagridDetailHeader;
    }());

    var ClrDatagridDetail = /** @class */ (function () {
        function ClrDatagridDetail(detailService, commonStrings) {
            this.detailService = detailService;
            this.commonStrings = commonStrings;
        }
        ClrDatagridDetail.prototype.closeCheck = function () {
            this.detailService.close();
        };
        ClrDatagridDetail.ctorParameters = function () { return [
            { type: DetailService },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.ContentChild(ClrDatagridDetailHeader)
        ], ClrDatagridDetail.prototype, "header", void 0);
        __decorate([
            core.HostListener('document:keyup.esc')
        ], ClrDatagridDetail.prototype, "closeCheck", null);
ClrDatagridDetail.ɵfac = function ClrDatagridDetail_Factory(t) { return new (t || ClrDatagridDetail)(ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrDatagridDetail.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridDetail, selectors: [["clr-dg-detail"]], contentQueries: function ClrDatagridDetail_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridDetailHeader, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
    } }, hostVars: 2, hostBindings: function ClrDatagridDetail_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.esc", function ClrDatagridDetail_keyup_esc_HostBindingHandler() { return ctx.closeCheck(); }, false, ɵngcc0.ɵɵresolveDocument);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-detail-pane", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 1, consts: [["class", "datagrid-detail-pane-content", "role", "dialog", "aria-modal", "true", 3, "clrFocusTrap", "id", 4, "ngIf"], ["role", "dialog", "aria-modal", "true", 1, "datagrid-detail-pane-content", 3, "clrFocusTrap", "id"], [1, "clr-sr-only"]], template: function ClrDatagridDetail_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrDatagridDetail_div_0_Template, 6, 6, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.detailService.isOpen);
    } }, directives: [ɵngcc1.NgIf, FocusTrapDirective], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridDetail, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-detail',
                host: {
                    '[class.datagrid-detail-pane]': 'true'
                },
                // We put the *ngIf on the clrFocusTrap so it doesn't always exist on the page
                // have to test for presence of header for aria-describedby because it was causing unit tests to crash
                template: "\n    <div [clrFocusTrap]=\"{strict: false}\" class=\"datagrid-detail-pane-content\" *ngIf=\"detailService.isOpen\" role=\"dialog\"\n         [id]=\"detailService.id\" aria-modal=\"true\" [attr.aria-describedby]=\"header ? header.titleId : ''\">\n    <div class=\"clr-sr-only\">{{commonStrings.keys.detailPaneStart}}</div>\n      <ng-content></ng-content>\n      <div class=\"clr-sr-only\">{{commonStrings.keys.detailPaneEnd}}</div>\n    </div>\n    "
            }]
    }], function () { return [{ type: DetailService }, { type: ClrCommonStringsService }]; }, { closeCheck: [{
            type: core.HostListener,
            args: ['document:keyup.esc']
        }], header: [{
            type: core.ContentChild,
            args: [ClrDatagridDetailHeader]
        }] }); })();
        return ClrDatagridDetail;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrIfDetail = /** @class */ (function () {
        function ClrIfDetail(templateRef, viewContainer, detailService) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.detailService = detailService;
            this.subscriptions = [];
            this.skip = false; // This keeps us from resetting the input and calling the toggle twice
            this.stateChange = new core.EventEmitter(null);
            this.detailService.enabled = true;
        }
        Object.defineProperty(ClrIfDetail.prototype, "state", {
            set: function (model) {
                if (!this.skip) {
                    this.detailService.toggle(model);
                }
                this.skip = false;
            },
            enumerable: true,
            configurable: true
        });
        ClrIfDetail.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.detailService.stateChange.subscribe(function (state) {
                if (state === true) {
                    _this.togglePanel(true);
                }
                else {
                    _this.togglePanel(false);
                }
            }));
        };
        ClrIfDetail.prototype.togglePanel = function (showPanel) {
            var stateChangeParams = null;
            this.viewContainer.clear();
            if (showPanel === true) {
                this.viewContainer.createEmbeddedView(this.templateRef, { $implicit: this.detailService.state });
                this.skip = true;
                stateChangeParams = this.detailService.state;
            }
            this.stateChange.emit(stateChangeParams);
        };
        ClrIfDetail.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrIfDetail.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: DetailService }
        ]; };
        __decorate([
            core.Input('clrIfDetail')
        ], ClrIfDetail.prototype, "state", null);
        __decorate([
            core.Output('clrIfDetailChange')
        ], ClrIfDetail.prototype, "stateChange", void 0);
ClrIfDetail.ɵfac = function ClrIfDetail_Factory(t) { return new (t || ClrIfDetail)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DetailService)); };
ClrIfDetail.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrIfDetail, selectors: [["", "clrIfDetail", ""]], inputs: { state: ["clrIfDetail", "state"] }, outputs: { stateChange: "clrIfDetailChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrIfDetail, [{
        type: core.Directive,
        args: [{
                selector: '[clrIfDetail]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: DetailService }]; }, { stateChange: [{
            type: core.Output,
            args: ['clrIfDetailChange']
        }], state: [{
            type: core.Input,
            args: ['clrIfDetail']
        }] }); })();
        return ClrIfDetail;
    }());

    var ClrDatagridDetailBody = /** @class */ (function () {
        function ClrDatagridDetailBody() {
        }
ClrDatagridDetailBody.ɵfac = function ClrDatagridDetailBody_Factory(t) { return new (t || ClrDatagridDetailBody)(); };
ClrDatagridDetailBody.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridDetailBody, selectors: [["clr-dg-detail-body"]], hostVars: 2, hostBindings: function ClrDatagridDetailBody_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-detail-body", true);
    } }, ngContentSelectors: _c1, decls: 2, vars: 0, consts: [[1, "clr-dg-detail-body-wrapper"]], template: function ClrDatagridDetailBody_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridDetailBody, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-detail-body',
                template: "\n    <div class=\"clr-dg-detail-body-wrapper\">\n      <ng-content></ng-content>\n    </div>\n  ",
                host: {
                    '[class.datagrid-detail-body]': 'true'
                }
            }]
    }], function () { return []; }, null); })();
        return ClrDatagridDetailBody;
    }());

    var ClrDatagridFooter = /** @class */ (function () {
        function ClrDatagridFooter(selection, detailService, columnsService) {
            this.selection = selection;
            this.detailService = detailService;
            this.columnsService = columnsService;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
        }
        Object.defineProperty(ClrDatagridFooter.prototype, "hasHideableColumns", {
            get: function () {
                return this.columnsService.hasHideableColumns;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridFooter.ctorParameters = function () { return [
            { type: Selection },
            { type: DetailService },
            { type: ColumnsService }
        ]; };
        __decorate([
            core.ContentChild(ClrDatagridColumnToggle)
        ], ClrDatagridFooter.prototype, "toggle", void 0);
ClrDatagridFooter.ɵfac = function ClrDatagridFooter_Factory(t) { return new (t || ClrDatagridFooter)(ɵngcc0.ɵɵdirectiveInject(Selection), ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(ColumnsService)); };
ClrDatagridFooter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridFooter, selectors: [["clr-dg-footer"]], contentQueries: function ClrDatagridFooter_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridColumnToggle, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggle = _t.first);
    } }, hostVars: 2, hostBindings: function ClrDatagridFooter_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("datagrid-footer", true);
    } }, ngContentSelectors: _c58, decls: 3, vars: 2, consts: [[4, "ngIf"], [1, "clr-form-control-disabled"], [1, "datagrid-footer-select"], ["clrCheckbox", "", "type", "checkbox", "checked", "checked", "disabled", ""], [1, "datagrid-footer-description"]], template: function ClrDatagridFooter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c57);
        ɵngcc0.ɵɵtemplate(0, ClrDatagridFooter_ng_container_0_Template, 6, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, ClrDatagridFooter_ng_container_1_Template, 5, 1, "ng-container", 0);
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Multi && ctx.selection.current.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.detailService.isOpen);
    } }, directives: [ɵngcc1.NgIf, ClrCheckboxWrapper,
        ClrCheckbox,
        ClrLabel,
        ClrDatagridColumnToggle], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridFooter, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-footer',
                template: "\n        <ng-container\n            *ngIf=\"(selection.selectionType === SELECTION_TYPE.Multi) && (selection.current.length > 0)\">\n          <div class=\"clr-form-control-disabled\">\n              <clr-checkbox-wrapper class=\"datagrid-footer-select\">\n                <input clrCheckbox type=\"checkbox\" checked=\"checked\" disabled>\n                <label>{{selection.current.length}}</label>\n            </clr-checkbox-wrapper>\n          </div>\n        </ng-container>\n        <ng-container *ngIf=\"!detailService.isOpen\">\n          <ng-content select=\"clr-dg-column-toggle\"></ng-content>\n          <clr-dg-column-toggle *ngIf=\"hasHideableColumns && !toggle\"></clr-dg-column-toggle>\n          <div class=\"datagrid-footer-description\">\n              <ng-content></ng-content>\n          </div>\n        </ng-container>\n        <ng-content select=\"clr-dg-pagination\"></ng-content>\n    ",
                host: {
                    '[class.datagrid-footer]': 'true'
                }
            }]
    }], function () { return [{ type: Selection }, { type: DetailService }, { type: ColumnsService }]; }, { toggle: [{
            type: core.ContentChild,
            args: [ClrDatagridColumnToggle]
        }] }); })();
        return ClrDatagridFooter;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var COLUMN_STATE = new core.InjectionToken('COLUMN_STATE');
    function columnStateFactory() {
        return new rxjs.BehaviorSubject({
            changes: [],
        });
    }
    var COLUMN_STATE_PROVIDER = {
        provide: COLUMN_STATE,
        useFactory: columnStateFactory,
    };

    var ClrDatagridHideableColumn = /** @class */ (function () {
        function ClrDatagridHideableColumn(titleTemplateRef, viewContainerRef, columnsService, columnState) {
            this.titleTemplateRef = titleTemplateRef;
            this.viewContainerRef = viewContainerRef;
            this.columnsService = columnsService;
            this.columnState = columnState;
            this.hiddenChange = new core.EventEmitter();
            this.subscriptions = [];
            this.viewContainerRef.createEmbeddedView(this.titleTemplateRef);
            if (!this.columnState) {
                throw new Error('The *clrDgHideableColumn directive can only be used inside of a clr-dg-column component.');
            }
        }
        Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHideableColumn", {
            /**
             *
             * @description
             * Setter fn for the @Input with the same name as this structural directive.
             * It allows the user to pre-configure the column's hide/show state. { hidden: true }
             * It's more verbose but has more Clarity.
             *
             *
             * @example
             * *clrDgHideableColumn
             * *clrDgHideableColumn={hidden: false}
             * *clrDgHideableColumn={hidden: true}
             *
             */
            set: function (value) {
                this.clrDgHidden = value && value.hidden ? value.hidden : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHidden", {
            set: function (hidden) {
                this._hidden = hidden ? hidden : false;
                this.columnsService.emitStateChange(this.columnState, {
                    hidden: this._hidden,
                    changes: [DatagridColumnChanges.HIDDEN],
                });
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridHideableColumn.prototype.ngOnInit = function () {
            var _this = this;
            this.columnsService.emitStateChange(this.columnState, {
                hideable: true,
                titleTemplateRef: this.titleTemplateRef,
                hidden: this._hidden,
                changes: [DatagridColumnChanges.HIDDEN],
            });
            this.subscriptions.push(this.columnState.subscribe(function (state) {
                if (state.changes && state.changes.indexOf(DatagridColumnChanges.HIDDEN) > -1) {
                    _this.hiddenChange.emit(state.hidden); // Can emit through @Output when desugared syntax is used
                }
            }));
        };
        ClrDatagridHideableColumn.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDatagridHideableColumn.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: ColumnsService },
            { type: rxjs.BehaviorSubject, decorators: [{ type: core.Optional }, { type: core.Inject, args: [COLUMN_STATE,] }] }
        ]; };
        __decorate([
            core.Input('clrDgHideableColumn')
        ], ClrDatagridHideableColumn.prototype, "clrDgHideableColumn", null);
        __decorate([
            core.Input('clrDgHidden')
        ], ClrDatagridHideableColumn.prototype, "clrDgHidden", null);
        __decorate([
            core.Output('clrDgHiddenChange')
        ], ClrDatagridHideableColumn.prototype, "hiddenChange", void 0);
        ClrDatagridHideableColumn = __decorate([ __param(3, core.Optional()),
            __param(3, core.Inject(COLUMN_STATE))
        ], ClrDatagridHideableColumn);
ClrDatagridHideableColumn.ɵfac = function ClrDatagridHideableColumn_Factory(t) { return new (t || ClrDatagridHideableColumn)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ColumnsService), ɵngcc0.ɵɵdirectiveInject(COLUMN_STATE, 8)); };
ClrDatagridHideableColumn.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDatagridHideableColumn, selectors: [["", "clrDgHideableColumn", ""]], inputs: { clrDgHideableColumn: "clrDgHideableColumn", clrDgHidden: "clrDgHidden" }, outputs: { hiddenChange: "clrDgHiddenChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridHideableColumn, [{
        type: core.Directive,
        args: [{ selector: '[clrDgHideableColumn]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: ColumnsService }, { type: ɵngcc3.BehaviorSubject, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [COLUMN_STATE]
            }] }]; }, { hiddenChange: [{
            type: core.Output,
            args: ['clrDgHiddenChange']
        }], clrDgHideableColumn: [{
            type: core.Input,
            args: ['clrDgHideableColumn']
        }], clrDgHidden: [{
            type: core.Input,
            args: ['clrDgHidden']
        }] }); })();
        return ClrDatagridHideableColumn;
    }());

    var ClrDatagridItemsTrackBy = /** @class */ (function () {
        function ClrDatagridItemsTrackBy(_items) {
            this._items = _items;
        }
        Object.defineProperty(ClrDatagridItemsTrackBy.prototype, "trackBy", {
            set: function (value) {
                if (this._items) {
                    this._items.trackBy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridItemsTrackBy.ctorParameters = function () { return [
            { type: Items, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input('ngForTrackBy')
        ], ClrDatagridItemsTrackBy.prototype, "trackBy", null);
        ClrDatagridItemsTrackBy = __decorate([ __param(0, core.Optional())
        ], ClrDatagridItemsTrackBy);
ClrDatagridItemsTrackBy.ɵfac = function ClrDatagridItemsTrackBy_Factory(t) { return new (t || ClrDatagridItemsTrackBy)(ɵngcc0.ɵɵdirectiveInject(Items, 8)); };
ClrDatagridItemsTrackBy.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDatagridItemsTrackBy, selectors: [["", "ngForTrackBy", ""]], inputs: { trackBy: ["ngForTrackBy", "trackBy"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridItemsTrackBy, [{
        type: core.Directive,
        args: [{
                selector: '[ngForTrackBy]'
            }]
    }], function () { return [{ type: Items, decorators: [{
                type: core.Optional
            }] }]; }, { trackBy: [{
            type: core.Input,
            args: ['ngForTrackBy']
        }] }); })();
        return ClrDatagridItemsTrackBy;
    }());

    var ClrDatagridPageSize = /** @class */ (function () {
        function ClrDatagridPageSize(page) {
            this.page = page;
        }
        ClrDatagridPageSize.prototype.ngOnInit = function () {
            if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
                this.pageSizeOptions = [this.page.size];
            }
        };
        ClrDatagridPageSize.ctorParameters = function () { return [
            { type: Page }
        ]; };
        __decorate([
            core.Input('clrPageSizeOptions')
        ], ClrDatagridPageSize.prototype, "pageSizeOptions", void 0);
ClrDatagridPageSize.ɵfac = function ClrDatagridPageSize_Factory(t) { return new (t || ClrDatagridPageSize)(ɵngcc0.ɵɵdirectiveInject(Page)); };
ClrDatagridPageSize.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridPageSize, selectors: [["clr-dg-page-size"]], inputs: { pageSizeOptions: ["clrPageSizeOptions", "pageSizeOptions"] }, ngContentSelectors: _c1, decls: 4, vars: 4, consts: [[1, "clr-select-wrapper"], [3, "ngModel", "ngModelChange"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"]], template: function ClrDatagridPageSize_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "select", 1);
        ɵngcc0.ɵɵlistener("ngModelChange", function ClrDatagridPageSize_Template_select_ngModelChange_2_listener($event) { return ctx.page.size = $event; });
        ɵngcc0.ɵɵtemplate(3, ClrDatagridPageSize_option_3_Template, 2, 2, "option", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("clr-page-size-select", true);
        ɵngcc0.ɵɵproperty("ngModel", ctx.page.size);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pageSizeOptions);
    } }, directives: [ɵngcc2.SelectControlValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ɵngcc1.NgForOf, ɵngcc2.NgSelectOption, ɵngcc2.ɵangular_packages_forms_forms_x], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridPageSize, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-page-size',
                template: "\n    <ng-content></ng-content>\n    <div class=\"clr-select-wrapper\">\n      <select [class.clr-page-size-select]=\"true\" [(ngModel)]=\"page.size\">\n        <option *ngFor=\"let option of pageSizeOptions\" [ngValue]=\"option\">{{option}}</option>\n      </select>\n    </div>\n  "
            }]
    }], function () { return [{ type: Page }]; }, { pageSizeOptions: [{
            type: core.Input,
            args: ['clrPageSizeOptions']
        }] }); })();
        return ClrDatagridPageSize;
    }());

    var ClrDatagridPagination = /** @class */ (function () {
        function ClrDatagridPagination(page, commonStrings, detailService) {
            this.page = page;
            this.commonStrings = commonStrings;
            this.detailService = detailService;
            this.currentChanged = new core.EventEmitter(false);
            this.page.activated = true;
        }
        /**********
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         */
        ClrDatagridPagination.prototype.ngOnInit = function () {
            var _this = this;
            /*
             * Default page size is 10.
             * The reason we set it here and not in the provider itself is because
             * we don't want pagination if this component isn't present in the datagrid.
             */
            if (!this.page.size) {
                this.page.size = 10;
            }
            this._pageSubscription = this.page.change.subscribe(function (current) { return _this.currentChanged.emit(current); });
        };
        ClrDatagridPagination.prototype.ngOnDestroy = function () {
            this.page.resetPageSize(true);
            if (this._pageSubscription) {
                this._pageSubscription.unsubscribe();
            }
        };
        Object.defineProperty(ClrDatagridPagination.prototype, "pageSize", {
            /**
             * Page size
             */
            get: function () {
                return this.page.size;
            },
            set: function (size) {
                if (typeof size === 'number') {
                    this.page.size = size;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "totalItems", {
            /**
             * Total items (needed to guess the last page)
             */
            get: function () {
                return this.page.totalItems;
            },
            set: function (total) {
                if (typeof total === 'number') {
                    this.page.totalItems = total;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "lastPage", {
            /**
             * Last page
             */
            get: function () {
                return this.page.last;
            },
            set: function (last) {
                if (typeof last === 'number') {
                    this.page.last = last;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "currentPage", {
            /**
             * Current page
             */
            get: function () {
                return this.page.current;
            },
            set: function (page) {
                if (typeof page === 'number') {
                    this.page.current = page;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Moves to the previous page if it exists
         */
        ClrDatagridPagination.prototype.previous = function () {
            this.page.previous();
        };
        /**
         * Moves to the next page if it exists
         */
        ClrDatagridPagination.prototype.next = function () {
            this.page.next();
        };
        Object.defineProperty(ClrDatagridPagination.prototype, "firstItem", {
            /**
             * Index of the first item displayed on the current page, starting at 0, -1 if none displayed
             */
            get: function () {
                return this.page.firstItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "lastItem", {
            /**
             * Index of the last item displayed on the current page, starting at 0, -1 if none displayed
             */
            get: function () {
                return this.page.lastItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "middlePages", {
            /**
             * Conditionally adds page numbers before and after the current page
             */
            get: function () {
                var middlePages = [];
                if (this.page.current > 1) {
                    middlePages.push(this.page.current - 1);
                }
                middlePages.push(this.page.current);
                if (this.page.current < this.page.last) {
                    middlePages.push(this.page.current + 1);
                }
                return middlePages;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         */
        ClrDatagridPagination.prototype.updateCurrentPage = function (event) {
            var parsed = parseInt(event.target.value, 10);
            // if the input value, is not a number, we don't update the page
            if (!isNaN(parsed)) {
                if (parsed < 1) {
                    this.page.current = 1;
                }
                else if (parsed > this.page.last) {
                    this.page.current = this.page.last;
                }
                else {
                    this.page.current = parsed;
                }
            }
            /**
             * Set the input's value to the new current page. This is needed because the code
             * above may have changed the value from what the user entered in.
             */
            this.currentPageInputRef.nativeElement.value = this.page.current;
        };
        ClrDatagridPagination.ctorParameters = function () { return [
            { type: Page },
            { type: ClrCommonStringsService },
            { type: DetailService }
        ]; };
        __decorate([
            core.ContentChild(ClrDatagridPageSize)
        ], ClrDatagridPagination.prototype, "_pageSizeComponent", void 0);
        __decorate([
            core.ViewChild('currentPageInput')
        ], ClrDatagridPagination.prototype, "currentPageInputRef", void 0);
        __decorate([
            core.Input('clrDgPageInputDisabled')
        ], ClrDatagridPagination.prototype, "disableCurrentPageInput", void 0);
        __decorate([
            core.Input('clrDgPageSize')
        ], ClrDatagridPagination.prototype, "pageSize", null);
        __decorate([
            core.Input('clrDgTotalItems')
        ], ClrDatagridPagination.prototype, "totalItems", null);
        __decorate([
            core.Input('clrDgLastPage')
        ], ClrDatagridPagination.prototype, "lastPage", null);
        __decorate([
            core.Input('clrDgPage')
        ], ClrDatagridPagination.prototype, "currentPage", null);
        __decorate([
            core.Output('clrDgPageChange')
        ], ClrDatagridPagination.prototype, "currentChanged", void 0);
ClrDatagridPagination.ɵfac = function ClrDatagridPagination_Factory(t) { return new (t || ClrDatagridPagination)(ɵngcc0.ɵɵdirectiveInject(Page), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(DetailService)); };
ClrDatagridPagination.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridPagination, selectors: [["clr-dg-pagination"]], contentQueries: function ClrDatagridPagination_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridPageSize, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._pageSizeComponent = _t.first);
    } }, viewQuery: function ClrDatagridPagination_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c59, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.currentPageInputRef = _t.first);
    } }, hostVars: 2, hostBindings: function ClrDatagridPagination_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("pagination", true);
    } }, inputs: { pageSize: ["clrDgPageSize", "pageSize"], totalItems: ["clrDgTotalItems", "totalItems"], lastPage: ["clrDgLastPage", "lastPage"], currentPage: ["clrDgPage", "currentPage"], disableCurrentPageInput: ["clrDgPageInputDisabled", "disableCurrentPageInput"] }, outputs: { currentChanged: "clrDgPageChange" }, ngContentSelectors: _c61, decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "pagination-size", 4, "ngIf"], [1, "pagination-description"], ["class", "pagination-list", 4, "ngIf"], [1, "pagination-size"], [1, "pagination-list"], ["type", "button", 1, "pagination-first", 3, "disabled", "click"], ["shape", "step-forward-2 down"], ["type", "button", 1, "pagination-previous", 3, "disabled", "click"], ["shape", "angle left"], ["type", "text", "class", "pagination-current clr-input", 3, "size", "value", "keydown.enter", "blur", 4, "ngIf", "ngIfElse"], ["readOnly", ""], ["type", "button", 1, "pagination-next", 3, "disabled", "click"], ["shape", "angle right"], ["type", "button", 1, "pagination-last", 3, "disabled", "click"], ["shape", "step-forward-2 up"], ["type", "text", 1, "pagination-current", "clr-input", 3, "size", "value", "keydown.enter", "blur"], ["currentPageInput", ""], [1, "pagination-description-compact"]], template: function ClrDatagridPagination_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c60);
        ɵngcc0.ɵɵtemplate(0, ClrDatagridPagination_ng_container_0_Template, 5, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, ClrDatagridPagination_ng_container_1_Template, 10, 8, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.detailService.isOpen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.detailService.isOpen);
    } }, directives: [ɵngcc1.NgIf, ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridPagination, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-pagination',
                template: "\n  <ng-container *ngIf=\"!detailService.isOpen\">\n    <div class=\"pagination-size\" *ngIf=\"_pageSizeComponent\">\n      <ng-content select=\"clr-dg-page-size\"></ng-content>\n    </div>\n    <div class=\"pagination-description\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"pagination-list\" *ngIf=\"page.last > 1\">\n      <button\n        type=\"button\" \n        class=\"pagination-first\" \n        [disabled]=\"page.current <= 1\" \n        (click)=\"page.current = 1\"\n        [attr.aria-label]=\"commonStrings.keys.firstPage\"\n        >\n        <clr-icon shape=\"step-forward-2 down\"></clr-icon>\n      </button>\n      <button \n        type=\"button\"\n        class=\"pagination-previous\" \n        [disabled]=\"page.current <= 1\" \n        (click)=\"page.current = page.current - 1\"\n        [attr.aria-label]=\"commonStrings.keys.previousPage\"\n        >\n        <clr-icon shape=\"angle left\"></clr-icon>\n      </button>\n        <input\n          *ngIf=\"!disableCurrentPageInput; else readOnly\"\n          #currentPageInput \n          type=\"text\" \n          class=\"pagination-current clr-input\" \n          [size]=\"page.last.toString().length\" \n          [value]=\"page.current\"\n          (keydown.enter)=\"updateCurrentPage($event)\" \n          (blur)=\"updateCurrentPage($event)\"\n          [attr.aria-label]=\"commonStrings.keys.currentPage\"\n          />\n          <ng-template #readOnly>\n            <span>{{ page.current }}</span>\n          </ng-template>\n\n          &nbsp;/&nbsp;<span [attr.aria-label]=\"commonStrings.keys.totalPages\">{{page.last}}</span>\n      <button \n        type=\"button\"\n        class=\"pagination-next\" \n        [disabled]=\"page.current >= page.last\" \n        (click)=\"page.current = page.current + 1\"\n        [attr.aria-label]=\"commonStrings.keys.nextPage\"\n        >\n        <clr-icon shape=\"angle right\"></clr-icon>\n      </button>\n      <button \n        type=\"button\" \n        class=\"pagination-last\" \n        [disabled]=\"page.current >= page.last\" \n        (click)=\"page.current = page.last\"\n        [attr.aria-label]=\"commonStrings.keys.lastPage\"\n        >\n        <clr-icon shape=\"step-forward-2 up\"></clr-icon>\n      </button>\n    </div>\n  </ng-container>\n  <ng-container *ngIf=\"detailService.isOpen\">\n      <div class=\"pagination-description-compact\">\n          {{page.firstItem + 1}}-{{page.lastItem + 1}} / {{page.totalItems}}\n      </div>\n      <div class=\"pagination-list\">\n          <button\n                  type=\"button\"\n                  class=\"pagination-previous\"\n                  [disabled]=\"page.current <= 1\"\n                  (click)=\"page.current = page.current - 1\"\n                  [attr.aria-label]=\"commonStrings.keys.previousPage\"\n          >\n              <clr-icon shape=\"angle left\"></clr-icon>\n          </button>\n          <span>{{page.current}}</span>\n          <button\n                  type=\"button\"\n                  class=\"pagination-next\"\n                  [disabled]=\"page.current >= page.last\"\n                  (click)=\"page.current = page.current + 1\"\n                  [attr.aria-label]=\"commonStrings.keys.nextPage\"\n          >\n              <clr-icon shape=\"angle right\"></clr-icon>\n          </button>\n      </div>\n  </ng-container>\n\n  ",
                host: { '[class.pagination]': 'true' }
            }]
    }], function () { return [{ type: Page }, { type: ClrCommonStringsService }, { type: DetailService }]; }, { currentChanged: [{
            type: core.Output,
            args: ['clrDgPageChange']
        }], pageSize: [{
            type: core.Input,
            args: ['clrDgPageSize']
        }], totalItems: [{
            type: core.Input,
            args: ['clrDgTotalItems']
        }], lastPage: [{
            type: core.Input,
            args: ['clrDgLastPage']
        }], currentPage: [{
            type: core.Input,
            args: ['clrDgPage']
        }], _pageSizeComponent: [{
            type: core.ContentChild,
            args: [ClrDatagridPageSize]
        }], currentPageInputRef: [{
            type: core.ViewChild,
            args: ['currentPageInput']
        }], disableCurrentPageInput: [{
            type: core.Input,
            args: ['clrDgPageInputDisabled']
        }] }); })();
        return ClrDatagridPagination;
    }());

    /**
     * Generic bland container serving various purposes for Datagrid.
     * For instance, it can help span a text over multiple rows in detail view.
     */
    var ClrDatagridRowDetail = /** @class */ (function () {
        function ClrDatagridRowDetail(selection, rowActionService, expand, expandableRows, commonStrings) {
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.expand = expand;
            this.expandableRows = expandableRows;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access it */
            this.SELECTION_TYPE = SelectionType;
            this.subscriptions = [];
            this.replacedRow = false;
        }
        Object.defineProperty(ClrDatagridRowDetail.prototype, "replace", {
            set: function (value) {
                this.expand.setReplace(!!value);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRowDetail.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.subscriptions.push(this.expand.replace.subscribe(function (replaceChange) {
                _this.replacedRow = replaceChange;
            }));
        };
        ClrDatagridRowDetail.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        Object.defineProperty(ClrDatagridRowDetail.prototype, "beginningOfExpandableContentAriaText", {
            get: function () {
                return (this._beginningOfExpandableContentAriaText ||
                    this.commonStrings.keys.dategridExpandableBeginningOf + " " + this.commonStrings.keys.dategridExpandableRowContent);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridRowDetail.prototype, "endOfExpandableContentAriaText", {
            get: function () {
                return (this._endOfExpandableContentAriaText ||
                    this.commonStrings.keys.dategridExpandableEndOf + " " + this.commonStrings.keys.dategridExpandableRowContent);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRowDetail.ctorParameters = function () { return [
            { type: Selection },
            { type: RowActionService },
            { type: DatagridIfExpandService },
            { type: ExpandableRowsCount },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.ContentChildren(ClrDatagridCell)
        ], ClrDatagridRowDetail.prototype, "cells", void 0);
        __decorate([
            core.Input('clrDgReplace')
        ], ClrDatagridRowDetail.prototype, "replace", null);
        __decorate([
            core.Input('clrRowDetailBeginningAriaText')
        ], ClrDatagridRowDetail.prototype, "_beginningOfExpandableContentAriaText", void 0);
        __decorate([
            core.Input('clrRowDetailEndAriaText')
        ], ClrDatagridRowDetail.prototype, "_endOfExpandableContentAriaText", void 0);
ClrDatagridRowDetail.ɵfac = function ClrDatagridRowDetail_Factory(t) { return new (t || ClrDatagridRowDetail)(ɵngcc0.ɵɵdirectiveInject(Selection), ɵngcc0.ɵɵdirectiveInject(RowActionService), ɵngcc0.ɵɵdirectiveInject(DatagridIfExpandService), ɵngcc0.ɵɵdirectiveInject(ExpandableRowsCount), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrDatagridRowDetail.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDatagridRowDetail, selectors: [["clr-dg-row-detail"]], contentQueries: function ClrDatagridRowDetail_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrDatagridCell, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cells = _t);
    } }, hostVars: 7, hostBindings: function ClrDatagridRowDetail_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.expand.expandableId);
        ɵngcc0.ɵɵclassProp("datagrid-row-flex", true)("datagrid-row-detail", true)("datagrid-container", ctx.cells.length === 0);
    } }, inputs: { replace: ["clrDgReplace", "replace"], _beginningOfExpandableContentAriaText: ["clrRowDetailBeginningAriaText", "_beginningOfExpandableContentAriaText"], _endOfExpandableContentAriaText: ["clrRowDetailEndAriaText", "_endOfExpandableContentAriaText"] }, ngContentSelectors: _c1, decls: 5, vars: 3, consts: [[1, "clr-sr-only"]], template: function ClrDatagridRowDetail_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementStart(3, "div", 0);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.beginningOfExpandableContentAriaText, " ", ctx.commonStrings.keys.dategridExpandableRowsHelperText, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.endOfExpandableContentAriaText);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridRowDetail, [{
        type: core.Component,
        args: [{
                selector: 'clr-dg-row-detail',
                template: "\n    <div class=\"clr-sr-only\">\n      {{ beginningOfExpandableContentAriaText }} {{ commonStrings.keys.dategridExpandableRowsHelperText }}\n    </div>\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\">{{ endOfExpandableContentAriaText }}</div>\n  ",
                host: {
                    '[class.datagrid-row-flex]': 'true',
                    '[class.datagrid-row-detail]': 'true',
                    '[class.datagrid-container]': 'cells.length === 0',
                    '[attr.id]': 'expand.expandableId'
                }
            }]
    }], function () { return [{ type: Selection }, { type: RowActionService }, { type: DatagridIfExpandService }, { type: ExpandableRowsCount }, { type: ClrCommonStringsService }]; }, { replace: [{
            type: core.Input,
            args: ['clrDgReplace']
        }], cells: [{
            type: core.ContentChildren,
            args: [ClrDatagridCell]
        }], _beginningOfExpandableContentAriaText: [{
            type: core.Input,
            args: ['clrRowDetailBeginningAriaText']
        }], _endOfExpandableContentAriaText: [{
            type: core.Input,
            args: ['clrRowDetailEndAriaText']
        }] }); })();
        return ClrDatagridRowDetail;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // @TODO The top two are not used now, which is probably a performance drag that was broken along the way.
    // There was a previous pattern to hide everything to do computation then display, for Firefox, needs revisiting.
    var NO_LAYOUT_CLASS = 'datagrid-no-layout';
    var COMPUTE_WIDTH_CLASS = 'datagrid-computing-columns-width';
    var STRICT_WIDTH_CLASS = 'datagrid-fixed-width';
    var HIDDEN_COLUMN_CLASS = 'datagrid-hidden-column';

    var DatagridCellRenderer = /** @class */ (function () {
        function DatagridCellRenderer(el, renderer, organizer) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.subscriptions = [];
            this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
        }
        Object.defineProperty(DatagridCellRenderer.prototype, "columnState", {
            // @TODO(JEREMY) Work out how to dedupe some of this code between header and cell renderers
            set: function (columnState) {
                var _this = this;
                if (this.stateSubscription) {
                    this.stateSubscription.unsubscribe();
                }
                this.runAllChanges = ALL_COLUMN_CHANGES;
                this.stateSubscription = columnState.subscribe(function (state) { return _this.stateChanges(state); });
            },
            enumerable: true,
            configurable: true
        });
        DatagridCellRenderer.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            if (this.stateSubscription) {
                this.stateSubscription.unsubscribe();
            }
        };
        DatagridCellRenderer.prototype.stateChanges = function (state) {
            var _this = this;
            if (this.runAllChanges) {
                state.changes = this.runAllChanges;
                delete this.runAllChanges;
            }
            if (state.changes && state.changes.length) {
                state.changes.forEach(function (change) {
                    switch (change) {
                        case DatagridColumnChanges.WIDTH:
                            _this.setWidth(state);
                            break;
                        case DatagridColumnChanges.HIDDEN:
                            _this.setHidden(state);
                            break;
                        default:
                            break;
                    }
                });
            }
        };
        DatagridCellRenderer.prototype.clearWidth = function () {
            this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            this.renderer.setStyle(this.el.nativeElement, 'width', null);
        };
        DatagridCellRenderer.prototype.setWidth = function (state) {
            if (state.strictWidth) {
                this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            }
            this.renderer.setStyle(this.el.nativeElement, 'width', state.width + 'px');
        };
        DatagridCellRenderer.prototype.setHidden = function (state) {
            if (state.hidden) {
                this.renderer.addClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
            }
        };
        DatagridCellRenderer.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: DatagridRenderOrganizer }
        ]; };
DatagridCellRenderer.ɵfac = function DatagridCellRenderer_Factory(t) { return new (t || DatagridCellRenderer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DatagridRenderOrganizer)); };
DatagridCellRenderer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridCellRenderer, selectors: [["clr-dg-cell"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridCellRenderer, [{
        type: core.Directive,
        args: [{ selector: 'clr-dg-cell' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DatagridRenderOrganizer }]; }, null); })();
        return DatagridCellRenderer;
    }());

    var DatagridHeaderRenderer = /** @class */ (function () {
        function DatagridHeaderRenderer(el, renderer, organizer, domAdapter, columnResizerService, columnsService, columnState) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.organizer = organizer;
            this.domAdapter = domAdapter;
            this.columnResizerService = columnResizerService;
            this.columnsService = columnsService;
            this.columnState = columnState;
            this.resizeEmitter = new core.EventEmitter();
            /**
             * Indicates if the column has a strict width, so it doesn't shrink or expand based on the content.
             */
            this.widthSet = false;
            this.autoSet = false;
            this.subscriptions = [];
            this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
            this.subscriptions.push(columnState.subscribe(function (state) { return _this.stateChanges(state); }));
        }
        DatagridHeaderRenderer.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        DatagridHeaderRenderer.prototype.stateChanges = function (state) {
            var _this = this;
            if (state.changes && state.changes.length) {
                state.changes.forEach(function (change) {
                    switch (change) {
                        case DatagridColumnChanges.WIDTH:
                            _this.setWidth(state);
                            break;
                        case DatagridColumnChanges.HIDDEN:
                            _this.setHidden(state);
                            break;
                        default:
                            break;
                    }
                });
            }
        };
        DatagridHeaderRenderer.prototype.clearWidth = function () {
            // remove the width only if we set it, and it is not changed by dragging.
            if (this.widthSet && !this.columnResizerService.resizedBy) {
                this.renderer.setStyle(this.el.nativeElement, 'width', null);
            }
            if (this.autoSet) {
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            }
        };
        DatagridHeaderRenderer.prototype.detectStrictWidth = function () {
            if (this.columnResizerService.resizedBy) {
                return this.columnResizerService.widthAfterResize;
            }
            else if (this.autoSet) {
                return 0;
            }
            else {
                return this.domAdapter.userDefinedWidth(this.el.nativeElement);
            }
        };
        DatagridHeaderRenderer.prototype.computeWidth = function (strictWidth) {
            var width = strictWidth;
            if (!width) {
                width = this.domAdapter.scrollWidth(this.el.nativeElement);
            }
            return width;
        };
        DatagridHeaderRenderer.prototype.getColumnWidthState = function () {
            var strictWidth = this.detectStrictWidth();
            return {
                width: this.computeWidth(strictWidth),
                strictWidth: strictWidth,
            };
        };
        DatagridHeaderRenderer.prototype.setColumnState = function (index) {
            this.columnsService.columns[index] = this.columnState;
        };
        DatagridHeaderRenderer.prototype.setWidth = function (state) {
            if (state.strictWidth) {
                if (this.columnResizerService.resizedBy) {
                    this.resizeEmitter.emit(state.width);
                    this.renderer.setStyle(this.el.nativeElement, 'width', state.width + 'px');
                    this.widthSet = false;
                }
                // Don't set width if there is a user-defined one. Just add the strict width class.
                this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                this.autoSet = false;
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                this.renderer.setStyle(this.el.nativeElement, 'width', state.width + 'px');
                this.widthSet = true;
                this.autoSet = true;
            }
        };
        DatagridHeaderRenderer.prototype.setHidden = function (state) {
            if (state.hidden) {
                this.renderer.addClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
            }
        };
        DatagridHeaderRenderer.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: DatagridRenderOrganizer },
            { type: DomAdapter },
            { type: ColumnResizerService },
            { type: ColumnsService },
            { type: rxjs.BehaviorSubject, decorators: [{ type: core.Inject, args: [COLUMN_STATE,] }] }
        ]; };
        __decorate([
            core.Output('clrDgColumnResize')
        ], DatagridHeaderRenderer.prototype, "resizeEmitter", void 0);
        DatagridHeaderRenderer = __decorate([ __param(6, core.Inject(COLUMN_STATE))
        ], DatagridHeaderRenderer);
DatagridHeaderRenderer.ɵfac = function DatagridHeaderRenderer_Factory(t) { return new (t || DatagridHeaderRenderer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DatagridRenderOrganizer), ɵngcc0.ɵɵdirectiveInject(DomAdapter), ɵngcc0.ɵɵdirectiveInject(ColumnResizerService), ɵngcc0.ɵɵdirectiveInject(ColumnsService), ɵngcc0.ɵɵdirectiveInject(COLUMN_STATE)); };
DatagridHeaderRenderer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridHeaderRenderer, selectors: [["clr-dg-column"]], outputs: { resizeEmitter: "clrDgColumnResize" }, features: [ɵngcc0.ɵɵProvidersFeature([ColumnResizerService, COLUMN_STATE_PROVIDER])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridHeaderRenderer, [{
        type: core.Directive,
        args: [{ selector: 'clr-dg-column', providers: [ColumnResizerService, COLUMN_STATE_PROVIDER] }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DatagridRenderOrganizer }, { type: DomAdapter }, { type: ColumnResizerService }, { type: ColumnsService }, { type: ɵngcc3.BehaviorSubject, decorators: [{
                type: core.Inject,
                args: [COLUMN_STATE]
            }] }]; }, { resizeEmitter: [{
            type: core.Output,
            args: ['clrDgColumnResize']
        }] }); })();
        return DatagridHeaderRenderer;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var NoopDomAdapter = /** @class */ (function () {
        function NoopDomAdapter() {
        }
        NoopDomAdapter.prototype.userDefinedWidth = function (element) {
            return 0;
        };
        NoopDomAdapter.prototype.scrollBarWidth = function (element) {
            return 0;
        };
        NoopDomAdapter.prototype.scrollWidth = function (element) {
            return 0;
        };
        NoopDomAdapter.prototype.computedHeight = function (element) {
            return 0;
        };
        NoopDomAdapter.prototype.clientRect = function (element) {
            return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0,
            };
        };
        NoopDomAdapter.prototype.minWidth = function (element) {
            return 0;
        };
        NoopDomAdapter.prototype.focus = function (element) { };
NoopDomAdapter.ɵfac = function NoopDomAdapter_Factory(t) { return new (t || NoopDomAdapter)(); };
NoopDomAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NoopDomAdapter, factory: function (t) { return NoopDomAdapter.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NoopDomAdapter, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return NoopDomAdapter;
    }());

    var DatagridRowRenderer = /** @class */ (function () {
        function DatagridRowRenderer(columnsService) {
            this.columnsService = columnsService;
            this.subscriptions = [];
        }
        DatagridRowRenderer.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.setColumnState(); // case #3 and #4
            this.subscriptions.push(this.cells.changes.subscribe(function () {
                _this.setColumnState(); // case #2
                // Note on case #2: In the case of dynamic columns, when one column (header/cell together) gets deleted,
                // this.cells.changes emits before this.columnsService.columns gets updated in MainRenderer
                // when this.headers.changes emits as well. So that means there will be n+1 column state providers
                // when this.cells.changes emits. Hence, we should quit earlier there. But this method will be called
                // right after again when this.headers.changes emits. By then, there will be the same number of column state
                // providers as column headers.
            }));
        };
        DatagridRowRenderer.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        DatagridRowRenderer.prototype.setColumnState = function () {
            var _this = this;
            // This method runs in four cases:
            // 1. When the initial rows appear on the first page.
            //    In this case, the method will be called in DatagridMainRenderer.
            // 2. When columns (corresponding header/cells) get added and deleted.
            //    In this case, the method will be called in DatagridMainRenderer. (Read the note on this case above).
            // 3. When rows load asynchronously.
            //    In this case, the method will be called in this class.
            // 4. When rows load after switching pages.
            //    In this case, the method will be called in this class (Basically, same as the case 3).
            if (this.cells.length === this.columnsService.columns.length) {
                this.cells.forEach(function (cell, index) {
                    if (_this.columnsService.columns[index]) {
                        cell.columnState = _this.columnsService.columns[index];
                    }
                });
            }
        };
        DatagridRowRenderer.ctorParameters = function () { return [
            { type: ColumnsService }
        ]; };
        __decorate([
            core.ContentChildren(DatagridCellRenderer)
        ], DatagridRowRenderer.prototype, "cells", void 0);
DatagridRowRenderer.ɵfac = function DatagridRowRenderer_Factory(t) { return new (t || DatagridRowRenderer)(ɵngcc0.ɵɵdirectiveInject(ColumnsService)); };
DatagridRowRenderer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridRowRenderer, selectors: [["clr-dg-row"], ["clr-dg-row-detail"]], contentQueries: function DatagridRowRenderer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DatagridCellRenderer, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cells = _t);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridRowRenderer, [{
        type: core.Directive,
        args: [{ selector: 'clr-dg-row, clr-dg-row-detail' }]
    }], function () { return [{ type: ColumnsService }]; }, { cells: [{
            type: core.ContentChildren,
            args: [DatagridCellRenderer]
        }] }); })();
        return DatagridRowRenderer;
    }());

    // Fixes build error
    // @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
    var domAdapterFactory = function (platformId) {
        if (common.isPlatformBrowser(platformId)) {
            return new DomAdapter();
        }
        else {
            return new NoopDomAdapter();
        }
    };
    // Fixes build error
    // @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
    var DatagridMainRenderer = /** @class */ (function () {
        function DatagridMainRenderer(organizer, items, page, domAdapter, el, renderer, detailService, tableSizeService, columnsService) {
            var _this = this;
            this.organizer = organizer;
            this.items = items;
            this.page = page;
            this.domAdapter = domAdapter;
            this.el = el;
            this.renderer = renderer;
            this.detailService = detailService;
            this.tableSizeService = tableSizeService;
            this.columnsService = columnsService;
            this._heightSet = false;
            this.subscriptions = [];
            /**
             * Indicates if we want to re-compute columns width. This should only happen:
             * 1) When headers change, with columns being added or removed
             * 2) When rows are lazily loaded for the first time
             */
            this.columnsSizesStable = false;
            this.shouldStabilizeColumns = true;
            this.subscriptions.push(this.organizer
                .filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS)
                .subscribe(function () { return _this.computeHeadersWidth(); }));
            this.subscriptions.push(this.page.sizeChange.subscribe(function () {
                if (_this._heightSet) {
                    _this.resetDatagridHeight();
                }
            }));
            this.subscriptions.push(this.detailService.stateChange.subscribe(function (state) { return _this.toggleDetailPane(state); }));
            this.subscriptions.push(this.items.change.subscribe(function () { return (_this.shouldStabilizeColumns = true); }));
        }
        DatagridMainRenderer.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.setupColumns();
            this.subscriptions.push(this.headers.changes.subscribe(function () {
                // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
                // Need to setup columns before stabalizing them
                _this.setupColumns();
                _this.columnsSizesStable = false;
                _this.stabilizeColumns();
            }));
        };
        // Initialize and set Table width for horizontal scrolling here.
        DatagridMainRenderer.prototype.ngAfterViewInit = function () {
            this.tableSizeService.table = this.el;
        };
        DatagridMainRenderer.prototype.ngAfterViewChecked = function () {
            var _this = this;
            if (this.shouldStabilizeColumns) {
                this.stabilizeColumns();
            }
            if (this.shouldComputeHeight()) {
                setTimeout(function () {
                    _this.computeDatagridHeight();
                });
            }
        };
        DatagridMainRenderer.prototype.setupColumns = function () {
            this.headers.forEach(function (header, index) { return header.setColumnState(index); });
            this.columnsService.columns.splice(this.headers.length); // Trim any old columns
            this.rows.forEach(function (row) { return row.setColumnState(); });
        };
        DatagridMainRenderer.prototype.shouldComputeHeight = function () {
            if (!this._heightSet && this.page.size > 0) {
                if (this.items.displayed.length === this.page.size) {
                    return true;
                }
            }
            return false;
        };
        DatagridMainRenderer.prototype.toggleDetailPane = function (state) {
            var _this = this;
            if (this.headers) {
                if (state && !this.columnsService.hasCache()) {
                    this.columnsService.cache();
                    this.headers.forEach(function (header, index) {
                        if (index > 0) {
                            _this.columnsService.emitStateChangeAt(index, {
                                changes: [DatagridColumnChanges.HIDDEN],
                                hidden: state,
                            });
                        }
                    });
                }
                else if (!state) {
                    this.columnsService.resetToLastCache();
                }
            }
        };
        /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         */
        DatagridMainRenderer.prototype.computeDatagridHeight = function () {
            // IE doesn't return correct value for getComputedStyle(element).getPropertyValue("height")
            var value = this.domAdapter.clientRect(this.el.nativeElement).height;
            this.renderer.setStyle(this.el.nativeElement, 'height', value + 'px');
            this._heightSet = true;
        };
        DatagridMainRenderer.prototype.resetDatagridHeight = function () {
            this.renderer.setStyle(this.el.nativeElement, 'height', '');
            this._heightSet = false;
        };
        DatagridMainRenderer.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        /**
         * Makes each header compute its width.
         */
        DatagridMainRenderer.prototype.computeHeadersWidth = function () {
            var _this = this;
            var nbColumns = this.headers.length;
            var allStrict = true;
            this.headers.forEach(function (header, index) {
                // On the last header column check whether all columns have strict widths.
                // If all columns have strict widths, remove the strict width from the last column and make it the column's
                // minimum width so that when all previous columns shrink, it will get a flexible width and cover the empty
                // gap in the Datagrid.
                var state = __assign({ changes: [DatagridColumnChanges.WIDTH] }, header.getColumnWidthState());
                if (!state.strictWidth) {
                    allStrict = false;
                }
                if (nbColumns === index + 1 && allStrict) {
                    state.strictWidth = 0;
                }
                _this.columnsService.emitStateChangeAt(index, state);
            });
        };
        /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         */
        DatagridMainRenderer.prototype.stabilizeColumns = function () {
            this.shouldStabilizeColumns = false;
            if (this.columnsSizesStable) {
                // Nothing to do.
                return;
            }
            // Resize when the rows are loaded.
            if (this.items.displayed.length > 0) {
                this.organizer.resize();
                this.columnsSizesStable = true;
            }
        };
        DatagridMainRenderer.ctorParameters = function () { return [
            { type: DatagridRenderOrganizer },
            { type: Items },
            { type: Page },
            { type: DomAdapter },
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: DetailService },
            { type: TableSizeService },
            { type: ColumnsService }
        ]; };
        __decorate([
            core.ContentChildren(DatagridHeaderRenderer)
        ], DatagridMainRenderer.prototype, "headers", void 0);
        __decorate([
            core.ContentChildren(DatagridRowRenderer, { descendants: true })
        ], DatagridMainRenderer.prototype, "rows", void 0);
DatagridMainRenderer.ɵfac = function DatagridMainRenderer_Factory(t) { return new (t || DatagridMainRenderer)(ɵngcc0.ɵɵdirectiveInject(DatagridRenderOrganizer), ɵngcc0.ɵɵdirectiveInject(Items), ɵngcc0.ɵɵdirectiveInject(Page), ɵngcc0.ɵɵdirectiveInject(DomAdapter), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DetailService), ɵngcc0.ɵɵdirectiveInject(TableSizeService), ɵngcc0.ɵɵdirectiveInject(ColumnsService)); };
DatagridMainRenderer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridMainRenderer, selectors: [["clr-datagrid"]], contentQueries: function DatagridMainRenderer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DatagridHeaderRenderer, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DatagridRowRenderer, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headers = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rows = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: DomAdapter, useFactory: domAdapterFactory, deps: [core.PLATFORM_ID] }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridMainRenderer, [{
        type: core.Directive,
        args: [{
                selector: 'clr-datagrid',
                providers: [{ provide: DomAdapter, useFactory: domAdapterFactory, deps: [core.PLATFORM_ID] }]
            }]
    }], function () { return [{ type: DatagridRenderOrganizer }, { type: Items }, { type: Page }, { type: DomAdapter }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DetailService }, { type: TableSizeService }, { type: ColumnsService }]; }, { headers: [{
            type: core.ContentChildren,
            args: [DatagridHeaderRenderer]
        }], rows: [{
            type: core.ContentChildren,
            args: [DatagridRowRenderer, { descendants: true }]
        }] }); })();
        return DatagridMainRenderer;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_DATAGRID_DIRECTIVES = [
        // Core
        ClrDatagrid,
        ClrDatagridActionBar,
        ClrDatagridActionOverflow,
        ClrDatagridColumn,
        ClrDatagridColumnSeparator,
        ClrDatagridColumnToggle,
        ClrDatagridHideableColumn,
        ClrDatagridFilter,
        ClrDatagridItems,
        ClrDatagridItemsTrackBy,
        ClrDatagridRow,
        ClrDatagridRowDetail,
        DatagridDetailRegisterer,
        ClrDatagridCell,
        ClrDatagridFooter,
        ClrDatagridPagination,
        ClrDatagridPageSize,
        ClrDatagridPlaceholder,
        ClrDatagridColumnToggleButton,
        ClrDatagridColumnToggleTitle,
        ClrDatagridDetail,
        ClrIfDetail,
        ClrDatagridDetailHeader,
        ClrDatagridDetailBody,
        WrappedCell,
        WrappedColumn,
        WrappedRow,
        // Renderers
        DatagridMainRenderer,
        DatagridHeaderRenderer,
        DatagridRowRenderer,
        DatagridCellRenderer,
        // Chocolate
        DatagridWillyWonka,
        ActionableOompaLoompa,
        ExpandableOompaLoompa,
        // Built-in shortcuts
        DatagridStringFilter,
        DatagridNumericFilter,
    ];
    var ClrDatagridModule = /** @class */ (function () {
        function ClrDatagridModule() {
        }
ClrDatagridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrDatagridModule });
ClrDatagridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrDatagridModule_Factory(t) { return new (t || ClrDatagridModule)(); }, imports: [[
            common.CommonModule,
            ClrIconModule,
            ClrFormsModule,
            forms.FormsModule,
            ClrLoadingModule,
            ClrConditionalModule,
            ClrOutsideClickModule,
            ClrExpandableAnimationModule,
            ClrDragAndDropModule,
            ClrSpinnerModule,
            ClrPopoverModuleNext,
            ClrFocusTrapModule,
            ClrFocusOnViewInitModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrDatagridModule, { declarations: [ClrDatagrid,
        ClrDatagridActionBar,
        ClrDatagridActionOverflow,
        ClrDatagridColumn,
        ClrDatagridColumnSeparator,
        ClrDatagridColumnToggle,
        ClrDatagridHideableColumn,
        ClrDatagridFilter,
        ClrDatagridItems,
        ClrDatagridItemsTrackBy,
        ClrDatagridRow,
        ClrDatagridRowDetail,
        DatagridDetailRegisterer,
        ClrDatagridCell,
        ClrDatagridFooter,
        ClrDatagridPagination,
        ClrDatagridPageSize,
        ClrDatagridPlaceholder,
        ClrDatagridColumnToggleButton,
        ClrDatagridColumnToggleTitle,
        ClrDatagridDetail,
        ClrIfDetail,
        ClrDatagridDetailHeader,
        ClrDatagridDetailBody,
        WrappedCell,
        WrappedColumn,
        WrappedRow,
        DatagridMainRenderer,
        DatagridHeaderRenderer,
        DatagridRowRenderer,
        DatagridCellRenderer,
        DatagridWillyWonka,
        ActionableOompaLoompa,
        ExpandableOompaLoompa,
        DatagridStringFilter,
        DatagridNumericFilter], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrFormsModule, ɵngcc2.FormsModule, ClrLoadingModule,
        ClrConditionalModule,
        ClrOutsideClickModule,
        ClrExpandableAnimationModule,
        ClrDragAndDropModule,
        ClrSpinnerModule,
        ClrPopoverModuleNext,
        ClrFocusTrapModule,
        ClrFocusOnViewInitModule], exports: [ClrDatagrid,
        ClrDatagridActionBar,
        ClrDatagridActionOverflow,
        ClrDatagridColumn,
        ClrDatagridColumnSeparator,
        ClrDatagridColumnToggle,
        ClrDatagridHideableColumn,
        ClrDatagridFilter,
        ClrDatagridItems,
        ClrDatagridItemsTrackBy,
        ClrDatagridRow,
        ClrDatagridRowDetail,
        DatagridDetailRegisterer,
        ClrDatagridCell,
        ClrDatagridFooter,
        ClrDatagridPagination,
        ClrDatagridPageSize,
        ClrDatagridPlaceholder,
        ClrDatagridColumnToggleButton,
        ClrDatagridColumnToggleTitle,
        ClrDatagridDetail,
        ClrIfDetail,
        ClrDatagridDetailHeader,
        ClrDatagridDetailBody,
        WrappedCell,
        WrappedColumn,
        WrappedRow,
        DatagridMainRenderer,
        DatagridHeaderRenderer,
        DatagridRowRenderer,
        DatagridCellRenderer,
        DatagridWillyWonka,
        ActionableOompaLoompa,
        ExpandableOompaLoompa,
        DatagridStringFilter,
        DatagridNumericFilter] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDatagridModule, [{
        type: core.NgModule,
        args: [{
                imports: [
                    common.CommonModule,
                    ClrIconModule,
                    ClrFormsModule,
                    forms.FormsModule,
                    ClrLoadingModule,
                    ClrConditionalModule,
                    ClrOutsideClickModule,
                    ClrExpandableAnimationModule,
                    ClrDragAndDropModule,
                    ClrSpinnerModule,
                    ClrPopoverModuleNext,
                    ClrFocusTrapModule,
                    ClrFocusOnViewInitModule,
                ],
                declarations: [CLR_DATAGRID_DIRECTIVES],
                exports: [CLR_DATAGRID_DIRECTIVES],
                entryComponents: [WrappedCell, WrappedColumn, WrappedRow]
            }]
    }], function () { return []; }, null); })();
        return ClrDatagridModule;
    }());

    var ClrStackBlock = /** @class */ (function () {
        /*
         * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
         * querying for children StackBlocks, but this feature is not available when downgrading
         * the component for Angular 1.
         */
        function ClrStackBlock(parent, uniqueId, commonStrings) {
            this.parent = parent;
            this.uniqueId = uniqueId;
            this.commonStrings = commonStrings;
            this.expanded = false;
            this.expandedChange = new core.EventEmitter(false);
            this.expandable = false;
            this.focused = false;
            this._changedChildren = 0;
            this._fullyInitialized = false;
            this._changed = false;
            if (parent) {
                parent.addChild();
            }
        }
        Object.defineProperty(ClrStackBlock.prototype, "getChangedValue", {
            get: function () {
                return this._changed || (this._changedChildren > 0 && !this.expanded);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "setChangedValue", {
            set: function (value) {
                this._changed = value;
                if (this.parent && this._fullyInitialized) {
                    if (value) {
                        this.parent._changedChildren++;
                    }
                    else {
                        this.parent._changedChildren--;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrStackBlock.prototype.ngOnInit = function () {
            // in order to access the parent ClrStackBlock's properties,
            // the child ClrStackBlock has to be fully initialized at first.
            this._fullyInitialized = true;
        };
        ClrStackBlock.prototype.addChild = function () {
            this.expandable = true;
        };
        ClrStackBlock.prototype.toggleExpand = function () {
            if (this.expandable) {
                this.expanded = !this.expanded;
                this.expandedChange.emit(this.expanded);
            }
        };
        Object.defineProperty(ClrStackBlock.prototype, "caretDirection", {
            get: function () {
                return this.expanded ? 'down' : 'right';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "role", {
            get: function () {
                return this.expandable ? 'button' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "tabIndex", {
            get: function () {
                return this.expandable ? '0' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "onStackLabelFocus", {
            get: function () {
                return this.expandable && !this.expanded && this.focused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "ariaExpanded", {
            get: function () {
                if (!this.expandable) {
                    return null;
                }
                else {
                    return this.expanded ? 'true' : 'false';
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrStackBlock.prototype.getStackChildrenId = function () {
            return this.expanded ? "clr-stack-children-" + this.uniqueId : null;
        };
        ClrStackBlock.ctorParameters = function () { return [
            { type: ClrStackBlock, decorators: [{ type: core.SkipSelf }, { type: core.Optional }] },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.HostBinding('class.stack-block-expanded'),
            core.Input('clrSbExpanded')
        ], ClrStackBlock.prototype, "expanded", void 0);
        __decorate([
            core.Output('clrSbExpandedChange')
        ], ClrStackBlock.prototype, "expandedChange", void 0);
        __decorate([
            core.HostBinding('class.stack-block-expandable'),
            core.Input('clrSbExpandable')
        ], ClrStackBlock.prototype, "expandable", void 0);
        __decorate([
            core.HostBinding('class.stack-block-changed')
        ], ClrStackBlock.prototype, "getChangedValue", null);
        __decorate([
            core.Input('clrSbNotifyChange')
        ], ClrStackBlock.prototype, "setChangedValue", null);
        __decorate([
            core.Input('clrStackViewLevel')
        ], ClrStackBlock.prototype, "ariaLevel", void 0);
        __decorate([
            core.Input('clrStackViewSetsize')
        ], ClrStackBlock.prototype, "ariaSetsize", void 0);
        __decorate([
            core.Input('clrStackViewPosinset')
        ], ClrStackBlock.prototype, "ariaPosinset", void 0);
        __decorate([
            core.HostBinding('class.on-focus')
        ], ClrStackBlock.prototype, "onStackLabelFocus", null);
        ClrStackBlock = __decorate([ __param(0, core.SkipSelf()),
            __param(0, core.Optional()),
            __param(1, core.Inject(UNIQUE_ID))
        ], ClrStackBlock);
ClrStackBlock.ɵfac = function ClrStackBlock_Factory(t) { return new (t || ClrStackBlock)(ɵngcc0.ɵɵdirectiveInject(ClrStackBlock, 12), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrStackBlock.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStackBlock, selectors: [["clr-stack-block"]], hostVars: 10, hostBindings: function ClrStackBlock_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("stack-block", true)("stack-block-expanded", ctx.expanded)("stack-block-expandable", ctx.expandable)("stack-block-changed", ctx.getChangedValue)("on-focus", ctx.onStackLabelFocus);
    } }, inputs: { expanded: ["clrSbExpanded", "expanded"], expandable: ["clrSbExpandable", "expandable"], setChangedValue: ["clrSbNotifyChange", "setChangedValue"], ariaLevel: ["clrStackViewLevel", "ariaLevel"], ariaSetsize: ["clrStackViewSetsize", "ariaSetsize"], ariaPosinset: ["clrStackViewPosinset", "ariaPosinset"] }, outputs: { expandedChange: "clrSbExpandedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([UNIQUE_ID_PROVIDER])], ngContentSelectors: _c63, decls: 10, vars: 14, consts: [[1, "stack-block-label", 3, "id", "click", "keyup.enter", "keyup.space", "focus", "blur"], ["shape", "caret", "class", "stack-block-caret", 4, "ngIf"], ["class", "clr-sr-only", 4, "ngIf"], [1, "stack-view-key"], [1, "stack-block-content"], [1, "stack-children", 3, "clrExpandTrigger"], ["role", "region"], ["shape", "caret", 1, "stack-block-caret"], [1, "clr-sr-only"]], template: function ClrStackBlock_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c62);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function ClrStackBlock_Template_div_click_0_listener() { return ctx.toggleExpand(); })("keyup.enter", function ClrStackBlock_Template_div_keyup_enter_0_listener() { return ctx.toggleExpand(); })("keyup.space", function ClrStackBlock_Template_div_keyup_space_0_listener() { return ctx.toggleExpand(); })("focus", function ClrStackBlock_Template_div_focus_0_listener() { return ctx.focused = true; })("blur", function ClrStackBlock_Template_div_blur_0_listener() { return ctx.focused = false; });
        ɵngcc0.ɵɵtemplate(1, ClrStackBlock_clr_icon_1_Template, 1, 1, "clr-icon", 1);
        ɵngcc0.ɵɵtemplate(2, ClrStackBlock_span_2_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "clr-expandable-animation", 5);
        ɵngcc0.ɵɵelementStart(8, "div", 6);
        ɵngcc0.ɵɵprojection(9, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.uniqueId);
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabIndex)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.getStackChildrenId())("aria-posinset", ctx.ariaPosinset)("aria-level", ctx.ariaLevel)("aria-setsize", ctx.ariaSetsize);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expandable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.getChangedValue);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("clrExpandTrigger", ctx.expanded);
        ɵngcc0.ɵɵattribute("id", ctx.getStackChildrenId());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.expanded ? "auto" : 0);
    } }, directives: [ɵngcc1.NgIf, ClrExpandableAnimation,
        ClrIconCustomTag], styles: ["[_nghost-%COMP%] {\n        display: block;\n      }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackBlock, [{
        type: core.Component,
        args: [{
                selector: 'clr-stack-block',
                template: "\n    <div class=\"stack-block-label\"\n        (click)=\"toggleExpand()\"\n        (keyup.enter)=\"toggleExpand()\"\n        (keyup.space)=\"toggleExpand()\"\n        (focus)=\"focused = true\"\n        (blur)=\"focused = false\"\n        [id]=\"uniqueId\"\n        [attr.role]=\"role\"\n        [attr.tabindex]=\"tabIndex\"\n        [attr.aria-expanded]=\"ariaExpanded\"\n        [attr.aria-controls]=\"getStackChildrenId()\"\n        [attr.aria-posinset]=\"ariaPosinset\"\n        [attr.aria-level]=\"ariaLevel\"\n        [attr.aria-setsize]=\"ariaSetsize\"\n        >\n      <clr-icon shape=\"caret\"\n                class=\"stack-block-caret\"\n                *ngIf=\"expandable\"\n                [attr.dir]=\"caretDirection\"></clr-icon>\n      <span class=\"clr-sr-only\" *ngIf=\"getChangedValue\">{{commonStrings.keys.stackViewChanged}}</span>\n      <div class=\"stack-view-key\">\n        <!-- This structure changed to fix #3567 and the a11y request was to move away from dl's -->\n        <!-- I added the key class to update css targets for the original component style -->\n        <ng-content select=\"clr-stack-label\"></ng-content>\n      </div>\n      <div class=\"stack-block-content\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n\n    <clr-expandable-animation [clrExpandTrigger]=\"expanded\" class=\"stack-children\" [attr.id]=\"getStackChildrenId()\">\n      <div [style.height]=\"expanded ? 'auto' : 0\" role=\"region\">\n        <ng-content select=\"clr-stack-block\"></ng-content>\n      </div>\n    </clr-expandable-animation>\n  ",
                // Make sure the host has the proper class for styling purposes
                host: { '[class.stack-block]': 'true' },
                providers: [UNIQUE_ID_PROVIDER],
                styles: ["\n      :host {\n        display: block;\n      }\n    "]
            }]
    }], function () { return [{ type: ClrStackBlock, decorators: [{
                type: core.SkipSelf
            }, {
                type: core.Optional
            }] }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: ClrCommonStringsService }]; }, { expanded: [{
            type: core.HostBinding,
            args: ['class.stack-block-expanded']
        }, {
            type: core.Input,
            args: ['clrSbExpanded']
        }], expandedChange: [{
            type: core.Output,
            args: ['clrSbExpandedChange']
        }], expandable: [{
            type: core.HostBinding,
            args: ['class.stack-block-expandable']
        }, {
            type: core.Input,
            args: ['clrSbExpandable']
        }], getChangedValue: [{
            type: core.HostBinding,
            args: ['class.stack-block-changed']
        }], setChangedValue: [{
            type: core.Input,
            args: ['clrSbNotifyChange']
        }], onStackLabelFocus: [{
            type: core.HostBinding,
            args: ['class.on-focus']
        }], ariaLevel: [{
            type: core.Input,
            args: ['clrStackViewLevel']
        }], ariaSetsize: [{
            type: core.Input,
            args: ['clrStackViewSetsize']
        }], ariaPosinset: [{
            type: core.Input,
            args: ['clrStackViewPosinset']
        }] }); })();
        return ClrStackBlock;
    }());

    var ClrStackView = /** @class */ (function () {
        function ClrStackView() {
            /**
             * Undocumented experimental feature: inline editing.
             */
            this.editable = false;
            this.save = new core.EventEmitter(false);
            this._editMode = false;
            this.editingChange = new core.EventEmitter(false);
            /**
             * End of undocumented experimental feature.
             */
        }
        Object.defineProperty(ClrStackView.prototype, "editing", {
            get: function () {
                return this.editable && this._editMode;
            },
            set: function (value) {
                if (this.editable) {
                    this._editMode = value;
                    this.editingChange.emit(value);
                    if (!value) {
                        this.save.emit(null);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Output('clrStackSave')
        ], ClrStackView.prototype, "save", void 0);
ClrStackView.ɵfac = function ClrStackView_Factory(t) { return new (t || ClrStackView)(); };
ClrStackView.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStackView, selectors: [["clr-stack-view"]], outputs: { save: "clrStackSave" }, ngContentSelectors: _c65, decls: 3, vars: 0, consts: [[1, "stack-view"]], template: function ClrStackView_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c64);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackView, [{
        type: core.Component,
        args: [{
                selector: 'clr-stack-view',
                template: "\n        <ng-content select=\"clr-stack-header\"></ng-content>\n        <div class=\"stack-view\"><ng-content></ng-content></div>\n    ",
                styles: ["\n        :host { display: block; }\n    "]
            }]
    }], function () { return []; }, { save: [{
            type: core.Output,
            args: ['clrStackSave']
        }] }); })();
        return ClrStackView;
    }());

    var ClrStackHeader = /** @class */ (function () {
        function ClrStackHeader(stackView) {
            this.stackView = stackView;
        }
        ClrStackHeader.ctorParameters = function () { return [
            { type: ClrStackView }
        ]; };
ClrStackHeader.ɵfac = function ClrStackHeader_Factory(t) { return new (t || ClrStackHeader)(ɵngcc0.ɵɵdirectiveInject(ClrStackView)); };
ClrStackHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStackHeader, selectors: [["clr-stack-header"]], ngContentSelectors: _c67, decls: 6, vars: 1, consts: [[1, "stack-header"], [1, "stack-title"], [1, "stack-actions"], ["class", "stack-action btn btn-sm btn-link", "type", "button", 3, "click", 4, "ngIf"], ["type", "button", 1, "stack-action", "btn", "btn-sm", "btn-link", 3, "click"]], template: function ClrStackHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c66);
        ɵngcc0.ɵɵelementStart(0, "h4", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrStackHeader_button_5_Template, 2, 0, "button", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.stackView.editable);
    } }, directives: [ɵngcc1.NgIf], styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackHeader, [{
        type: core.Component,
        args: [{
                selector: 'clr-stack-header',
                template: "\n        <h4 class=\"stack-header\">\n            <span class=\"stack-title\"><ng-content></ng-content></span>\n            \n            <span class=\"stack-actions\">\n                <ng-content select=\".stack-action\"></ng-content>\n                <!-- Undocumented experimental feature: inline editing. -->\n                <button *ngIf=\"stackView.editable\" class=\"stack-action btn btn-sm btn-link\" \n                        (click)=\"stackView.editing = !stackView.editing\" type=\"button\">\n                        Edit\n                </button>\n                <!-- End of undocumented experimental feature. -->\n            </span>\n        </h4>\n    ",
                styles: ["\n        :host { display: block; }\n    "]
            }]
    }], function () { return [{ type: ClrStackView }]; }, null); })();
        return ClrStackHeader;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var StackControl = /** @class */ (function () {
        function StackControl(stackView) {
            var _this = this;
            this.stackView = stackView;
            this.modelChange = new core.EventEmitter(false);
            // Make the ClrStackView editable, since it contains a StackControl
            this.stackView.editable = true;
            this.stackView.editingChange.subscribe(function (editing) {
                // Edit mode was closed
                if (!editing) {
                    _this.modelChange.emit(_this.model);
                }
            });
        }
        return StackControl;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrStackInput = /** @class */ (function (_super) {
        __extends(ClrStackInput, _super);
        function ClrStackInput(stackView) {
            var _this = _super.call(this, stackView) || this;
            _this.stackView = stackView;
            _this.type = 'text';
            return _this;
        }
        ClrStackInput.ctorParameters = function () { return [
            { type: ClrStackView }
        ]; };
ClrStackInput.ɵfac = function ClrStackInput_Factory(t) { return new (t || ClrStackInput)(ɵngcc0.ɵɵdirectiveInject(ClrStackView)); };
ClrStackInput.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStackInput, selectors: [["clr-stack-input"]], inputs: { model: ["clrModel", "model"], type: "type" }, outputs: { modelChange: "clrModelChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "type", "ngModel", "ngModelChange", 4, "ngIf"], [3, "type", "ngModel", "ngModelChange"]], template: function ClrStackInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ClrStackInput_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ClrStackInput_input_1_Template, 1, 2, "input", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.stackView.editing);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.stackView.editing);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackInput, [{
        type: core.Component,
        args: [{
                selector: 'clr-stack-input',
                inputs: ['model: clrModel', 'type'],
                outputs: ['modelChange: clrModelChange'],
                template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <input [type]=\"type\" *ngIf=\"stackView.editing\" [(ngModel)]=\"model\"/>\n    "
            }]
    }], function () { return [{ type: ClrStackView }]; }, null); })();
        return ClrStackInput;
    }(StackControl));

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrStackSelect = /** @class */ (function (_super) {
        __extends(ClrStackSelect, _super);
        function ClrStackSelect(stackView) {
            var _this = _super.call(this, stackView) || this;
            _this.stackView = stackView;
            return _this;
        }
        ClrStackSelect.ctorParameters = function () { return [
            { type: ClrStackView }
        ]; };
ClrStackSelect.ɵfac = function ClrStackSelect_Factory(t) { return new (t || ClrStackSelect)(ɵngcc0.ɵɵdirectiveInject(ClrStackView)); };
ClrStackSelect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStackSelect, selectors: [["clr-stack-select"]], inputs: { model: ["clrModel", "model"] }, outputs: { modelChange: "clrModelChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "select", 4, "ngIf"], [1, "select"], [3, "ngModel", "ngModelChange"]], template: function ClrStackSelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrStackSelect_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ClrStackSelect_div_1_Template, 3, 1, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.stackView.editing);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.stackView.editing);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.SelectControlValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackSelect, [{
        type: core.Component,
        args: [{
                selector: 'clr-stack-select',
                inputs: ['model: clrModel'],
                outputs: ['modelChange: clrModelChange'],
                template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <div class=\"select\" *ngIf=\"stackView.editing\" >\n            <select [(ngModel)]=\"model\">\n                <ng-content></ng-content>\n            </select>\n        </div>\n    "
            }]
    }], function () { return [{ type: ClrStackView }]; }, null); })();
        return ClrStackSelect;
    }(StackControl));

    var ClrStackViewCustomTags = /** @class */ (function () {
        function ClrStackViewCustomTags() {
        }
ClrStackViewCustomTags.ɵfac = function ClrStackViewCustomTags_Factory(t) { return new (t || ClrStackViewCustomTags)(); };
ClrStackViewCustomTags.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrStackViewCustomTags, selectors: [["clr-stack-label"], ["clr-stack-content"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackViewCustomTags, [{
        type: core.Directive,
        args: [{ selector: 'clr-stack-label, clr-stack-content' }]
    }], function () { return []; }, null); })();
        return ClrStackViewCustomTags;
    }());

    var ClrStackContentInput = /** @class */ (function () {
        function ClrStackContentInput(uniqueId) {
            this.uniqueId = uniqueId;
        }
        ClrStackContentInput.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        ClrStackContentInput = __decorate([ __param(0, core.Inject(UNIQUE_ID))
        ], ClrStackContentInput);
ClrStackContentInput.ɵfac = function ClrStackContentInput_Factory(t) { return new (t || ClrStackContentInput)(ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrStackContentInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrStackContentInput, selectors: [["", "clrStackInput", ""]], hostVars: 3, hostBindings: function ClrStackContentInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.uniqueId);
        ɵngcc0.ɵɵclassProp("clr-input", true);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackContentInput, [{
        type: core.Directive,
        args: [{
                selector: '[clrStackInput]',
                host: {
                    '[class.clr-input]': 'true',
                    '[attr.aria-labelledby]': 'uniqueId'
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, null); })();
        return ClrStackContentInput;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_STACK_VIEW_DIRECTIVES = [
        ClrStackView,
        ClrStackHeader,
        ClrStackBlock,
        ClrStackContentInput,
        ClrStackViewCustomTags,
        /**
         * Undocumented experimental feature: inline editing.
         */
        ClrStackInput,
        ClrStackSelect,
    ];
    var ClrStackViewModule = /** @class */ (function () {
        function ClrStackViewModule() {
        }
ClrStackViewModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrStackViewModule });
ClrStackViewModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrStackViewModule_Factory(t) { return new (t || ClrStackViewModule)(); }, imports: [[common.CommonModule, forms.FormsModule, ClrIconModule, ClrExpandableAnimationModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrStackViewModule, { declarations: [ClrStackView,
        ClrStackHeader,
        ClrStackBlock,
        ClrStackContentInput,
        ClrStackViewCustomTags,
        ClrStackInput,
        ClrStackSelect], imports: [ɵngcc1.CommonModule, ɵngcc2.FormsModule, ClrIconModule,
        ClrExpandableAnimationModule], exports: [ClrStackView,
        ClrStackHeader,
        ClrStackBlock,
        ClrStackContentInput,
        ClrStackViewCustomTags,
        ClrStackInput,
        ClrStackSelect] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStackViewModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrExpandableAnimationModule],
                declarations: [CLR_STACK_VIEW_DIRECTIVES],
                exports: [CLR_STACK_VIEW_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrStackViewModule;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var KeyCodes;
    (function (KeyCodes) {
        KeyCodes["ArrowLeft"] = "ArrowLeft";
        KeyCodes["ArrowUp"] = "ArrowUp";
        KeyCodes["ArrowRight"] = "ArrowRight";
        KeyCodes["ArrowDown"] = "ArrowDown";
        KeyCodes["Backspace"] = "Backspace";
        KeyCodes["Tab"] = "TAB";
        KeyCodes["Enter"] = "Enter";
        KeyCodes["Escape"] = "Escape";
        KeyCodes["Space"] = "Space";
        KeyCodes["Home"] = "Home";
        KeyCodes["End"] = "End";
    })(KeyCodes || (KeyCodes = {}));
    var IEKeyCodes;
    (function (IEKeyCodes) {
        IEKeyCodes["ArrowUp"] = "Up";
        IEKeyCodes["ArrowDown"] = "Down";
        IEKeyCodes["ArrowRight"] = "Right";
        IEKeyCodes["ArrowLeft"] = "Left";
        IEKeyCodes["Space"] = "Spacebar";
        IEKeyCodes["Escape"] = "Esc";
        IEKeyCodes["Home"] = "Home";
        IEKeyCodes["End"] = "End";
        IEKeyCodes["Enter"] = "Enter";
        IEKeyCodes["Tab"] = "Tab";
    })(IEKeyCodes || (IEKeyCodes = {}));

    /*
    * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
    * This software is released under MIT license.
    * The full license information can be found in LICENSE in the root directory of this project.
    */
    function keyValidator(key) {
        if (key === KeyCodes.ArrowUp || key === IEKeyCodes.ArrowUp) {
            return KeyCodes.ArrowUp;
        }
        else if (key === KeyCodes.ArrowDown || key === IEKeyCodes.ArrowDown) {
            return KeyCodes.ArrowDown;
        }
        else if (key === KeyCodes.ArrowRight || key === IEKeyCodes.ArrowRight) {
            return KeyCodes.ArrowRight;
        }
        else if (key === KeyCodes.ArrowLeft || key === IEKeyCodes.ArrowLeft) {
            return KeyCodes.ArrowLeft;
        }
        else if (key === KeyCodes.Space || key === IEKeyCodes.Space) {
            return KeyCodes.Space;
        }
        else if (key === KeyCodes.Escape || key === IEKeyCodes.Escape) {
            return KeyCodes.Escape;
        }
        else {
            return key;
        }
    }
    function preventArrowKeyScroll(event) {
        var validKey = keyValidator(event.key);
        if (validKey === KeyCodes.ArrowUp ||
            validKey === KeyCodes.ArrowDown ||
            validKey === KeyCodes.ArrowLeft ||
            validKey === KeyCodes.ArrowRight) {
            // prevent element container scroll
            // MDN references this is really the only way to prevent native browser interactions
            // https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets
            event.preventDefault();
        }
    }
    function getKeyCodes(event) {
        // IE does not properly follow the spec for `event.key` so we need to return a different enum for the key events
        // We use `event.key` for optimal browser support, to detect IE/Edge check if `event.code` is undefined
        var isIEKeyboardEvent = event.code === undefined;
        return isIEKeyboardEvent ? IEKeyCodes : KeyCodes;
    }

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // TODO: I'd like this to be a CheckedState enum for the checkboxes in the future.

    (function (ClrSelectedState) {
        // WARNING! Unselected has the value 0,
        // so it's actually the only one that will evaluate to false if cast to a boolean.
        // Don't mess with the order!
        ClrSelectedState[ClrSelectedState["UNSELECTED"] = 0] = "UNSELECTED";
        ClrSelectedState[ClrSelectedState["SELECTED"] = 1] = "SELECTED";
        ClrSelectedState[ClrSelectedState["INDETERMINATE"] = 2] = "INDETERMINATE";
    })(exports.ClrSelectedState || (exports.ClrSelectedState = {}));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var TreeNodeModel = /** @class */ (function () {
        function TreeNodeModel() {
            this.selected = new rxjs.BehaviorSubject(exports.ClrSelectedState.UNSELECTED);
            /*
             * Being able to push this down to the RecursiveTreeNodeModel would require too much work on the angular components
             * right now for them to know which kind of model they are using. So I'm lifting the public properties to this
             * abstract parent class for now and we can revisit it later, when we're not facing such a close deadline.
             */
            this.loading = false;
        }
        TreeNodeModel.prototype.destroy = function () {
            // Just to be safe
            this.selected.complete();
        };
        // Propagate by default when eager, don't propagate in the lazy-loaded tree.
        TreeNodeModel.prototype.setSelected = function (state, propagateUp, propagateDown) {
            if (state === this.selected.value) {
                return;
            }
            this.selected.next(state);
            if (propagateDown && state !== exports.ClrSelectedState.INDETERMINATE && this.children) {
                this.children.forEach(function (child) { return child.setSelected(state, false, true); });
            }
            if (propagateUp && this.parent) {
                this.parent._updateSelectionFromChildren();
            }
        };
        TreeNodeModel.prototype.toggleSelection = function (propagate) {
            // Both unselected and indeterminate toggle to selected
            var newState = this.selected.value === exports.ClrSelectedState.SELECTED ? exports.ClrSelectedState.UNSELECTED : exports.ClrSelectedState.SELECTED;
            // NOTE: we always propagate selection up in this method because it is only called when the user takes an action.
            // It should never be called from lifecycle hooks or app-provided inputs.
            this.setSelected(newState, true, propagate);
        };
        TreeNodeModel.prototype.computeSelectionStateFromChildren = function () {
            var e_1, _a;
            var oneSelected = false;
            var oneUnselected = false;
            try {
                // Using a good old for loop to exit as soon as we can tell, for better performance on large trees.
                for (var _b = __values(this.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    switch (child.selected.value) {
                        case exports.ClrSelectedState.INDETERMINATE:
                            return exports.ClrSelectedState.INDETERMINATE;
                        case exports.ClrSelectedState.SELECTED:
                            oneSelected = true;
                            if (oneUnselected) {
                                return exports.ClrSelectedState.INDETERMINATE;
                            }
                            break;
                        case exports.ClrSelectedState.UNSELECTED:
                        default:
                            // Default is the same as unselected, in case an undefined somehow made it all the way here.
                            oneUnselected = true;
                            if (oneSelected) {
                                return exports.ClrSelectedState.INDETERMINATE;
                            }
                            break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!oneSelected) {
                return exports.ClrSelectedState.UNSELECTED;
            }
            else if (!oneUnselected) {
                return exports.ClrSelectedState.SELECTED;
            }
        };
        /*
         * Internal, but needs to be called by other nodes
         */
        TreeNodeModel.prototype._updateSelectionFromChildren = function () {
            var newState = this.computeSelectionStateFromChildren();
            if (newState === this.selected.value) {
                return;
            }
            this.selected.next(newState);
            if (this.parent) {
                this.parent._updateSelectionFromChildren();
            }
        };
        return TreeNodeModel;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /*
     * A declarative model is built by traversing the Angular component tree.
     * Declarative = Tree node components dictate the model
     */
    var DeclarativeTreeNodeModel = /** @class */ (function (_super) {
        __extends(DeclarativeTreeNodeModel, _super);
        function DeclarativeTreeNodeModel(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            if (parent) {
                parent._addChild(_this);
            }
            _this.children = [];
            return _this;
        }
        DeclarativeTreeNodeModel.prototype._addChild = function (child) {
            this.children.push(child);
        };
        DeclarativeTreeNodeModel.prototype._removeChild = function (child) {
            var index = this.children.indexOf(child);
            if (index > -1) {
                this.children.splice(index, 1);
            }
        };
        DeclarativeTreeNodeModel.prototype.destroy = function () {
            if (this.parent) {
                this.parent._removeChild(this);
            }
            _super.prototype.destroy.call(this);
        };
        return DeclarativeTreeNodeModel;
    }(TreeNodeModel));

    var TreeFeaturesService = /** @class */ (function () {
        function TreeFeaturesService() {
            this.selectable = false;
            this.eager = true;
            this.childrenFetched = new rxjs.Subject();
        }
TreeFeaturesService.ɵfac = function TreeFeaturesService_Factory(t) { return new (t || TreeFeaturesService)(); };
TreeFeaturesService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TreeFeaturesService, factory: function (t) { return TreeFeaturesService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeFeaturesService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return TreeFeaturesService;
    }());
    function treeFeaturesFactory(existing) {
        return existing || new TreeFeaturesService();
    }
    var TREE_FEATURES_PROVIDER = {
        provide: TreeFeaturesService,
        useFactory: treeFeaturesFactory,
        /*
         * The Optional + SkipSelf pattern ensures that in case of nested components, only the root one will
         * instantiate a new service and all its children will reuse the root's instance.
         * If there are several roots (in this case, several independent trees on a page), each root will instantiate
         * its own service so they won't interfere with one another.
         *
         * TL;DR - Optional + SkipSelf = 1 instance of TreeFeaturesService per tree.
         */
        deps: [[new core.Optional(), new core.SkipSelf(), TreeFeaturesService]],
    };

    var TreeFocusManagerService = /** @class */ (function () {
        function TreeFocusManagerService() {
            this._focusRequest = new rxjs.Subject();
            this._focusChange = new rxjs.Subject();
        }
        Object.defineProperty(TreeFocusManagerService.prototype, "focusRequest", {
            get: function () {
                return this._focusRequest.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeFocusManagerService.prototype, "focusChange", {
            get: function () {
                return this._focusChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        TreeFocusManagerService.prototype.findSiblings = function (model) {
            // the method will return not only sibling models but also itself among them
            if (model.parent) {
                return model.parent.children;
            }
            else {
                return this.rootNodeModels;
            }
        };
        TreeFocusManagerService.prototype.findLastVisibleInNode = function (model) {
            // the method will traverse through until it finds the last visible node from the given node
            if (!model) {
                return;
            }
            if (model.expanded && model.children.length > 0) {
                var children = model.children;
                var lastChild = children[children.length - 1];
                return this.findLastVisibleInNode(lastChild);
            }
            else {
                return model;
            }
        };
        TreeFocusManagerService.prototype.findNextFocusable = function (model) {
            if (!model) {
                return;
            }
            var siblings = this.findSiblings(model);
            var selfIndex = siblings.indexOf(model);
            if (selfIndex < siblings.length - 1) {
                return siblings[selfIndex + 1];
            }
            else if (selfIndex === siblings.length - 1) {
                return this.findNextFocusable(model.parent);
            }
        };
        TreeFocusManagerService.prototype.findLastVisibleInTree = function () {
            var lastRootNode = this.rootNodeModels && this.rootNodeModels.length && this.rootNodeModels[this.rootNodeModels.length - 1];
            return this.findLastVisibleInNode(lastRootNode);
        };
        TreeFocusManagerService.prototype.findNodeAbove = function (model) {
            if (!model) {
                return;
            }
            var siblings = this.findSiblings(model);
            var selfIndex = siblings.indexOf(model);
            if (selfIndex === 0) {
                return model.parent;
            }
            else if (selfIndex > 0) {
                return this.findLastVisibleInNode(siblings[selfIndex - 1]);
            }
        };
        TreeFocusManagerService.prototype.findNodeBelow = function (model) {
            if (!model) {
                return;
            }
            if (model.expanded && model.children.length > 0) {
                return model.children[0];
            }
            else {
                return this.findNextFocusable(model);
            }
        };
        TreeFocusManagerService.prototype.focusNode = function (model) {
            if (model) {
                this._focusRequest.next(model.nodeId);
            }
        };
        TreeFocusManagerService.prototype.broadcastFocusedNode = function (nodeId) {
            if (this.focusedNodeId !== nodeId) {
                this.focusedNodeId = nodeId;
                this._focusChange.next(nodeId);
            }
        };
        TreeFocusManagerService.prototype.focusParent = function (model) {
            if (model) {
                this.focusNode(model.parent);
            }
        };
        TreeFocusManagerService.prototype.focusFirstVisibleNode = function () {
            var focusModel = this.rootNodeModels && this.rootNodeModels[0];
            this.focusNode(focusModel);
        };
        TreeFocusManagerService.prototype.focusLastVisibleNode = function () {
            this.focusNode(this.findLastVisibleInTree());
        };
        TreeFocusManagerService.prototype.focusNodeAbove = function (model) {
            this.focusNode(this.findNodeAbove(model));
        };
        TreeFocusManagerService.prototype.focusNodeBelow = function (model) {
            this.focusNode(this.findNodeBelow(model));
        };
TreeFocusManagerService.ɵfac = function TreeFocusManagerService_Factory(t) { return new (t || TreeFocusManagerService)(); };
TreeFocusManagerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TreeFocusManagerService, factory: function (t) { return TreeFocusManagerService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeFocusManagerService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return TreeFocusManagerService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTreeNodeLink = /** @class */ (function () {
        function ClrTreeNodeLink(el) {
            this.el = el;
        }
        ClrTreeNodeLink.prototype.activate = function () {
            if (this.el.nativeElement && this.el.nativeElement.click) {
                this.el.nativeElement.click();
            }
        };
        ClrTreeNodeLink.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
ClrTreeNodeLink.ɵfac = function ClrTreeNodeLink_Factory(t) { return new (t || ClrTreeNodeLink)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrTreeNodeLink.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrTreeNodeLink, selectors: [["", 8, "clr-treenode-link"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTreeNodeLink, [{
        type: core.Directive,
        args: [{
                selector: '.clr-treenode-link'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();
        return ClrTreeNodeLink;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var LVIEW_CONTEXT_INDEX = 8;
    var ClrTreeNode = /** @class */ (function () {
        function ClrTreeNode(nodeId, platformId, parent, featuresService, expandService, commonStrings, focusManager, injector) {
            this.nodeId = nodeId;
            this.platformId = platformId;
            this.featuresService = featuresService;
            this.expandService = expandService;
            this.commonStrings = commonStrings;
            this.focusManager = focusManager;
            this.STATES = exports.ClrSelectedState;
            this.skipEmitChange = false;
            this.selectedChange = new core.EventEmitter(false);
            this.expandedChange = new core.EventEmitter();
            this.subscriptions = [];
            this.contentContainerTabindex = -1;
            if (this.featuresService.recursion) {
                // I'm completely stuck, we have to hack into private properties until either
                // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
                // are fixed
                // This is for non-ivy implementations
                if (injector.view) {
                    this._model = injector.view.context.clrModel;
                }
                else {
                    // Ivy puts this on a specific index of a _lView property
                    // tslint:disable-next-line
                    this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
                }
            }
            else {
                // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
                this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
            }
            this._model.nodeId = this.nodeId;
        }
        ClrTreeNode.prototype.isExpandable = function () {
            if (typeof this.expandable !== 'undefined') {
                return this.expandable;
            }
            return !!this.expandService.expandable || (this._model.children && this._model.children.length > 0);
        };
        Object.defineProperty(ClrTreeNode.prototype, "selected", {
            get: function () {
                return this._model.selected.value;
            },
            set: function (value) {
                this.featuresService.selectable = true;
                // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
                // This shouldn't happen with strict typing on the app's side, but it's not up to us.
                if (value === null || typeof value === 'undefined') {
                    value = exports.ClrSelectedState.UNSELECTED;
                }
                // We match booleans to the corresponding ClrSelectedState
                if (typeof value === 'boolean') {
                    value = value ? exports.ClrSelectedState.SELECTED : exports.ClrSelectedState.UNSELECTED;
                }
                // We propagate only if the tree is in smart mode, and skip emitting the output when we set the input
                // See https://github.com/vmware/clarity/issues/3073
                this.skipEmitChange = true;
                this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
                this.skipEmitChange = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "ariaSelected", {
            get: function () {
                return this.featuresService.selectable ? this._model.selected.value === exports.ClrSelectedState.SELECTED : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "expanded", {
            // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
            // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
            // case, you can't use a structural directive, it would need to go on an ng-container.
            get: function () {
                return this.expandService.expanded;
            },
            set: function (value) {
                this.expandService.expanded = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrTreeNode.prototype.ngOnInit = function () {
            var _this = this;
            this._model.expanded = this.expanded;
            this.subscriptions.push(this._model.selected.pipe(operators.filter(function () { return !_this.skipEmitChange; })).subscribe(function (value) {
                _this.selectedChange.emit(value);
            }));
            this.subscriptions.push(this.expandService.expandChange.subscribe(function (value) {
                _this.expandedChange.emit(value);
                _this._model.expanded = value;
            }));
            this.subscriptions.push(this.focusManager.focusRequest.subscribe(function (nodeId) {
                if (_this.nodeId === nodeId) {
                    _this.focusTreeNode();
                }
            }), this.focusManager.focusChange.subscribe(function (nodeId) {
                _this.checkTabIndex(nodeId);
            }));
        };
        ClrTreeNode.prototype.ngOnDestroy = function () {
            this._model.destroy();
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        Object.defineProperty(ClrTreeNode.prototype, "treeNodeLink", {
            get: function () {
                return this.treeNodeLinkList && this.treeNodeLinkList.first;
            },
            enumerable: true,
            configurable: true
        });
        ClrTreeNode.prototype.setTabIndex = function (value) {
            this.contentContainerTabindex = value;
            this.contentContainer.nativeElement.setAttribute('tabindex', value);
        };
        ClrTreeNode.prototype.checkTabIndex = function (nodeId) {
            if (common.isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
                this.setTabIndex(-1);
            }
        };
        ClrTreeNode.prototype.focusTreeNode = function () {
            if (common.isPlatformBrowser(this.platformId) && document.activeElement !== this.contentContainer.nativeElement) {
                this.setTabIndex(0);
                this.contentContainer.nativeElement.focus();
            }
        };
        ClrTreeNode.prototype.broadcastFocusOnContainer = function () {
            this.focusManager.broadcastFocusedNode(this.nodeId);
        };
        ClrTreeNode.prototype.onKeyDown = function (event) {
            // Two reasons to prevent default behavior:
            // 1. to prevent scrolling on arrow keys
            // 2. Assistive Technology focus differs from Keyboard focus behavior.
            //    By default, pressing arrow key makes AT focus go into the nested content of the item.
            preventArrowKeyScroll(event);
            // https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-22
            switch (keyValidator(event.key)) {
                case KeyCodes.ArrowUp:
                    this.focusManager.focusNodeAbove(this._model);
                    break;
                case KeyCodes.ArrowDown:
                    this.focusManager.focusNodeBelow(this._model);
                    break;
                case KeyCodes.ArrowRight:
                    this.expandOrFocusFirstChild();
                    break;
                case KeyCodes.ArrowLeft:
                    this.collapseOrFocusParent();
                    break;
                case KeyCodes.Home:
                    this.focusManager.focusFirstVisibleNode();
                    break;
                case KeyCodes.End:
                    this.focusManager.focusLastVisibleNode();
                    break;
                case KeyCodes.Enter:
                    this.triggerDefaultAction();
                    break;
                case KeyCodes.Space:
                    // to prevent scrolling on space key in this specific case
                    event.preventDefault();
                    this.triggerDefaultAction();
                    break;
                default:
                    break;
            }
        };
        ClrTreeNode.prototype.expandOrFocusFirstChild = function () {
            if (this.expanded) {
                // if the node is already expanded and has children, focus its very first child
                if (this._model.children.length > 0) {
                    this.focusManager.focusNodeBelow(this._model);
                }
            }
            else {
                // we must check if the node is expandable, in order to set .expanded to true from false
                // because we shouldn't set .expanded to true if it's not expandable node
                if (this.isExpandable()) {
                    this.expandService.expanded = true;
                }
            }
        };
        ClrTreeNode.prototype.collapseOrFocusParent = function () {
            if (this.expanded) {
                this.expandService.expanded = false;
            }
            else {
                this.focusManager.focusParent(this._model);
            }
        };
        ClrTreeNode.prototype.triggerDefaultAction = function () {
            if (this.treeNodeLink) {
                this.treeNodeLink.activate();
            }
            else {
                if (this.featuresService.selectable) {
                    this._model.toggleSelection(this.featuresService.eager);
                }
            }
        };
        ClrTreeNode.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: ClrTreeNode, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: TreeFeaturesService },
            { type: IfExpandService },
            { type: ClrCommonStringsService },
            { type: TreeFocusManagerService },
            { type: core.Injector }
        ]; };
        __decorate([
            core.Input('clrSelected')
        ], ClrTreeNode.prototype, "selected", null);
        __decorate([
            core.Output('clrSelectedChange')
        ], ClrTreeNode.prototype, "selectedChange", void 0);
        __decorate([
            core.Input('clrExpandable')
        ], ClrTreeNode.prototype, "expandable", void 0);
        __decorate([
            core.Input('clrExpanded')
        ], ClrTreeNode.prototype, "expanded", null);
        __decorate([
            core.Output('clrExpandedChange')
        ], ClrTreeNode.prototype, "expandedChange", void 0);
        __decorate([
            core.ViewChild('contentContainer', { read: core.ElementRef, static: true })
        ], ClrTreeNode.prototype, "contentContainer", void 0);
        __decorate([
            core.ContentChildren(ClrTreeNodeLink, { descendants: false })
        ], ClrTreeNode.prototype, "treeNodeLinkList", void 0);
        ClrTreeNode = __decorate([ __param(0, core.Inject(UNIQUE_ID)),
            __param(1, core.Inject(core.PLATFORM_ID)),
            __param(2, core.Optional()),
            __param(2, core.SkipSelf())
        ], ClrTreeNode);
ClrTreeNode.ɵfac = function ClrTreeNode_Factory(t) { return new (t || ClrTreeNode)(ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ClrTreeNode, 12), ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(IfExpandService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(TreeFocusManagerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
ClrTreeNode.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTreeNode, selectors: [["clr-tree-node"]], contentQueries: function ClrTreeNode_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTreeNodeLink, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeLinkList = _t);
    } }, viewQuery: function ClrTreeNode_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c68, true, core.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);
    } }, hostVars: 3, hostBindings: function ClrTreeNode_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "treeitem");
        ɵngcc0.ɵɵclassProp("clr-tree-node", true);
    } }, inputs: { selected: ["clrSelected", "selected"], expanded: ["clrExpanded", "expanded"], expandable: ["clrExpandable", "expandable"] }, outputs: { selectedChange: "clrSelectedChange", expandedChange: "clrExpandedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            UNIQUE_ID_PROVIDER,
            TREE_FEATURES_PROVIDER,
            IfExpandService,
            { provide: LoadingListener, useExisting: IfExpandService },
        ])], ngContentSelectors: _c70, decls: 12, vars: 9, consts: [["role", "treeitem", "tabindex", "-1", 1, "clr-tree-node-content-container", 3, "keydown", "focus"], ["contentContainer", ""], ["aria-hidden", "true", "type", "button", "tabindex", "-1", "class", "clr-treenode-caret", 3, "click", "focus", 4, "ngIf"], ["class", "clr-treenode-spinner-container", 4, "ngIf"], ["class", "clr-checkbox-wrapper clr-treenode-checkbox", 4, "ngIf"], [1, "clr-treenode-content", 3, "mousedown"], ["class", "clr-sr-only", 4, "ngIf"], [1, "clr-treenode-children"], [3, "parent"], ["aria-hidden", "true", "type", "button", "tabindex", "-1", 1, "clr-treenode-caret", 3, "click", "focus"], ["shape", "caret", 1, "clr-treenode-caret-icon"], [1, "clr-treenode-spinner-container"], [1, "clr-treenode-spinner", "spinner"], [1, "clr-checkbox-wrapper", "clr-treenode-checkbox"], ["aria-hidden", "true", "type", "checkbox", "tabindex", "-1", 1, "clr-checkbox", 3, "id", "checked", "indeterminate", "change", "focus"], [1, "clr-control-label", 3, "for"], [1, "clr-sr-only"], [4, "ngIf"]], template: function ClrTreeNode_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c69);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("keydown", function ClrTreeNode_Template_div_keydown_0_listener($event) { return ctx.onKeyDown($event); })("focus", function ClrTreeNode_Template_div_focus_0_listener() { return ctx.broadcastFocusOnContainer(); });
        ɵngcc0.ɵɵtemplate(2, ClrTreeNode_button_2_Template, 2, 1, "button", 2);
        ɵngcc0.ɵɵtemplate(3, ClrTreeNode_div_3_Template, 2, 0, "div", 3);
        ɵngcc0.ɵɵtemplate(4, ClrTreeNode_div_4_Template, 3, 4, "div", 4);
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵlistener("mousedown", function ClrTreeNode_Template_div_mousedown_5_listener() { return ctx.focusTreeNode(); });
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵtemplate(7, ClrTreeNode_div_7_Template, 3, 2, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 7);
        ɵngcc0.ɵɵprojection(9, 1);
        ɵngcc0.ɵɵprojection(10, 2);
        ɵngcc0.ɵɵelement(11, "clr-recursive-children", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.isExpandable() ? ctx.expanded : null)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isExpandable() && !ctx._model.loading && !ctx.expandService.loading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expandService.loading || ctx._model.loading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.featuresService.selectable);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.featuresService.selectable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("@toggleChildrenAnim", ctx.expandService.expanded ? "expanded" : "collapsed");
        ɵngcc0.ɵɵattribute("role", ctx.isExpandable() && !ctx.featuresService.recursion ? "group" : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("parent", ctx._model);
    } }, directives: function () { return [ɵngcc1.NgIf, RecursiveChildren,
        ClrIconCustomTag]; }, encapsulation: 2, data: { animation: [
            animations.trigger('toggleChildrenAnim', [
                animations.transition('collapsed => expanded', [animations.style({ height: 0 }), animations.animate(200, animations.style({ height: '*' }))]),
                animations.transition('expanded => collapsed', [animations.style({ height: '*' }), animations.animate(200, animations.style({ height: 0 }))]),
                animations.state('expanded', animations.style({ height: '*', 'overflow-y': 'visible' })),
                animations.state('collapsed', animations.style({ height: 0 })),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTreeNode, [{
        type: core.Component,
        args: [{
                selector: 'clr-tree-node',
                template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div #contentContainer role=\"treeitem\" \n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\" \n  (keydown)=\"onKeyDown($event)\" \n  (focus)=\"broadcastFocusOnContainer()\">\n  <button\n    *ngIf=\"isExpandable() && !_model.loading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\" (focus)=\"focusTreeNode()\">\n    <clr-icon\n      class=\"clr-treenode-caret-icon\" shape=\"caret\"\n      [attr.dir]=\"expandService.expanded ? 'down' : 'right'\"></clr-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || _model.loading\">\n        <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input aria-hidden=\"true\" type=\"checkbox\" id=\"{{nodeId}}-check\" class=\"clr-checkbox\" \n           [checked]=\"_model.selected.value === STATES.SELECTED\"\n           [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n           (change)=\"_model.toggleSelection(featuresService.eager)\" \n           (focus)=\"focusTreeNode()\"\n           tabindex=\"-1\">\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\">\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable\">\n        <span *ngIf=\"ariaSelected\">\n          selected \n        </span>\n        <span *ngIf=\"!ariaSelected\">\n          unselected \n        </span>\n    </div>\n  </div>\n</div>\n<div class=\"clr-treenode-children\" \n    [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\" \n    [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\">\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n",
                providers: [
                    UNIQUE_ID_PROVIDER,
                    TREE_FEATURES_PROVIDER,
                    IfExpandService,
                    { provide: LoadingListener, useExisting: IfExpandService },
                ],
                animations: [
                    animations.trigger('toggleChildrenAnim', [
                        animations.transition('collapsed => expanded', [animations.style({ height: 0 }), animations.animate(200, animations.style({ height: '*' }))]),
                        animations.transition('expanded => collapsed', [animations.style({ height: '*' }), animations.animate(200, animations.style({ height: 0 }))]),
                        animations.state('expanded', animations.style({ height: '*', 'overflow-y': 'visible' })),
                        animations.state('collapsed', animations.style({ height: 0 })),
                    ]),
                ],
                host: {
                    '[attr.role]': '"treeitem"',
                    '[class.clr-tree-node]': 'true'
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: ClrTreeNode, decorators: [{
                type: core.Optional
            }, {
                type: core.SkipSelf
            }] }, { type: TreeFeaturesService }, { type: IfExpandService }, { type: ClrCommonStringsService }, { type: TreeFocusManagerService }, { type: ɵngcc0.Injector }]; }, { selectedChange: [{
            type: core.Output,
            args: ['clrSelectedChange']
        }], expandedChange: [{
            type: core.Output,
            args: ['clrExpandedChange']
        }], selected: [{
            type: core.Input,
            args: ['clrSelected']
        }], expanded: [{
            type: core.Input,
            args: ['clrExpanded']
        }], expandable: [{
            type: core.Input,
            args: ['clrExpandable']
        }], contentContainer: [{
            type: core.ViewChild,
            args: ['contentContainer', { read: core.ElementRef, static: true }]
        }], treeNodeLinkList: [{
            type: core.ContentChildren,
            args: [ClrTreeNodeLink, { descendants: false }]
        }] }); })();
        return ClrTreeNode;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTree = /** @class */ (function () {
        function ClrTree(featuresService, focusManagerService, el) {
            this.featuresService = featuresService;
            this.focusManagerService = focusManagerService;
            this.el = el;
            this.subscriptions = [];
            this.tabindex = 0;
        }
        Object.defineProperty(ClrTree.prototype, "lazy", {
            set: function (value) {
                this.featuresService.eager = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTree.prototype, "isMultiSelectable", {
            get: function () {
                return this.featuresService.selectable && this.rootNodes.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        ClrTree.prototype.onFocusIn = function (event) {
            if (event.target === this.el.nativeElement) {
                // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
                // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
                this.focusManagerService.focusFirstVisibleNode();
                // when the first child gets focus,
                // tree should no longer have tabindex of 0;
                delete this.tabindex;
            }
        };
        ClrTree.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.setRootNodes();
            this.subscriptions.push(this.rootNodes.changes.subscribe(function () {
                _this.setRootNodes();
            }));
        };
        ClrTree.prototype.setRootNodes = function () {
            // if node has no parent, it's a root node
            // for recursive tree, this.rootNodes registers also nested children
            // so we have to use filter to extract the ones that are truly root nodes
            this.focusManagerService.rootNodeModels = this.rootNodes.map(function (node) { return node._model; }).filter(function (node) { return !node.parent; });
        };
        ClrTree.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrTree.ctorParameters = function () { return [
            { type: TreeFeaturesService },
            { type: TreeFocusManagerService },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('clrLazy')
        ], ClrTree.prototype, "lazy", null);
        __decorate([
            core.HostListener('focusin', ['$event'])
        ], ClrTree.prototype, "onFocusIn", null);
        __decorate([
            core.ContentChildren(ClrTreeNode)
        ], ClrTree.prototype, "rootNodes", void 0);
ClrTree.ɵfac = function ClrTree_Factory(t) { return new (t || ClrTree)(ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(TreeFocusManagerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrTree.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTree, selectors: [["clr-tree"]], contentQueries: function ClrTree_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTreeNode, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rootNodes = _t);
    } }, hostVars: 3, hostBindings: function ClrTree_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function ClrTree_focusin_HostBindingHandler($event) { return ctx.onFocusIn($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("role", "tree")("aria-multiselectable", ctx.isMultiSelectable);
    } }, inputs: { lazy: ["clrLazy", "lazy"] }, features: [ɵngcc0.ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, TreeFocusManagerService])], ngContentSelectors: _c1, decls: 2, vars: 1, consts: [[3, "children", 4, "ngIf"], [3, "children"]], template: function ClrTree_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrTree_clr_recursive_children_1_Template, 1, 1, "clr-recursive-children", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.featuresService.recursion);
    } }, directives: function () { return [ɵngcc1.NgIf, RecursiveChildren]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTree, [{
        type: core.Component,
        args: [{
                selector: 'clr-tree',
                template: "\n    <ng-content></ng-content>\n    <clr-recursive-children *ngIf=\"featuresService.recursion\"\n                            [children]=\"featuresService.recursion.root\"></clr-recursive-children>\n  ",
                providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
                host: {
                    '[attr.tabindex]': 'tabindex',
                    '[attr.role]': '"tree"',
                    '[attr.aria-multiselectable]': 'isMultiSelectable'
                }
            }]
    }], function () { return [{ type: TreeFeaturesService }, { type: TreeFocusManagerService }, { type: ɵngcc0.ElementRef }]; }, { lazy: [{
            type: core.Input,
            args: ['clrLazy']
        }], onFocusIn: [{
            type: core.HostListener,
            args: ['focusin', ['$event']]
        }], rootNodes: [{
            type: core.ContentChildren,
            args: [ClrTreeNode]
        }] }); })();
        return ClrTree;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function isPromise(o) {
        // Shamelessly copied from every open-source project out there.
        return o && typeof o.then === 'function';
    }

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /*
     * A recursive model is built received from the app and traversed to create the corresponding components.
     * Recursive = Model dictates the tree node components
     */
    var RecursiveTreeNodeModel = /** @class */ (function (_super) {
        __extends(RecursiveTreeNodeModel, _super);
        function RecursiveTreeNodeModel(model, parent, getChildren, featuresService) {
            var _this = _super.call(this) || this;
            _this.getChildren = getChildren;
            _this.featuresService = featuresService;
            _this.childrenFetched = false;
            _this._children = [];
            _this.model = model;
            _this.parent = parent;
            return _this;
        }
        RecursiveTreeNodeModel.prototype.clearChildren = function () {
            this._children.forEach(function (child) { return child.destroy(); });
            delete this._children;
            this.childrenFetched = false;
        };
        RecursiveTreeNodeModel.prototype.fetchChildren = function () {
            var _this = this;
            if (this.childrenFetched) {
                return;
            }
            var asyncChildren = this.getChildren(this.model);
            if (isPromise(asyncChildren)) {
                this.loading = true;
                asyncChildren.then(function (raw) {
                    _this._children = _this.wrapChildren(raw);
                    _this.loading = false;
                });
            }
            else if (rxjs.isObservable(asyncChildren)) {
                this.loading = true;
                this.subscription = asyncChildren.subscribe(function (raw) {
                    _this._children = _this.wrapChildren(raw);
                    _this.loading = false;
                });
            }
            else if (asyncChildren) {
                // Synchronous case
                this._children = this.wrapChildren(asyncChildren);
            }
            else {
                this._children = [];
            }
            this.childrenFetched = true;
            if (this.featuresService) {
                this.featuresService.childrenFetched.next();
            }
        };
        RecursiveTreeNodeModel.prototype.wrapChildren = function (rawModels) {
            var _this = this;
            return rawModels.map(function (m) { return new RecursiveTreeNodeModel(m, _this, _this.getChildren, _this.featuresService); });
        };
        Object.defineProperty(RecursiveTreeNodeModel.prototype, "children", {
            get: function () {
                this.fetchChildren();
                return this._children;
            },
            set: function (value) {
                this._children = value;
            },
            enumerable: true,
            configurable: true
        });
        RecursiveTreeNodeModel.prototype.destroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
            _super.prototype.destroy.call(this);
        };
        return RecursiveTreeNodeModel;
    }(TreeNodeModel));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrRecursiveForOf = /** @class */ (function () {
        function ClrRecursiveForOf(template, featuresService, cdr) {
            this.template = template;
            this.featuresService = featuresService;
            this.cdr = cdr;
        }
        // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
        ClrRecursiveForOf.prototype.ngOnChanges = function () {
            var _this = this;
            var wrapped;
            if (Array.isArray(this.nodes)) {
                wrapped = this.nodes.map(function (node) { return new RecursiveTreeNodeModel(node, null, _this.getChildren, _this.featuresService); });
            }
            else {
                wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren, this.featuresService)];
            }
            if (!this.childrenFetchSubscription) {
                this.childrenFetchSubscription = this.featuresService.childrenFetched.pipe(operators.debounceTime(0)).subscribe(function () {
                    _this.cdr.detectChanges();
                });
            }
            this.featuresService.recursion = {
                template: this.template,
                root: wrapped,
            };
        };
        ClrRecursiveForOf.prototype.ngOnDestroy = function () {
            if (this.childrenFetchSubscription) {
                this.childrenFetchSubscription.unsubscribe();
            }
        };
        ClrRecursiveForOf.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: TreeFeaturesService },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input('clrRecursiveForOf')
        ], ClrRecursiveForOf.prototype, "nodes", void 0);
        __decorate([
            core.Input('clrRecursiveForGetChildren')
        ], ClrRecursiveForOf.prototype, "getChildren", void 0);
ClrRecursiveForOf.ɵfac = function ClrRecursiveForOf_Factory(t) { return new (t || ClrRecursiveForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ClrRecursiveForOf.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrRecursiveForOf, selectors: [["", "clrRecursiveFor", "", "clrRecursiveForOf", ""]], inputs: { nodes: ["clrRecursiveForOf", "nodes"], getChildren: ["clrRecursiveForGetChildren", "getChildren"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRecursiveForOf, [{
        type: core.Directive,
        args: [{ selector: '[clrRecursiveFor][clrRecursiveForOf]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: TreeFeaturesService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { nodes: [{
            type: core.Input,
            args: ['clrRecursiveForOf']
        }], getChildren: [{
            type: core.Input,
            args: ['clrRecursiveForGetChildren']
        }] }); })();
        return ClrRecursiveForOf;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var RecursiveChildren = /** @class */ (function () {
        function RecursiveChildren(featuresService, expandService) {
            var _this = this;
            this.featuresService = featuresService;
            this.expandService = expandService;
            if (expandService) {
                this.subscription = this.expandService.expandChange.subscribe(function (value) {
                    if (!value && _this.parent && !_this.featuresService.eager && _this.featuresService.recursion) {
                        // In the case of lazy-loading recursive trees, we clear the children on collapse.
                        // This is better in case they change between two user interaction, and that way
                        // the app itself can decide whether to cache them or not.
                        _this.parent.clearChildren();
                    }
                });
            }
        }
        RecursiveChildren.prototype.shouldRender = function () {
            return (this.featuresService.recursion &&
                // In the smart case, we eagerly render all the recursive children
                // to make sure two-way bindings for selection are available.
                // They will be hidden with CSS by the parent.
                (this.featuresService.eager || !this.expandService || this.expandService.expanded));
        };
        RecursiveChildren.prototype.getContext = function (node) {
            return {
                $implicit: node.model,
                clrModel: node,
            };
        };
        RecursiveChildren.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        RecursiveChildren.ctorParameters = function () { return [
            { type: TreeFeaturesService },
            { type: IfExpandService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input('parent')
        ], RecursiveChildren.prototype, "parent", void 0);
        __decorate([
            core.Input('children')
        ], RecursiveChildren.prototype, "children", void 0);
        RecursiveChildren = __decorate([ __param(1, core.Optional())
        ], RecursiveChildren);
RecursiveChildren.ɵfac = function RecursiveChildren_Factory(t) { return new (t || RecursiveChildren)(ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(IfExpandService, 8)); };
RecursiveChildren.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RecursiveChildren, selectors: [["clr-recursive-children"]], hostVars: 1, hostBindings: function RecursiveChildren_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "group");
    } }, inputs: { parent: "parent", children: "children" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function RecursiveChildren_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, RecursiveChildren_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldRender());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RecursiveChildren, [{
        type: core.Component,
        args: [{
                selector: 'clr-recursive-children',
                template: "\n    <ng-container *ngIf=\"shouldRender()\">\n      <ng-container *ngFor=\"let child of parent?.children || children\">\n        <ng-container *ngTemplateOutlet=\"featuresService.recursion.template; context: getContext(child)\"></ng-container>\n      </ng-container>\n    </ng-container>\n  ",
                host: {
                    '[attr.role]': '"group"'
                }
            }]
    }], function () { return [{ type: TreeFeaturesService }, { type: IfExpandService, decorators: [{
                type: core.Optional
            }] }]; }, { parent: [{
            type: core.Input,
            args: ['parent']
        }], children: [{
            type: core.Input,
            args: ['children']
        }] }); })();
        return RecursiveChildren;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_TREE_VIEW_DIRECTIVES = [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink];
    var ClrTreeViewModule = /** @class */ (function () {
        function ClrTreeViewModule() {
        }
ClrTreeViewModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrTreeViewModule });
ClrTreeViewModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrTreeViewModule_Factory(t) { return new (t || ClrTreeViewModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrLoadingModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrTreeViewModule, { declarations: [ClrTree,
        ClrTreeNode,
        ClrRecursiveForOf,
        ClrTreeNodeLink,
        RecursiveChildren], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrLoadingModule], exports: [ClrTree,
        ClrTreeNode,
        ClrRecursiveForOf,
        ClrTreeNodeLink] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTreeViewModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrLoadingModule],
                declarations: [CLR_TREE_VIEW_DIRECTIVES, RecursiveChildren],
                exports: [CLR_TREE_VIEW_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrTreeViewModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrDataModule = /** @class */ (function () {
        function ClrDataModule() {
        }
ClrDataModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrDataModule });
ClrDataModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrDataModule_Factory(t) { return new (t || ClrDataModule)(); }, imports: [ClrDatagridModule,
        ClrStackViewModule,
        ClrTreeViewModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrDataModule, { exports: [ClrDatagridModule,
        ClrStackViewModule,
        ClrTreeViewModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDataModule, [{
        type: core.NgModule,
        args: [{ exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule] }]
    }], function () { return []; }, null); })();
        return ClrDataModule;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var FocusableItem = /** @class */ (function () {
        function FocusableItem() {
        }
        return FocusableItem;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function customFocusableItemProvider(implementation) {
        return [
            UNIQUE_ID_PROVIDER,
            implementation,
            {
                provide: FocusableItem,
                useExisting: implementation,
            },
        ];
    }

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ArrowKeyDirection;
    (function (ArrowKeyDirection) {
        ArrowKeyDirection["UP"] = "up";
        ArrowKeyDirection["DOWN"] = "down";
        ArrowKeyDirection["LEFT"] = "left";
        ArrowKeyDirection["RIGHT"] = "right";
    })(ArrowKeyDirection || (ArrowKeyDirection = {}));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var FocusService$1 = /** @class */ (function () {
        function FocusService(renderer) {
            this.renderer = renderer;
            this._unlistenFuncs = [];
        }
        Object.defineProperty(FocusService.prototype, "current", {
            get: function () {
                return this._current;
            },
            enumerable: true,
            configurable: true
        });
        FocusService.prototype.reset = function (first) {
            this._current = first;
        };
        FocusService.prototype.listenToArrowKeys = function (el) {
            var _this = this;
            // The following listeners return false when there was an action to take for the key pressed,
            // in order to prevent the default behavior of that key.
            this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowup', function (event) { return !_this.move(ArrowKeyDirection.UP); }));
            this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowdown', function (event) { return !_this.move(ArrowKeyDirection.DOWN); }));
            this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowleft', function (event) { return !_this.move(ArrowKeyDirection.LEFT); }));
            this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowright', function (event) { return !_this.move(ArrowKeyDirection.RIGHT); }));
        };
        FocusService.prototype.registerContainer = function (el) {
            var _this = this;
            this.renderer.setAttribute(el, 'tabindex', '0');
            this.listenToArrowKeys(el);
            // The following listeners return false when there was an action to take for the key pressed,
            // in order to prevent the default behavior of that key.
            this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.space', function () { return !_this.activateCurrent(); }));
            this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.enter', function () { return !_this.activateCurrent(); }));
        };
        FocusService.prototype.moveTo = function (item) {
            /**
             * Make sure that item is not undefined,
             * This is safety net in the case that someone sometime decide to
             * call this method without having FocusableItem.
             */
            if (item === undefined) {
                return;
            }
            if (this.current) {
                this.current.blur();
            }
            item.focus();
            this._current = item;
        };
        FocusService.prototype.move = function (direction) {
            var _this = this;
            var moved = false;
            if (this.current) {
                var next = this.current[direction];
                if (next) {
                    // Turning the value into an Observable isn't great, but it's the fastest way to avoid code duplication.
                    // If performance ever matters for this, we can refactor using additional private methods.
                    var nextObs = rxjs.isObservable(next) ? next : rxjs.of(next);
                    nextObs.subscribe(function (item) {
                        if (item) {
                            _this.moveTo(item);
                            moved = true;
                        }
                    });
                }
            }
            return moved;
        };
        FocusService.prototype.activateCurrent = function () {
            if (this.current && this.current.activate) {
                this.current.activate();
                return true;
            }
            return false;
        };
        FocusService.prototype.detachListeners = function () {
            this._unlistenFuncs.forEach(function (unlisten) { return unlisten(); });
        };
        FocusService.ctorParameters = function () { return [
            { type: core.Renderer2 }
        ]; };
FocusService.ɵfac = function FocusService$1_Factory(t) { return new (t || FocusService)(ɵngcc0.ɵɵinject(ɵngcc0.Renderer2)); };
FocusService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FocusService, factory: function (t) { return FocusService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, null); })();
        return FocusService;
    }());
    function clrFocusServiceFactory(existing, renderer) {
        return existing || new FocusService$1(renderer);
    }
    var FOCUS_SERVICE_PROVIDER = {
        provide: FocusService$1,
        useFactory: clrFocusServiceFactory,
        deps: [[new core.Optional(), new core.SkipSelf(), FocusService$1], core.Renderer2],
    };

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var Linkers = /** @class */ (function () {
        function Linkers() {
        }
        /**
         * Links a set of focusable items to a parent along one direction
         */
        Linkers.linkParent = function (items, parent, direction) {
            items.forEach(function (item) { return (item[direction] = parent); });
        };
        /**
         * Double-links a set of focusable items vertically, possibly looping
         */
        Linkers.linkVertical = function (items, loop) {
            if (loop === void 0) { loop = true; }
            items.forEach(function (item, index) {
                if (index > 0) {
                    item.up = items[index - 1];
                }
                if (index < items.length - 1) {
                    item.down = items[index + 1];
                }
            });
            if (loop && items.length > 1) {
                items[0].up = items[items.length - 1];
                items[items.length - 1].down = items[0];
            }
        };
        return Linkers;
    }());
    // Right now I only need the two linkers above, but we can easily add more linkers. A couple examples:
    // export function linkHorizontal(items: FocusableItem[], loop = true);
    // export function linkTable(items: FocusableItem[][]);

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function wrapObservable(observable, onSubscribe, onUnsubscribe) {
        return rxjs.Observable.create(function (observer) {
            onSubscribe(observer);
            var subscription = observable.subscribe(observer);
            return function () {
                subscription.unsubscribe();
                if (onUnsubscribe) {
                    onUnsubscribe(observer);
                }
            };
        });
    }

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DropdownFocusHandler = /** @class */ (function () {
        function DropdownFocusHandler(id, renderer, parent, toggleService, focusService, platformId) {
            this.id = id;
            this.renderer = renderer;
            this.parent = parent;
            this.toggleService = toggleService;
            this.focusService = focusService;
            this.platformId = platformId;
            this._unlistenFuncs = [];
            this.focusBackOnTrigger = false;
            this.resetChildren();
            this.moveToFirstItemWhenOpen();
            if (!this.parent) {
                this.handleRootFocus();
            }
        }
        /**
         * If the dropdown was opened by clicking on the trigger, we automatically move to the first item
         */
        DropdownFocusHandler.prototype.moveToFirstItemWhenOpen = function () {
            var _this = this;
            this.toggleService.openChange.subscribe(function (open) {
                if (open && _this.toggleService.originalEvent) {
                    // Even if we properly waited for ngAfterViewInit, the container still wouldn't be attached to the DOM.
                    // So setTimeout is the only way to wait for the container to be ready to move focus to first item.
                    setTimeout(function () {
                        _this.focusService.moveTo(_this);
                        if (_this.parent) {
                            _this.focusService.move(ArrowKeyDirection.RIGHT);
                        }
                        else {
                            _this.focusService.move(ArrowKeyDirection.DOWN);
                        }
                    });
                }
            });
        };
        /**
         * Focus on the menu when it opens, and focus back on the root trigger when the whole dropdown becomes closed
         */
        DropdownFocusHandler.prototype.handleRootFocus = function () {
            var _this = this;
            this.toggleService.openChange.subscribe(function (open) {
                if (!open) {
                    // We reset the state of the focus service both on initialization and when closing.
                    _this.focusService.reset(_this);
                    // But we only actively focus the trigger when closing, not on initialization.
                    if (_this.focusBackOnTrigger) {
                        _this.focus();
                    }
                }
                _this.focusBackOnTrigger = open;
            });
        };
        Object.defineProperty(DropdownFocusHandler.prototype, "trigger", {
            get: function () {
                return this._trigger;
            },
            set: function (el) {
                var _this = this;
                this._trigger = el;
                if (this.parent) {
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowright', function (event) { return _this.toggleService.toggleWithEvent(event); }));
                }
                else {
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowup', function (event) { return _this.toggleService.toggleWithEvent(event); }));
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.arrowdown', function (event) { return _this.toggleService.toggleWithEvent(event); }));
                    this.focusService.listenToArrowKeys(el);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DropdownFocusHandler.prototype, "container", {
            get: function () {
                return this._container;
            },
            set: function (el) {
                var _this = this;
                this._container = el;
                // whether root container or not, tab key should always toggle (i.e. close) the container
                this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.tab', function (event) { return _this.toggleService.toggleWithEvent(event); }));
                if (this.parent) {
                    // if it's a nested container, pressing esc has the same effect as pressing left key, which closes the current
                    // popup and moves up to its parent. Here, we stop propagation so that the parent container
                    // doesn't receive the esc keydown
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.esc', function (event) {
                        _this.focusService.move(ArrowKeyDirection.LEFT);
                        event.stopPropagation();
                    }));
                }
                else {
                    // The root container is the only one we register to the focus service, others do not need focus
                    this.focusService.registerContainer(el);
                    // The root container will simply close the container when esc key is pressed
                    this._unlistenFuncs.push(this.renderer.listen(el, 'keydown.esc', function (event) { return _this.toggleService.toggleWithEvent(event); }));
                    // When the user moves focus outside of the menu, we close the dropdown
                    this._unlistenFuncs.push(this.renderer.listen(el, 'blur', function (event) {
                        // we clear out any existing focus on the items
                        _this.children.pipe(operators.take(1)).subscribe(function (items) { return items.forEach(function (item) { return item.blur(); }); });
                        // event.relatedTarget is null in IE11. In that case we use document.activeElement which correctly points
                        // to the element we want to check. Note that other browsers might point document.activeElement to the
                        // wrong element. This is ok, because all the other browsers we support relies on event.relatedTarget.
                        var target = event.relatedTarget || document.activeElement;
                        // If the user clicks on an item which triggers the blur, we don't want to close it since it may open a submenu.
                        // In the case of needing to close it (i.e. user selected an item and the dropdown menu is set to close on
                        // selection), dropdown-item.ts handles it.
                        if (target && common.isPlatformBrowser(_this.platformId)) {
                            if (el.contains(target) || target === _this.trigger) {
                                return;
                            }
                        }
                        // We let the user move focus to where the want, we don't force the focus back on the trigger
                        _this.focusBackOnTrigger = false;
                        _this.toggleService.open = false;
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        DropdownFocusHandler.prototype.focus = function () {
            if (this.trigger && common.isPlatformBrowser(this.platformId)) {
                this.trigger.focus();
            }
        };
        DropdownFocusHandler.prototype.blur = function () {
            if (this.trigger && common.isPlatformBrowser(this.platformId)) {
                this.trigger.blur();
            }
        };
        DropdownFocusHandler.prototype.activate = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.trigger.click();
            }
        };
        DropdownFocusHandler.prototype.openAndGetChildren = function () {
            var _this = this;
            return wrapObservable(this.children, function () { return (_this.toggleService.open = true); });
        };
        DropdownFocusHandler.prototype.closeAndGetThis = function () {
            var _this = this;
            return wrapObservable(rxjs.of(this), function () { return (_this.toggleService.open = false); });
        };
        DropdownFocusHandler.prototype.resetChildren = function () {
            this.children = new rxjs.ReplaySubject(1);
            if (this.parent) {
                this.right = this.openAndGetChildren().pipe(operators.map(function (all) { return all[0]; }));
            }
            else {
                this.down = this.openAndGetChildren().pipe(operators.map(function (all) { return all[0]; }));
                this.up = this.openAndGetChildren().pipe(operators.map(function (all) { return all[all.length - 1]; }));
            }
        };
        DropdownFocusHandler.prototype.addChildren = function (children) {
            Linkers.linkVertical(children);
            if (this.parent) {
                Linkers.linkParent(children, this.closeAndGetThis(), ArrowKeyDirection.LEFT);
            }
            this.children.next(children);
        };
        DropdownFocusHandler.prototype.ngOnDestroy = function () {
            this._unlistenFuncs.forEach(function (unlisten) { return unlisten(); });
            this.focusService.detachListeners();
        };
        DropdownFocusHandler.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: core.Renderer2 },
            { type: DropdownFocusHandler, decorators: [{ type: core.SkipSelf }, { type: core.Optional }] },
            { type: ClrPopoverToggleService },
            { type: FocusService$1 },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        DropdownFocusHandler = __decorate([ __param(0, core.Inject(UNIQUE_ID)),
            __param(2, core.SkipSelf()),
            __param(2, core.Optional()),
            __param(5, core.Inject(core.PLATFORM_ID))
        ], DropdownFocusHandler);
DropdownFocusHandler.ɵfac = function DropdownFocusHandler_Factory(t) { return new (t || DropdownFocusHandler)(ɵngcc0.ɵɵinject(UNIQUE_ID), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(DropdownFocusHandler, 12), ɵngcc0.ɵɵinject(ClrPopoverToggleService), ɵngcc0.ɵɵinject(FocusService$1), ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
DropdownFocusHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DropdownFocusHandler, factory: function (t) { return DropdownFocusHandler.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropdownFocusHandler, [{
        type: core.Injectable
    }], function () { return [{ type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: ɵngcc0.Renderer2 }, { type: DropdownFocusHandler, decorators: [{
                type: core.SkipSelf
            }, {
                type: core.Optional
            }] }, { type: ClrPopoverToggleService }, { type: FocusService$1 }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return DropdownFocusHandler;
    }());
    var DROPDOWN_FOCUS_HANDLER_PROVIDER = customFocusableItemProvider(DropdownFocusHandler);

    var RootDropdownService = /** @class */ (function () {
        function RootDropdownService() {
            this._changes = new rxjs.Subject();
        }
        Object.defineProperty(RootDropdownService.prototype, "changes", {
            get: function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        RootDropdownService.prototype.closeMenus = function () {
            this._changes.next(false);
        };
RootDropdownService.ɵfac = function RootDropdownService_Factory(t) { return new (t || RootDropdownService)(); };
RootDropdownService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RootDropdownService, factory: function (t) { return RootDropdownService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RootDropdownService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return RootDropdownService;
    }());
    function clrRootDropdownFactory(existing) {
        return existing || new RootDropdownService();
    }
    var ROOT_DROPDOWN_PROVIDER = {
        provide: RootDropdownService,
        useFactory: clrRootDropdownFactory,
        deps: [[new core.Optional(), new core.SkipSelf(), RootDropdownService]],
    };

    var ClrDropdown = /** @class */ (function () {
        function ClrDropdown(parent, toggleService, cdr, dropdownService) {
            var _this = this;
            this.parent = parent;
            this.toggleService = toggleService;
            this.cdr = cdr;
            this.subscriptions = [];
            this.isMenuClosable = true;
            this.subscriptions.push(dropdownService.changes.subscribe(function (value) { return (_this.toggleService.open = value); }));
            this.subscriptions.push(toggleService.openChange.subscribe(function (value) { return _this.cdr.markForCheck(); }));
        }
        ClrDropdown.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrDropdown.ctorParameters = function () { return [
            { type: ClrDropdown, decorators: [{ type: core.SkipSelf }, { type: core.Optional }] },
            { type: ClrPopoverToggleService },
            { type: core.ChangeDetectorRef },
            { type: RootDropdownService }
        ]; };
        __decorate([
            core.Input('clrCloseMenuOnItemClick')
        ], ClrDropdown.prototype, "isMenuClosable", void 0);
        ClrDropdown = __decorate([ __param(0, core.SkipSelf()),
            __param(0, core.Optional())
        ], ClrDropdown);
ClrDropdown.ɵfac = function ClrDropdown_Factory(t) { return new (t || ClrDropdown)(ɵngcc0.ɵɵdirectiveInject(ClrDropdown, 12), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RootDropdownService)); };
ClrDropdown.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDropdown, selectors: [["clr-dropdown"]], hostVars: 4, hostBindings: function ClrDropdown_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("dropdown", true)("open", ctx.toggleService.open);
    } }, inputs: { isMenuClosable: ["clrCloseMenuOnItemClick", "isMenuClosable"] }, features: [ɵngcc0.ɵɵProvidersFeature([
            ROOT_DROPDOWN_PROVIDER,
            { provide: POPOVER_HOST_ANCHOR, useExisting: core.ElementRef },
            FOCUS_SERVICE_PROVIDER,
            ClrPopoverToggleService,
            DROPDOWN_FOCUS_HANDLER_PROVIDER,
        ])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrDropdown_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDropdown, [{
        type: core.Component,
        args: [{
                selector: 'clr-dropdown',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.dropdown]': 'true',
                    '[class.open]': 'toggleService.open'
                },
                providers: [
                    ROOT_DROPDOWN_PROVIDER,
                    { provide: POPOVER_HOST_ANCHOR, useExisting: core.ElementRef },
                    FOCUS_SERVICE_PROVIDER,
                    ClrPopoverToggleService,
                    DROPDOWN_FOCUS_HANDLER_PROVIDER,
                ]
            }]
    }], function () { return [{ type: ClrDropdown, decorators: [{
                type: core.SkipSelf
            }, {
                type: core.Optional
            }] }, { type: ClrPopoverToggleService }, { type: ɵngcc0.ChangeDetectorRef }, { type: RootDropdownService }]; }, { isMenuClosable: [{
            type: core.Input,
            args: ['clrCloseMenuOnItemClick']
        }] }); })();
        return ClrDropdown;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var BasicFocusableItem = /** @class */ (function () {
        function BasicFocusableItem(id, el, renderer, platformId) {
            this.id = id;
            this.el = el;
            this.renderer = renderer;
            this.platformId = platformId;
            this.disabled = false;
            renderer.setAttribute(el.nativeElement, 'id', id);
            renderer.setAttribute(el.nativeElement, 'tabindex', '-1');
        }
        BasicFocusableItem.prototype.focus = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
                this.el.nativeElement.focus();
            }
        };
        BasicFocusableItem.prototype.blur = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '-1');
                this.el.nativeElement.blur();
            }
        };
        BasicFocusableItem.prototype.activate = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.el.nativeElement.click();
            }
        };
        BasicFocusableItem.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        BasicFocusableItem = __decorate([ __param(0, core.Inject(UNIQUE_ID)),
            __param(3, core.Inject(core.PLATFORM_ID))
        ], BasicFocusableItem);
BasicFocusableItem.ɵfac = function BasicFocusableItem_Factory(t) { return new (t || BasicFocusableItem)(ɵngcc0.ɵɵinject(UNIQUE_ID), ɵngcc0.ɵɵinject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(core.PLATFORM_ID)); };
BasicFocusableItem.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BasicFocusableItem, factory: function (t) { return BasicFocusableItem.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BasicFocusableItem, [{
        type: core.Injectable
    }], function () { return [{ type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, null); })();
        return BasicFocusableItem;
    }());
    var BASIC_FOCUSABLE_ITEM_PROVIDER = [
        UNIQUE_ID_PROVIDER,
        {
            provide: FocusableItem,
            useClass: BasicFocusableItem,
        },
    ];

    var ClrDropdownItem = /** @class */ (function () {
        function ClrDropdownItem(dropdown, el, _dropdownService, renderer, focusableItem) {
            this.dropdown = dropdown;
            this.el = el;
            this._dropdownService = _dropdownService;
            this.renderer = renderer;
            this.focusableItem = focusableItem;
            this.setByDeprecatedDisabled = false;
        }
        Object.defineProperty(ClrDropdownItem.prototype, "disabled", {
            get: function () {
                return this.focusableItem.disabled;
            },
            set: function (value) {
                // Empty string attribute evaluates to false but should disable the item, so we need to add a special case for it.
                this.focusableItem.disabled = !!value || value === '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDropdownItem.prototype, "disabledDeprecated", {
            get: function () {
                return this.focusableItem.disabled;
            },
            /*
             * @deprecated since 3.0, remove in 4.0. the presence of this attribute makes it not-focusable in IE11. Use [clrDisabled] input instead.
             */
            set: function (value) {
                // Empty string attribute evaluates to false but should disable the item, so we need to add a special case for it.
                this.focusableItem.disabled = !!value || value === '';
                this.setByDeprecatedDisabled = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDropdownItem.prototype, "dropdownItemId", {
            get: function () {
                return this.focusableItem.id;
            },
            /**
             * Let you overwrite the focusable auto increment id.
             */
            set: function (value) {
                this.focusableItem.id = value;
            },
            enumerable: true,
            configurable: true
        });
        ClrDropdownItem.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.unlisten = this.renderer.listen(this.el.nativeElement, 'click', function () { return _this.onDropdownItemClick(); });
        };
        ClrDropdownItem.prototype.onDropdownItemClick = function () {
            if (this.dropdown.isMenuClosable && !this.el.nativeElement.classList.contains('disabled')) {
                this._dropdownService.closeMenus();
            }
        };
        ClrDropdownItem.prototype.ngOnDestroy = function () {
            if (this.unlisten) {
                this.unlisten();
            }
        };
        ClrDropdownItem.ctorParameters = function () { return [
            { type: ClrDropdown },
            { type: core.ElementRef },
            { type: RootDropdownService },
            { type: core.Renderer2 },
            { type: FocusableItem }
        ]; };
        __decorate([
            core.Input('clrDisabled')
        ], ClrDropdownItem.prototype, "disabled", null);
        __decorate([
            core.Input('disabled')
        ], ClrDropdownItem.prototype, "disabledDeprecated", null);
        __decorate([
            core.Input('id')
        ], ClrDropdownItem.prototype, "dropdownItemId", null);
ClrDropdownItem.ɵfac = function ClrDropdownItem_Factory(t) { return new (t || ClrDropdownItem)(ɵngcc0.ɵɵdirectiveInject(ClrDropdown), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(RootDropdownService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(FocusableItem)); };
ClrDropdownItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDropdownItem, selectors: [["", "clrDropdownItem", ""]], hostVars: 8, hostBindings: function ClrDropdownItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "menuitem")("aria-disabled", ctx.disabled)("disabled", ctx.disabled && ctx.setByDeprecatedDisabled ? "" : null)("id", ctx.dropdownItemId);
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled)("dropdown-item", true);
    } }, inputs: { disabled: ["clrDisabled", "disabled"], disabledDeprecated: ["disabled", "disabledDeprecated"], dropdownItemId: ["id", "dropdownItemId"] }, features: [ɵngcc0.ɵɵProvidersFeature([BASIC_FOCUSABLE_ITEM_PROVIDER])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDropdownItem, [{
        type: core.Directive,
        args: [{
                selector: '[clrDropdownItem]',
                host: {
                    '[class.disabled]': 'disabled',
                    '[class.dropdown-item]': 'true',
                    '[attr.role]': '"menuitem"',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.disabled]': "(disabled && setByDeprecatedDisabled)? '' : null",
                    '[attr.id]': 'dropdownItemId'
                },
                providers: [BASIC_FOCUSABLE_ITEM_PROVIDER]
            }]
    }], function () { return [{ type: ClrDropdown }, { type: ɵngcc0.ElementRef }, { type: RootDropdownService }, { type: ɵngcc0.Renderer2 }, { type: FocusableItem }]; }, { disabled: [{
            type: core.Input,
            args: ['clrDisabled']
        }], disabledDeprecated: [{
            type: core.Input,
            args: ['disabled']
        }], dropdownItemId: [{
            type: core.Input,
            args: ['id']
        }] }); })();
        return ClrDropdownItem;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var Point;
    (function (Point) {
        Point[Point["RIGHT_CENTER"] = 0] = "RIGHT_CENTER";
        Point[Point["RIGHT_TOP"] = 1] = "RIGHT_TOP";
        Point[Point["RIGHT_BOTTOM"] = 2] = "RIGHT_BOTTOM";
        Point[Point["TOP_CENTER"] = 3] = "TOP_CENTER";
        Point[Point["TOP_RIGHT"] = 4] = "TOP_RIGHT";
        Point[Point["TOP_LEFT"] = 5] = "TOP_LEFT";
        Point[Point["BOTTOM_CENTER"] = 6] = "BOTTOM_CENTER";
        Point[Point["BOTTOM_RIGHT"] = 7] = "BOTTOM_RIGHT";
        Point[Point["BOTTOM_LEFT"] = 8] = "BOTTOM_LEFT";
        Point[Point["LEFT_CENTER"] = 9] = "LEFT_CENTER";
        Point[Point["LEFT_TOP"] = 10] = "LEFT_TOP";
        Point[Point["LEFT_BOTTOM"] = 11] = "LEFT_BOTTOM";
    })(Point || (Point = {}));
    var POSITION_RELATIVE = 'relative';
    var POSITION_ABSOLUTE = 'absolute';
    var POSITION_FIXED = 'fixed';
    var OVERFLOW_SCROLL = 'scroll';
    var OVERFLOW_AUTO = 'auto';
    var Popover = /** @class */ (function () {
        function Popover(element) {
            this.element = element;
            /*
             * Containers up to the first positioned one will have an event on scroll
             */
            this.scrollableElements = [];
            this.boundOnScrollListener = this.emitScrollEvent.bind(this);
            // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
            element.style.position = POSITION_ABSOLUTE;
            element.style.top = 0;
            element.style.bottom = 'auto';
            element.style.left = 0;
            element.style.right = 'auto';
        }
        // TODO: need a way to account for parameters that change dynamically (positioning).
        Popover.prototype.anchor = function (anchor, anchorAlign, popoverAlign, _a) {
            // TODO: we are assuming here that the popover is inside or next to the anchor.
            // We'd need to go up the popover tree too otherwise
            var _b = _a === void 0 ? {} : _a, _c = _b.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _b.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _b.useAnchorParent, useAnchorParent = _e === void 0 ? false : _e;
            this.addScrollEventListeners(anchor);
            if (useAnchorParent) {
                anchor = anchor.parentNode;
            }
            // explicitly override anchor's style to static
            anchor.style.position = 'static';
            var anchorRect = anchor.getBoundingClientRect();
            var popoverRect = this.element.getBoundingClientRect();
            // position of left top corner of anchor + the offset
            var leftDiff = anchorRect.left - popoverRect.left + offsetX;
            var topDiff = anchorRect.top - popoverRect.top + offsetY;
            // first, adjust positioning based on anchor's align point
            switch (anchorAlign) {
                case Point.LEFT_TOP:
                case Point.TOP_LEFT:
                    break;
                case Point.TOP_CENTER:
                    leftDiff += anchorRect.width / 2;
                    break;
                case Point.TOP_RIGHT:
                    leftDiff += anchorRect.width;
                    break;
                case Point.RIGHT_TOP:
                    leftDiff += anchorRect.width;
                    break;
                case Point.LEFT_BOTTOM:
                    topDiff += anchorRect.height;
                    break;
                case Point.BOTTOM_LEFT:
                    topDiff += anchorRect.height;
                    break;
                case Point.BOTTOM_CENTER:
                    topDiff += anchorRect.height;
                    leftDiff += anchorRect.width / 2;
                    break;
                case Point.BOTTOM_RIGHT:
                    topDiff += anchorRect.height;
                    leftDiff += anchorRect.width;
                    break;
                case Point.RIGHT_BOTTOM:
                    topDiff += anchorRect.height;
                    leftDiff += anchorRect.width;
                    break;
                case Point.LEFT_CENTER:
                    topDiff += anchorRect.height / 2;
                    break;
                case Point.RIGHT_CENTER:
                    topDiff += anchorRect.height / 2;
                    leftDiff += anchorRect.width;
                    break;
                default:
            }
            // second, adjust positioning based on popover's align point
            switch (popoverAlign) {
                case Point.LEFT_TOP:
                case Point.TOP_LEFT:
                    break;
                case Point.TOP_CENTER:
                    leftDiff -= popoverRect.width / 2;
                    break;
                case Point.TOP_RIGHT:
                    leftDiff -= popoverRect.width;
                    break;
                case Point.RIGHT_TOP:
                    leftDiff -= popoverRect.width;
                    break;
                case Point.LEFT_BOTTOM:
                    topDiff -= popoverRect.height;
                    break;
                case Point.BOTTOM_LEFT:
                    topDiff -= popoverRect.height;
                    break;
                case Point.BOTTOM_CENTER:
                    topDiff -= popoverRect.height;
                    leftDiff -= popoverRect.width / 2;
                    break;
                case Point.BOTTOM_RIGHT:
                    topDiff -= popoverRect.height;
                    leftDiff -= popoverRect.width;
                    break;
                case Point.RIGHT_BOTTOM:
                    topDiff -= popoverRect.height;
                    leftDiff -= popoverRect.width;
                    break;
                case Point.LEFT_CENTER:
                    topDiff -= popoverRect.height / 2;
                    break;
                case Point.RIGHT_CENTER:
                    topDiff -= popoverRect.height / 2;
                    leftDiff -= popoverRect.width;
                    break;
                default:
            }
            // Third, adjust with popover's margins based on the two align points.
            // Here, we make an assumption that popover is primarily positioned outside the
            // anchor with minor offset. Without this assumption, it's impossible to apply
            // the popover's margins in a predictable way. For example, assume that a popover
            // and its anchor are exactly the same size. if a popover is positioned inside the
            // anchor (which is technically possible), then it becomes impossible to know what to do
            // if the popover has a non-zero margin value all around (because applying the margin in
            // all four directions will result in no margin visually, which isn't what we want).
            // Therefore, our logic makes assumptions about margins of interest given the points,
            // and only covers the cases where popover is outside the anchor.
            var popoverComputedStyle = getComputedStyle(this.element);
            var marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
            var marginRight = parseInt(popoverComputedStyle.marginRight, 10);
            var marginTop = parseInt(popoverComputedStyle.marginTop, 10);
            var marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
            switch (anchorAlign) {
                case Point.LEFT_TOP:
                case Point.TOP_LEFT:
                case Point.TOP_RIGHT:
                case Point.RIGHT_TOP:
                    if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                        topDiff -= marginBottom;
                        leftDiff -= marginRight;
                    }
                    if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                        topDiff -= marginTop;
                        leftDiff += marginLeft;
                    }
                    if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                        topDiff += marginTop;
                        leftDiff += marginLeft;
                    }
                    if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                        topDiff += marginTop;
                        leftDiff -= marginRight;
                    }
                    break;
                case Point.LEFT_BOTTOM:
                case Point.BOTTOM_LEFT:
                case Point.BOTTOM_RIGHT:
                case Point.RIGHT_BOTTOM:
                    if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                        topDiff -= marginBottom;
                        leftDiff += marginLeft;
                    }
                    if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                        topDiff -= marginBottom;
                        leftDiff -= marginRight;
                    }
                    if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                        topDiff += marginTop;
                        leftDiff += marginLeft;
                    }
                    if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                        topDiff += marginTop;
                        leftDiff -= marginRight;
                    }
                    break;
                case Point.TOP_CENTER:
                    topDiff -= marginBottom;
                    leftDiff += marginLeft;
                    leftDiff -= marginRight;
                    break;
                case Point.BOTTOM_CENTER:
                    topDiff += marginTop;
                    leftDiff += marginLeft;
                    leftDiff -= marginRight;
                    break;
                case Point.LEFT_CENTER:
                    topDiff += marginTop;
                    topDiff -= marginBottom;
                    leftDiff -= marginRight;
                    break;
                case Point.RIGHT_CENTER:
                    topDiff += marginTop;
                    topDiff -= marginBottom;
                    leftDiff += marginLeft;
                    break;
                default:
            }
            this.element.style.transform = "translateX(" + Math.round(leftDiff) + "px) translateY(" + Math.round(topDiff) + "px)";
            return this._scroll.asObservable();
        };
        Popover.prototype.release = function () {
            this.element.style.transform = '';
            this.removeScrollEventListeners();
        };
        Popover.prototype.isPositioned = function (container) {
            var position = getComputedStyle(container).position;
            return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
        };
        Popover.prototype.emitScrollEvent = function () {
            this._scroll.next();
        };
        Popover.prototype.addScrollEventListeners = function (e) {
            this._scroll = new rxjs.Subject();
            var anchor = e;
            var current = e;
            while (current && current !== document) {
                if (this.scrolls(current)) {
                    current.addEventListener('scroll', this.boundOnScrollListener);
                    this.scrollableElements.push(current);
                }
                if (current !== anchor && this.isPositioned(current)) {
                    break;
                }
                current = current.parentNode;
            }
        };
        Popover.prototype.removeScrollEventListeners = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this.scrollableElements), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var elem = _c.value;
                    elem.removeEventListener('scroll', this.boundOnScrollListener);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.scrollableElements.length = 0;
            if (this._scroll) {
                this._scroll.complete();
                delete this._scroll;
            }
        };
        Popover.prototype.scrolls = function (container) {
            var computedStyles = getComputedStyle(container);
            return (computedStyles.overflowX === OVERFLOW_SCROLL ||
                computedStyles.overflowX === OVERFLOW_AUTO ||
                computedStyles.overflowY === OVERFLOW_SCROLL ||
                computedStyles.overflowY === OVERFLOW_AUTO);
        };
        return Popover;
    }());

    // Literally any annotation would work here, but writing our own @HoneyBadger annotation feels overkill.
    var AbstractPopover = /** @class */ (function () {
        function AbstractPopover(injector, parentHost) {
            var _this = this;
            this.parentHost = parentHost;
            this.updateAnchor = false;
            this.popoverOptions = {};
            /*
               * Until https://github.com/angular/angular/issues/8785 is supported, we don't have any way to instantiate
               * a separate directive on the host. So let's do dirty but performant for now.
               */
            this.closeOnOutsideClick = false;
            this.el = injector.get(core.ElementRef);
            this.toggleService = injector.get(ClrPopoverToggleService);
            this.renderer = injector.get(core.Renderer2);
            // Default anchor is the parent host
            this.anchorElem = parentHost.nativeElement;
            this.popoverInstance = new Popover(this.el.nativeElement);
            this.subscription = this.toggleService.openChange.subscribe(function (change) {
                if (change) {
                    _this.anchor();
                    _this.attachESCListener();
                }
                else {
                    _this.release();
                    _this.detachESCListener();
                }
            });
            if (this.toggleService.open) {
                this.anchor();
                this.attachESCListener();
            }
        }
        AbstractPopover.prototype.anchor = function () {
            this.updateAnchor = true;
            // Ugh
            this.ignore = this.toggleService.originalEvent;
        };
        AbstractPopover.prototype.release = function () {
            this.detachOutsideClickListener();
            this.popoverInstance.release();
        };
        AbstractPopover.prototype.ngAfterViewChecked = function () {
            var _this = this;
            if (this.updateAnchor) {
                this.updateAnchor = false;
                this.popoverInstance
                    .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                    .subscribe(function () {
                    // if a scroll event is detected, close the popover
                    _this.toggleService.open = false;
                });
                this.attachOutsideClickListener();
            }
        };
        AbstractPopover.prototype.ngOnDestroy = function () {
            this.release();
            this.detachESCListener();
            this.subscription.unsubscribe();
        };
        Object.defineProperty(AbstractPopover.prototype, "isOffScreen", {
            /*
               * Fallback to hide when *clrIfOpen is not being used
               */
            get: function () {
                return this.toggleService.open ? false : true;
            },
            enumerable: true,
            configurable: true
        });
        AbstractPopover.prototype.attachESCListener = function () {
            var _this = this;
            if (!this.popoverOptions.ignoreGlobalESCListener) {
                this.documentESCListener = this.renderer.listen('document', 'keydown', function (event) {
                    if (event && event.key) {
                        if (event.key === 'Escape' || event.key === 'Esc') {
                            _this.toggleService.open = false;
                        }
                    }
                });
            }
        };
        AbstractPopover.prototype.detachESCListener = function () {
            if (this.documentESCListener) {
                this.documentESCListener();
                delete this.documentESCListener;
            }
        };
        AbstractPopover.prototype.attachOutsideClickListener = function () {
            var _this = this;
            if (this.closeOnOutsideClick) {
                this.hostClickListener = this.renderer.listen(this.el.nativeElement, 'click', function (event) { return (_this.ignore = event); });
                if (this.ignoredElement) {
                    this.ignoredElementClickListener = this.renderer.listen(this.ignoredElement, 'click', function (event) { return (_this.ignore = event); });
                }
                this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
                    if (event === _this.ignore) {
                        delete _this.ignore;
                    }
                    else {
                        _this.toggleService.open = false;
                    }
                });
            }
        };
        AbstractPopover.prototype.detachOutsideClickListener = function () {
            if (this.closeOnOutsideClick) {
                if (this.hostClickListener) {
                    this.hostClickListener();
                    delete this.hostClickListener;
                }
                if (this.ignoredElementClickListener) {
                    this.ignoredElementClickListener();
                    delete this.ignoredElementClickListener;
                }
                if (this.documentClickListener) {
                    this.documentClickListener();
                    delete this.documentClickListener;
                }
            }
        };
        AbstractPopover.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ElementRef, decorators: [{ type: core.SkipSelf }] }
        ]; };
        __decorate([
            core.HostBinding('class.is-off-screen')
        ], AbstractPopover.prototype, "isOffScreen", null);
        AbstractPopover = __decorate([ __param(1, core.SkipSelf())
        ], AbstractPopover);
AbstractPopover.ɵfac = function AbstractPopover_Factory(t) { return new (t || AbstractPopover)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc0.ElementRef, 4)); };
AbstractPopover.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AbstractPopover, factory: function (t) { return AbstractPopover.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AbstractPopover, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef, decorators: [{
                type: core.SkipSelf
            }] }]; }, { isOffScreen: [{
            type: core.HostBinding,
            args: ['class.is-off-screen']
        }] }); })();
        return AbstractPopover;
    }());

    var ClrDropdownMenu = /** @class */ (function (_super) {
        __extends(ClrDropdownMenu, _super);
        function ClrDropdownMenu(injector, parentHost, nested, focusHandler) {
            var _this = this;
            if (!parentHost) {
                throw new Error('clr-dropdown-menu should only be used inside of a clr-dropdown');
            }
            _this = _super.call(this, injector, parentHost) || this;
            if (!nested) {
                // Default positioning for normal dropdown is bottom-left
                _this.anchorPoint = Point.BOTTOM_LEFT;
                _this.popoverPoint = Point.LEFT_TOP;
            }
            else {
                // Default positioning for nested dropdown is right-top
                _this.anchorPoint = Point.RIGHT_TOP;
                _this.popoverPoint = Point.LEFT_TOP;
            }
            _this.popoverOptions.allowMultipleOpen = true;
            _this.popoverOptions.ignoreGlobalESCListener = true;
            _this.closeOnOutsideClick = true;
            _this.focusHandler = focusHandler;
            return _this;
        }
        Object.defineProperty(ClrDropdownMenu.prototype, "position", {
            set: function (position) {
                // set the popover values based on menu position
                switch (position) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_RIGHT;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_LEFT;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_RIGHT;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-top':
                        this.anchorPoint = Point.RIGHT_TOP;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-bottom':
                        this.anchorPoint = Point.RIGHT_BOTTOM;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'left-top':
                        this.anchorPoint = Point.LEFT_TOP;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'left-bottom':
                        this.anchorPoint = Point.LEFT_BOTTOM;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    default:
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDropdownMenu.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.focusHandler.container = this.el.nativeElement;
            this.items.changes.subscribe(function () { return _this.focusHandler.addChildren(_this.items.toArray()); });
            // I saw this on GitHub as a solution to avoid code duplication because of missed QueryList changes
            this.items.notifyOnChanges();
        };
        ClrDropdownMenu.prototype.ngOnDestroy = function () {
            _super.prototype.ngOnDestroy.call(this);
            this.focusHandler.resetChildren();
        };
        ClrDropdownMenu.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ElementRef, decorators: [{ type: core.Optional }, { type: core.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
            { type: ClrDropdownMenu, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: DropdownFocusHandler }
        ]; };
        __decorate([
            core.Input('clrPosition')
        ], ClrDropdownMenu.prototype, "position", null);
        __decorate([
            core.ContentChildren(FocusableItem)
        ], ClrDropdownMenu.prototype, "items", void 0);
        ClrDropdownMenu = __decorate([ __param(1, core.Optional()),
            __param(1, core.Inject(POPOVER_HOST_ANCHOR)),
            __param(2, core.Optional()),
            __param(2, core.SkipSelf())
        ], ClrDropdownMenu);
ClrDropdownMenu.ɵfac = function ClrDropdownMenu_Factory(t) { return new (t || ClrDropdownMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵngcc0.ɵɵdirectiveInject(ClrDropdownMenu, 12), ɵngcc0.ɵɵdirectiveInject(DropdownFocusHandler)); };
ClrDropdownMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrDropdownMenu, selectors: [["clr-dropdown-menu"]], contentQueries: function ClrDropdownMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FocusableItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostVars: 3, hostBindings: function ClrDropdownMenu_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "menu");
        ɵngcc0.ɵɵclassProp("dropdown-menu", true);
    } }, inputs: { position: ["clrPosition", "position"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrDropdownMenu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDropdownMenu, [{
        type: core.Component,
        args: [{
                selector: 'clr-dropdown-menu',
                template: "\n        <ng-content></ng-content>\n    ",
                host: {
                    '[class.dropdown-menu]': 'true',
                    '[attr.role]': '"menu"'
                }
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [POPOVER_HOST_ANCHOR]
            }] }, { type: ClrDropdownMenu, decorators: [{
                type: core.Optional
            }, {
                type: core.SkipSelf
            }] }, { type: DropdownFocusHandler }]; }, { position: [{
            type: core.Input,
            args: ['clrPosition']
        }], items: [{
            type: core.ContentChildren,
            args: [FocusableItem]
        }] }); })();
        return ClrDropdownMenu;
    }(AbstractPopover));

    var ClrDropdownTrigger = /** @class */ (function () {
        function ClrDropdownTrigger(dropdown, toggleService, el, focusHandler) {
            this.toggleService = toggleService;
            this.isRootLevelToggle = true;
            // if the containing dropdown has a parent, then this is not the root level one
            if (dropdown.parent) {
                this.isRootLevelToggle = false;
            }
            focusHandler.trigger = el.nativeElement;
        }
        Object.defineProperty(ClrDropdownTrigger.prototype, "active", {
            get: function () {
                return this.toggleService.open;
            },
            enumerable: true,
            configurable: true
        });
        ClrDropdownTrigger.prototype.onDropdownTriggerClick = function (event) {
            this.toggleService.toggleWithEvent(event);
        };
        ClrDropdownTrigger.ctorParameters = function () { return [
            { type: ClrDropdown },
            { type: ClrPopoverToggleService },
            { type: core.ElementRef },
            { type: DropdownFocusHandler }
        ]; };
        __decorate([
            core.HostListener('click', ['$event'])
        ], ClrDropdownTrigger.prototype, "onDropdownTriggerClick", null);
ClrDropdownTrigger.ɵfac = function ClrDropdownTrigger_Factory(t) { return new (t || ClrDropdownTrigger)(ɵngcc0.ɵɵdirectiveInject(ClrDropdown), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DropdownFocusHandler)); };
ClrDropdownTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrDropdownTrigger, selectors: [["", "clrDropdownTrigger", ""], ["", "clrDropdownToggle", ""]], hostVars: 10, hostBindings: function ClrDropdownTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrDropdownTrigger_click_HostBindingHandler($event) { return ctx.onDropdownTriggerClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-haspopup", "menu")("aria-expanded", ctx.active);
        ɵngcc0.ɵɵclassProp("dropdown-toggle", ctx.isRootLevelToggle)("dropdown-item", !ctx.isRootLevelToggle)("expandable", !ctx.isRootLevelToggle)("active", ctx.active);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDropdownTrigger, [{
        type: core.Directive,
        args: [{
                // We support both selectors for legacy reasons
                selector: '[clrDropdownTrigger],[clrDropdownToggle]',
                host: {
                    '[class.dropdown-toggle]': 'isRootLevelToggle',
                    '[class.dropdown-item]': '!isRootLevelToggle',
                    '[class.expandable]': '!isRootLevelToggle',
                    '[class.active]': 'active',
                    '[attr.aria-haspopup]': '"menu"',
                    '[attr.aria-expanded]': 'active'
                }
            }]
    }], function () { return [{ type: ClrDropdown }, { type: ClrPopoverToggleService }, { type: ɵngcc0.ElementRef }, { type: DropdownFocusHandler }]; }, { onDropdownTriggerClick: [{
            type: core.HostListener,
            args: ['click', ['$event']]
        }] }); })();
        return ClrDropdownTrigger;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
    var ClrDropdownModule = /** @class */ (function () {
        function ClrDropdownModule() {
        }
ClrDropdownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrDropdownModule });
ClrDropdownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrDropdownModule_Factory(t) { return new (t || ClrDropdownModule)(); }, imports: [[common.CommonModule],
        ClrConditionalModule,
        ClrIconModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrDropdownModule, { declarations: [ClrDropdown,
        ClrDropdownMenu,
        ClrDropdownTrigger,
        ClrDropdownItem], imports: [ɵngcc1.CommonModule], exports: [ClrDropdown,
        ClrDropdownMenu,
        ClrDropdownTrigger,
        ClrDropdownItem,
        ClrConditionalModule,
        ClrIconModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrDropdownModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [CLR_DROPDOWN_DIRECTIVES],
                exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule]
            }]
    }], function () { return []; }, null); })();
        return ClrDropdownModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // @TODO Make this an enum
    var ALERT_TYPES = ['info', 'warning', 'danger', 'success'];

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var AlertIconAndTypesService = /** @class */ (function () {
        function AlertIconAndTypesService(commonStrings) {
            this.commonStrings = commonStrings;
            this.defaultIconShape = 'info-circle';
            this._alertIconShape = '';
            this._alertType = 'info';
        }
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertType", {
            get: function () {
                return this._alertType;
            },
            set: function (val) {
                if (ALERT_TYPES.indexOf(val) > -1) {
                    this._alertType = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconShape", {
            get: function () {
                if ('' === this._alertIconShape) {
                    return this.iconInfoFromType(this._alertType).shape;
                }
                return this._alertIconShape;
            },
            set: function (val) {
                if (!val) {
                    this._alertIconShape = '';
                }
                else if (val !== this._alertIconShape) {
                    this._alertIconShape = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconTitle", {
            get: function () {
                return this.iconInfoFromType(this._alertType).title;
            },
            enumerable: true,
            configurable: true
        });
        AlertIconAndTypesService.prototype.iconInfoFromType = function (type) {
            var returnObj = { shape: '', cssClass: '', title: '' };
            switch (type) {
                case 'warning':
                    returnObj.shape = 'exclamation-triangle';
                    returnObj.cssClass = 'alert-warning';
                    returnObj.title = this.commonStrings.keys.warning;
                    break;
                case 'danger':
                    returnObj.shape = 'exclamation-circle';
                    returnObj.cssClass = 'alert-danger';
                    returnObj.title = this.commonStrings.keys.danger;
                    break;
                case 'success':
                    returnObj.shape = 'check-circle';
                    returnObj.cssClass = 'alert-success';
                    returnObj.title = this.commonStrings.keys.success;
                    break;
                default:
                    returnObj.shape = this.defaultIconShape;
                    returnObj.cssClass = 'alert-info';
                    returnObj.title = this.commonStrings.keys.info;
                    break;
            }
            return returnObj;
        };
        AlertIconAndTypesService.ctorParameters = function () { return [
            { type: ClrCommonStringsService }
        ]; };
AlertIconAndTypesService.ɵfac = function AlertIconAndTypesService_Factory(t) { return new (t || AlertIconAndTypesService)(ɵngcc0.ɵɵinject(ClrCommonStringsService)); };
AlertIconAndTypesService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AlertIconAndTypesService, factory: function (t) { return AlertIconAndTypesService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AlertIconAndTypesService, [{
        type: core.Injectable
    }], function () { return [{ type: ClrCommonStringsService }]; }, null); })();
        return AlertIconAndTypesService;
    }());

    var MultiAlertService = /** @class */ (function () {
        function MultiAlertService() {
            /**
             * The Observable that lets other classes subscribe to changes
             */
            this._change = new rxjs.Subject();
        }
        Object.defineProperty(MultiAlertService.prototype, "changes", {
            get: function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "current", {
            get: function () {
                return this._current;
            },
            set: function (index) {
                if (index !== this._current) {
                    this._current = index;
                    this._change.next(index);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "activeAlerts", {
            get: function () {
                return this.allAlerts && this.allAlerts.filter(function (alert) { return !alert._closed; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "currentAlert", {
            get: function () {
                return this.activeAlerts && this.activeAlerts[this.current];
            },
            set: function (alert) {
                this.current = this.activeAlerts.indexOf(alert);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "count", {
            get: function () {
                return (this.activeAlerts && this.activeAlerts.length) || 0;
            },
            enumerable: true,
            configurable: true
        });
        MultiAlertService.prototype.manage = function (alerts) {
            var _this = this;
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
            this.allAlerts = alerts;
            // After receiving alerts' QueryList,
            // we are picking index 0 as current by default if a user hasn't any index
            this.current = typeof this._current === 'number' ? this._current : 0;
            // we have to also broadcast that initial index
            this._change.next(this.current);
            this.subscription = this.allAlerts.changes.subscribe(function () {
                if (_this.current >= _this.allAlerts.length) {
                    _this.current = Math.max(0, _this.allAlerts.length - 1);
                }
            });
        };
        MultiAlertService.prototype.next = function () {
            this.current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
        };
        MultiAlertService.prototype.previous = function () {
            if (this.activeAlerts.length === 0) {
                return;
            }
            this.current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
        };
        MultiAlertService.prototype.close = function () {
            this.previous();
        };
        MultiAlertService.prototype.destroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
MultiAlertService.ɵfac = function MultiAlertService_Factory(t) { return new (t || MultiAlertService)(); };
MultiAlertService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MultiAlertService, factory: function (t) { return MultiAlertService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MultiAlertService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return MultiAlertService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @remark
     * This directive is used only of selectin alert text.
     */
    var ClrAlertText = /** @class */ (function () {
        function ClrAlertText() {
        }
ClrAlertText.ɵfac = function ClrAlertText_Factory(t) { return new (t || ClrAlertText)(); };
ClrAlertText.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrAlertText, selectors: [["", 8, "alert-text"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAlertText, [{
        type: core.Directive,
        args: [{
                selector: '.alert-text'
            }]
    }], function () { return []; }, null); })();
        return ClrAlertText;
    }());

    var ClrAlert = /** @class */ (function () {
        function ClrAlert(iconService, cdr, multiAlertService, commonStrings, ariaLiveService) {
            this.iconService = iconService;
            this.cdr = cdr;
            this.multiAlertService = multiAlertService;
            this.commonStrings = commonStrings;
            this.ariaLiveService = ariaLiveService;
            this.subscriptions = [];
            this.isSmall = false;
            this.closable = true;
            this.isAppLevel = false;
            // Aria
            this.clrCloseButtonAriaLabel = this.commonStrings.keys.alertCloseButtonAriaLabel;
            this._closed = false;
            this._closedChanged = new core.EventEmitter(false);
            /**
             * clrPolite is not used in the code. Is here just to provide
             * code complition and also mark component what type AriaLive
             * will be used.
             */
            /** @deprecated since 3.0, remove in 4.0 */
            this.polite = true;
        }
        ClrAlert.prototype.ngOnInit = function () {
            var _this = this;
            if (this.multiAlertService) {
                this.subscriptions.push(this.multiAlertService.changes.subscribe(function () {
                    _this.hidden = _this.multiAlertService.currentAlert !== _this;
                }));
            }
        };
        ClrAlert.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrAlert.prototype.ngAfterViewInit = function () {
            // Announce the first time the alert is render if it is not hidden
            this.announceAriaLiveMessage();
        };
        Object.defineProperty(ClrAlert.prototype, "alertType", {
            get: function () {
                return this.iconService.alertType;
            },
            set: function (val) {
                this.iconService.alertType = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "ariaLive", {
            /**
             * There is an order on how the attributes will take effect.
             * Assertive, Off, Polite.
             *
             * Polite is default if non is passed.
             *
             * In the case of setting all of them to true. Assertive will be used.
             *
             */
            get: function () {
                if (isBooleanAttributeSet(this.assertive)) {
                    return exports.ClrAriaLivePoliteness.assertive;
                }
                if (isBooleanAttributeSet(this.off)) {
                    return exports.ClrAriaLivePoliteness.off;
                }
                return exports.ClrAriaLivePoliteness.polite;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "alertIconShape", {
            set: function (value) {
                this.iconService.alertIconShape = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "alertClass", {
            get: function () {
                return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This handle the find what content to be annonced withing the aria-live container
         * alerts that are hidden will be ignored.
         *
         * @remark
         * We depend on the ClrAlertText Directive to find and parse the alert messages.
         * Also this require the HTML markup for the alert to be
         * ```html
         * <div class="alert" role="alert">
         *    <div class="alert-items">
         *        <div class="alert-item static">
         *            <span class="alert-text">
         *                 ...
         *            </span>
         *        </div>
         *    </div>
         * </div>
         * ```
         */
        ClrAlert.prototype.announceAriaLiveMessage = function () {
            if (!this.hidden && this.alertTexts.length) {
                var message = this.alertTexts.map(function (alertText) { return alertText.nativeElement.textContent; }).join(' ');
                // Don't call announce when there is nothing to say
                if (message) {
                    this.ariaLiveService.announce(message, this.ariaLive);
                }
            }
        };
        Object.defineProperty(ClrAlert.prototype, "hidden", {
            get: function () {
                return this._hidden;
            },
            set: function (value) {
                if (value !== this._hidden) {
                    this._hidden = value;
                    this.cdr.detectChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrAlert.prototype.close = function () {
            if (!this.closable) {
                return;
            }
            this._closed = true;
            if (this.multiAlertService) {
                this.multiAlertService.close();
            }
            this._closedChanged.emit(true);
        };
        ClrAlert.prototype.open = function () {
            this._closed = false;
            this._closedChanged.emit(false);
        };
        ClrAlert.ctorParameters = function () { return [
            { type: AlertIconAndTypesService },
            { type: core.ChangeDetectorRef },
            { type: MultiAlertService, decorators: [{ type: core.Optional }] },
            { type: ClrCommonStringsService },
            { type: ClrAriaLiveService }
        ]; };
        __decorate([
            core.Input('clrAlertSizeSmall')
        ], ClrAlert.prototype, "isSmall", void 0);
        __decorate([
            core.Input('clrAlertClosable')
        ], ClrAlert.prototype, "closable", void 0);
        __decorate([
            core.Input('clrAlertAppLevel')
        ], ClrAlert.prototype, "isAppLevel", void 0);
        __decorate([
            core.Input()
        ], ClrAlert.prototype, "clrCloseButtonAriaLabel", void 0);
        __decorate([
            core.Input('clrAlertClosed')
        ], ClrAlert.prototype, "_closed", void 0);
        __decorate([
            core.Output('clrAlertClosedChange')
        ], ClrAlert.prototype, "_closedChanged", void 0);
        __decorate([
            core.Input('clrAlertType')
        ], ClrAlert.prototype, "alertType", null);
        __decorate([
            core.Input('clrPolite')
        ], ClrAlert.prototype, "polite", void 0);
        __decorate([
            core.Input('clrAssertive')
        ], ClrAlert.prototype, "assertive", void 0);
        __decorate([
            core.Input('clrOff')
        ], ClrAlert.prototype, "off", void 0);
        __decorate([
            core.Input('clrAlertIcon')
        ], ClrAlert.prototype, "alertIconShape", null);
        __decorate([
            core.ContentChildren(ClrAlertText, { descendants: true, read: core.ElementRef })
        ], ClrAlert.prototype, "alertTexts", void 0);
        ClrAlert = __decorate([ __param(2, core.Optional())
        ], ClrAlert);
ClrAlert.ɵfac = function ClrAlert_Factory(t) { return new (t || ClrAlert)(ɵngcc0.ɵɵdirectiveInject(AlertIconAndTypesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MultiAlertService, 8), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService)); };
ClrAlert.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAlert, selectors: [["clr-alert"]], contentQueries: function ClrAlert_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrAlertText, true, core.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.alertTexts = _t);
    } }, inputs: { isSmall: ["clrAlertSizeSmall", "isSmall"], closable: ["clrAlertClosable", "closable"], isAppLevel: ["clrAlertAppLevel", "isAppLevel"], clrCloseButtonAriaLabel: "clrCloseButtonAriaLabel", _closed: ["clrAlertClosed", "_closed"], polite: ["clrPolite", "polite"], alertType: ["clrAlertType", "alertType"], alertIconShape: ["clrAlertIcon", "alertIconShape"], assertive: ["clrAssertive", "assertive"], off: ["clrOff", "off"] }, outputs: { _closedChanged: "clrAlertClosedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([AlertIconAndTypesService, ClrAriaLiveService])], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [["class", "alert", 3, "ngClass", "alert-hidden", "alert-sm", "alert-app-level", 4, "ngIf"], [1, "alert", 3, "ngClass"], [1, "alert-items"], ["type", "button", "class", "close", 3, "click", 4, "ngIf"], ["type", "button", 1, "close", 3, "click"], ["shape", "close"]], template: function ClrAlert_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrAlert_div_0_Template, 4, 8, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx._closed);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrIconCustomTag], styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAlert, [{
        type: core.Component,
        args: [{
                selector: 'clr-alert',
                providers: [AlertIconAndTypesService, ClrAriaLiveService],
                template: "<!--\n  ~ Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n    *ngIf=\"!_closed\"\n    class=\"alert\"\n    [ngClass]=\"alertClass\"\n    [class.alert-hidden]=\"hidden\"\n    [class.alert-sm]=\"isSmall\"\n    [class.alert-app-level]=\"isAppLevel\">\n    <div class=\"alert-items\">\n        <ng-content></ng-content>\n    </div>\n    <button\n        type=\"button\"\n        class=\"close\"\n        *ngIf=\"closable\"\n        (click)=\"close()\"\n        [attr.aria-label]=\"clrCloseButtonAriaLabel\"\n        >\n        <clr-icon shape=\"close\"></clr-icon>\n    </button>\n</div>\n",
                styles: [':host { display: block; }']
            }]
    }], function () { return [{ type: AlertIconAndTypesService }, { type: ɵngcc0.ChangeDetectorRef }, { type: MultiAlertService, decorators: [{
                type: core.Optional
            }] }, { type: ClrCommonStringsService }, { type: ClrAriaLiveService }]; }, { isSmall: [{
            type: core.Input,
            args: ['clrAlertSizeSmall']
        }], closable: [{
            type: core.Input,
            args: ['clrAlertClosable']
        }], isAppLevel: [{
            type: core.Input,
            args: ['clrAlertAppLevel']
        }], clrCloseButtonAriaLabel: [{
            type: core.Input
        }], _closed: [{
            type: core.Input,
            args: ['clrAlertClosed']
        }], _closedChanged: [{
            type: core.Output,
            args: ['clrAlertClosedChange']
        }], polite: [{
            type: core.Input,
            args: ['clrPolite']
        }], alertType: [{
            type: core.Input,
            args: ['clrAlertType']
        }], alertIconShape: [{
            type: core.Input,
            args: ['clrAlertIcon']
        }], assertive: [{
            type: core.Input,
            args: ['clrAssertive']
        }], off: [{
            type: core.Input,
            args: ['clrOff']
        }], alertTexts: [{
            type: core.ContentChildren,
            args: [ClrAlertText, { descendants: true, read: core.ElementRef }]
        }] }); })();
        return ClrAlert;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAlertItem = /** @class */ (function () {
        function ClrAlertItem(iconService) {
            this.iconService = iconService;
        }
        ClrAlertItem.ctorParameters = function () { return [
            { type: AlertIconAndTypesService }
        ]; };
ClrAlertItem.ɵfac = function ClrAlertItem_Factory(t) { return new (t || ClrAlertItem)(ɵngcc0.ɵɵdirectiveInject(AlertIconAndTypesService)); };
ClrAlertItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAlertItem, selectors: [["clr-alert-item"]], hostAttrs: [1, "alert-item"], ngContentSelectors: _c1, decls: 3, vars: 2, consts: [[1, "alert-icon-wrapper"], [1, "alert-icon"]], template: function ClrAlertItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "clr-icon", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("shape", ctx.iconService.alertIconShape)("title", ctx.iconService.alertIconTitle);
    } }, directives: [ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAlertItem, [{
        type: core.Component,
        args: [{
                selector: 'clr-alert-item',
                template: "\n        <div class=\"alert-icon-wrapper\">\n            <clr-icon class=\"alert-icon\" \n              [attr.shape]=\"iconService.alertIconShape\" \n              [attr.title]=\"iconService.alertIconTitle\"></clr-icon>\n        </div>\n        <ng-content></ng-content>\n    ",
                host: { class: 'alert-item' }
            }]
    }], function () { return [{ type: AlertIconAndTypesService }]; }, null); })();
        return ClrAlertItem;
    }());

    var ClrAlerts = /** @class */ (function () {
        function ClrAlerts(multiAlertService) {
            this.multiAlertService = multiAlertService;
            this.subscriptions = [];
            this.currentAlertIndexChange = new core.EventEmitter(false);
            this.currentAlertChange = new core.EventEmitter(false);
        }
        Object.defineProperty(ClrAlerts.prototype, "allAlerts", {
            set: function (value) {
                this.multiAlertService.manage(value); // provide alerts
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "_inputCurrentIndex", {
            /**
             * Input/Output to support two way binding on current alert index
             */
            set: function (index) {
                if (Number.isInteger(index) && index >= 0) {
                    this.multiAlertService.current = index;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlertIndex", {
            get: function () {
                return this.multiAlertService.current;
            },
            set: function (index) {
                this.multiAlertService.current = index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlert", {
            get: function () {
                return this.multiAlertService.currentAlert;
            },
            /**
             * Input/Output to support two way binding on current alert instance
             */
            set: function (alert) {
                if (alert) {
                    this.multiAlertService.currentAlert = alert;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "alerts", {
            /**
             * Ensure we are only dealing with alerts that have not been closed yet
             */
            get: function () {
                return this.allAlerts.filter(function (alert) {
                    return alert.hidden === false;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlertType", {
            get: function () {
                if (this.multiAlertService.currentAlert) {
                    return this.multiAlertService.currentAlert.alertType;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        ClrAlerts.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.subscriptions.push(this.multiAlertService.changes.subscribe(function (index) {
                _this.currentAlertIndexChange.next(index);
                _this.currentAlertChange.next(_this.multiAlertService.currentAlert);
            }));
        };
        ClrAlerts.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            this.multiAlertService.destroy();
        };
        ClrAlerts.ctorParameters = function () { return [
            { type: MultiAlertService }
        ]; };
        __decorate([
            core.ContentChildren(ClrAlert)
        ], ClrAlerts.prototype, "allAlerts", null);
        __decorate([
            core.Input('clrCurrentAlertIndex')
        ], ClrAlerts.prototype, "_inputCurrentIndex", null);
        __decorate([
            core.Output('clrCurrentAlertIndexChange')
        ], ClrAlerts.prototype, "currentAlertIndexChange", void 0);
        __decorate([
            core.Input('clrCurrentAlert')
        ], ClrAlerts.prototype, "currentAlert", null);
        __decorate([
            core.Output('clrCurrentAlertChange')
        ], ClrAlerts.prototype, "currentAlertChange", void 0);
ClrAlerts.ɵfac = function ClrAlerts_Factory(t) { return new (t || ClrAlerts)(ɵngcc0.ɵɵdirectiveInject(MultiAlertService)); };
ClrAlerts.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAlerts, selectors: [["clr-alerts"]], contentQueries: function ClrAlerts_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrAlert, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.allAlerts = _t);
    } }, hostVars: 10, hostBindings: function ClrAlerts_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("alerts", true)("alert-danger", ctx.currentAlertType == "danger")("alert-info", ctx.currentAlertType == "info")("alert-success", ctx.currentAlertType == "success")("alert-warning", ctx.currentAlertType == "warning");
    } }, inputs: { _inputCurrentIndex: ["clrCurrentAlertIndex", "_inputCurrentIndex"], currentAlert: ["clrCurrentAlert", "currentAlert"] }, outputs: { currentAlertIndexChange: "clrCurrentAlertIndexChange", currentAlertChange: "clrCurrentAlertChange" }, features: [ɵngcc0.ɵɵProvidersFeature([MultiAlertService])], ngContentSelectors: _c72, decls: 2, vars: 1, consts: [[3, "clrCurrentAlertIndex", 4, "ngIf"], [3, "clrCurrentAlertIndex"]], template: function ClrAlerts_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c71);
        ɵngcc0.ɵɵtemplate(0, ClrAlerts_clr_alerts_pager_0_Template, 1, 1, "clr-alerts-pager", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.multiAlertService.count > 1);
    } }, directives: function () { return [ɵngcc1.NgIf, ClrAlertsPager]; }, styles: ["[_nghost-%COMP%] { display: block }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAlerts, [{
        type: core.Component,
        args: [{
                selector: 'clr-alerts',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-alerts-pager\n        *ngIf=\"multiAlertService.count > 1\"\n        [clrCurrentAlertIndex]=\"currentAlertIndex\">\n</clr-alerts-pager>\n<ng-content select=\"clr-alert\"></ng-content>\n",
                providers: [MultiAlertService],
                host: {
                    '[class.alerts]': 'true',
                    '[class.alert-danger]': "this.currentAlertType == 'danger'",
                    '[class.alert-info]': "this.currentAlertType == 'info'",
                    '[class.alert-success]': "this.currentAlertType == 'success'",
                    '[class.alert-warning]': "this.currentAlertType == 'warning'"
                },
                styles: [':host { display: block }']
            }]
    }], function () { return [{ type: MultiAlertService }]; }, { currentAlertIndexChange: [{
            type: core.Output,
            args: ['clrCurrentAlertIndexChange']
        }], currentAlertChange: [{
            type: core.Output,
            args: ['clrCurrentAlertChange']
        }], allAlerts: [{
            type: core.ContentChildren,
            args: [ClrAlert]
        }], _inputCurrentIndex: [{
            type: core.Input,
            args: ['clrCurrentAlertIndex']
        }], currentAlert: [{
            type: core.Input,
            args: ['clrCurrentAlert']
        }] }); })();
        return ClrAlerts;
    }());

    var ClrAlertsPager = /** @class */ (function () {
        function ClrAlertsPager(multiAlertService, commonStrings) {
            this.multiAlertService = multiAlertService;
            this.commonStrings = commonStrings;
            this.currentAlertChange = new core.EventEmitter(false);
            this.currentAlertIndexChange = new core.EventEmitter();
        }
        Object.defineProperty(ClrAlertsPager.prototype, "currentAlert", {
            get: function () {
                return this.multiAlertService.currentAlert;
            },
            /**
             * Input/Output to support two way binding on current alert instance
             */
            set: function (alert) {
                if (alert) {
                    this.multiAlertService.currentAlert = alert;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlertsPager.prototype, "currentAlertIndex", {
            get: function () {
                return this.multiAlertService.current;
            },
            /**
             * Input/Output to support two way binding on current alert index
             */
            set: function (index) {
                this.multiAlertService.current = index;
            },
            enumerable: true,
            configurable: true
        });
        ClrAlertsPager.prototype.ngOnInit = function () {
            var _this = this;
            this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe(function (index) {
                _this.currentAlertIndexChange.emit(index);
                _this.currentAlertChange.emit(_this.multiAlertService.activeAlerts[index]);
            });
        };
        ClrAlertsPager.prototype.pageUp = function () {
            this.multiAlertService.next();
        };
        ClrAlertsPager.prototype.pageDown = function () {
            this.multiAlertService.previous();
        };
        ClrAlertsPager.prototype.ngOnDestroy = function () {
            this.multiAlertServiceChanges.unsubscribe();
        };
        ClrAlertsPager.ctorParameters = function () { return [
            { type: MultiAlertService },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.Input('clrCurrentAlert')
        ], ClrAlertsPager.prototype, "currentAlert", null);
        __decorate([
            core.Output('clrCurrentAlertChange')
        ], ClrAlertsPager.prototype, "currentAlertChange", void 0);
        __decorate([
            core.Input('clrCurrentAlertIndex')
        ], ClrAlertsPager.prototype, "currentAlertIndex", null);
        __decorate([
            core.Output('clrCurrentAlertIndexChange')
        ], ClrAlertsPager.prototype, "currentAlertIndexChange", void 0);
ClrAlertsPager.ɵfac = function ClrAlertsPager_Factory(t) { return new (t || ClrAlertsPager)(ɵngcc0.ɵɵdirectiveInject(MultiAlertService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrAlertsPager.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAlertsPager, selectors: [["clr-alerts-pager"]], hostVars: 2, hostBindings: function ClrAlertsPager_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("alerts-pager", true);
    } }, inputs: { currentAlert: ["clrCurrentAlert", "currentAlert"], currentAlertIndex: ["clrCurrentAlertIndex", "currentAlertIndex"] }, outputs: { currentAlertChange: "clrCurrentAlertChange", currentAlertIndexChange: "clrCurrentAlertIndexChange" }, decls: 9, vars: 4, consts: [[1, "alerts-pager-control"], [1, "alerts-page-down"], [1, "alerts-pager-button", 3, "click"], ["shape", "caret left"], [1, "alerts-pager-text"], [1, "alerts-page-up"], ["shape", "caret right"]], template: function ClrAlertsPager_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "button", 2);
        ɵngcc0.ɵɵlistener("click", function ClrAlertsPager_Template_button_click_2_listener() { return ctx.pageDown(); });
        ɵngcc0.ɵɵelement(3, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵelementStart(7, "button", 2);
        ɵngcc0.ɵɵlistener("click", function ClrAlertsPager_Template_button_click_7_listener() { return ctx.pageUp(); });
        ɵngcc0.ɵɵelement(8, "clr-icon", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.previous);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.multiAlertService.current + 1, " / ", ctx.multiAlertService.count, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.next);
    } }, directives: [ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAlertsPager, [{
        type: core.Component,
        args: [{
                selector: 'clr-alerts-pager',
                template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"alerts-pager-control\">\n    <div class=\"alerts-page-down\">\n        <button class=\"alerts-pager-button\" (click)=\"pageDown()\">\n            <clr-icon shape=\"caret left\" [attr.title]=\"commonStrings.keys.previous\"></clr-icon>\n        </button>\n    </div>\n    <div class=\"alerts-pager-text\">\n        {{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}\n    </div>\n    <div class=\"alerts-page-up\">\n        <button class=\"alerts-pager-button\" (click)=\"pageUp()\">\n            <clr-icon shape=\"caret right\" [attr.title]=\"commonStrings.keys.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n",
                host: { '[class.alerts-pager]': 'true' }
            }]
    }], function () { return [{ type: MultiAlertService }, { type: ClrCommonStringsService }]; }, { currentAlertChange: [{
            type: core.Output,
            args: ['clrCurrentAlertChange']
        }], currentAlertIndexChange: [{
            type: core.Output,
            args: ['clrCurrentAlertIndexChange']
        }], currentAlert: [{
            type: core.Input,
            args: ['clrCurrentAlert']
        }], currentAlertIndex: [{
            type: core.Input,
            args: ['clrCurrentAlertIndex']
        }] }); })();
        return ClrAlertsPager;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText];
    var ClrAlertModule = /** @class */ (function () {
        function ClrAlertModule() {
        }
ClrAlertModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrAlertModule });
ClrAlertModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrAlertModule_Factory(t) { return new (t || ClrAlertModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrDropdownModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrAlertModule, { declarations: [ClrAlert,
        ClrAlertItem,
        ClrAlerts,
        ClrAlertsPager,
        ClrAlertText], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrDropdownModule], exports: [ClrAlert,
        ClrAlertItem,
        ClrAlerts,
        ClrAlertsPager,
        ClrAlertText] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAlertModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrDropdownModule],
                declarations: [CLR_ALERT_DIRECTIVES],
                exports: [CLR_ALERT_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrAlertModule;
    }());

    var ClrEmphasisModule = /** @class */ (function () {
        function ClrEmphasisModule() {
        }
ClrEmphasisModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrEmphasisModule });
ClrEmphasisModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrEmphasisModule_Factory(t) { return new (t || ClrEmphasisModule)(); }, imports: [ClrAlertModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrEmphasisModule, { exports: [ClrAlertModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrEmphasisModule, [{
        type: core.NgModule,
        args: [{ exports: [ClrAlertModule] }]
    }], function () { return []; }, null); })();
        return ClrEmphasisModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ResponsiveNavCodes = /** @class */ (function () {
        function ResponsiveNavCodes() {
        }
        ResponsiveNavCodes.NAV_LEVEL_1 = 1;
        ResponsiveNavCodes.NAV_LEVEL_2 = 2;
        ResponsiveNavCodes.NAV_CLOSE_ALL = 'NAV_CLOSE_ALL';
        ResponsiveNavCodes.NAV_OPEN = 'NAV_OPEN';
        ResponsiveNavCodes.NAV_CLOSE = 'NAV_CLOSE';
        ResponsiveNavCodes.NAV_TOGGLE = 'NAV_TOGGLE';
        ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = 'open-hamburger-menu';
        ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = 'open-overflow-menu';
        ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = 'header-hamburger-trigger';
        ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = 'header-overflow-trigger';
        ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = 'clr-nav-level-1';
        ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = 'clr-nav-level-2';
        return ResponsiveNavCodes;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ResponsiveNavControlMessage = /** @class */ (function () {
        function ResponsiveNavControlMessage(_controlCode, _navLevel) {
            this._controlCode = _controlCode;
            this._navLevel = _navLevel;
        }
        Object.defineProperty(ResponsiveNavControlMessage.prototype, "controlCode", {
            get: function () {
                return this._controlCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResponsiveNavControlMessage.prototype, "navLevel", {
            get: function () {
                return this._navLevel;
            },
            enumerable: true,
            configurable: true
        });
        return ResponsiveNavControlMessage;
    }());

    var ResponsiveNavigationService = /** @class */ (function () {
        function ResponsiveNavigationService() {
            this.responsiveNavList = [];
            this.registerNavSubject = new rxjs.ReplaySubject();
            this.controlNavSubject = new rxjs.Subject();
            this.closeAllNavs(); // We start with all navs closed
        }
        Object.defineProperty(ResponsiveNavigationService.prototype, "registeredNavs", {
            get: function () {
                return this.registerNavSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResponsiveNavigationService.prototype, "navControl", {
            get: function () {
                return this.controlNavSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        ResponsiveNavigationService.prototype.registerNav = function (navLevel) {
            if (!navLevel || this.isNavRegistered(navLevel)) {
                return;
            }
            this.responsiveNavList.push(navLevel);
            this.registerNavSubject.next(this.responsiveNavList);
        };
        ResponsiveNavigationService.prototype.isNavRegistered = function (navLevel) {
            if (this.responsiveNavList.indexOf(navLevel) > -1) {
                console.error('Multiple clr-nav-level ' + navLevel + ' attributes found. Please make sure that only one exists');
                return true;
            }
            return false;
        };
        ResponsiveNavigationService.prototype.unregisterNav = function (navLevel) {
            var index = this.responsiveNavList.indexOf(navLevel);
            if (index > -1) {
                this.responsiveNavList.splice(index, 1);
                this.registerNavSubject.next(this.responsiveNavList);
            }
        };
        ResponsiveNavigationService.prototype.sendControlMessage = function (controlCode, navLevel) {
            var message = new ResponsiveNavControlMessage(controlCode, navLevel);
            this.controlNavSubject.next(message);
        };
        ResponsiveNavigationService.prototype.closeAllNavs = function () {
            var message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
            this.controlNavSubject.next(message);
        };
        ResponsiveNavigationService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function ResponsiveNavigationService_Factory() { return new ResponsiveNavigationService(); }, token: ResponsiveNavigationService, providedIn: "root" });
ResponsiveNavigationService.ɵfac = function ResponsiveNavigationService_Factory(t) { return new (t || ResponsiveNavigationService)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResponsiveNavigationService, [{
        type: core.Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
        return ResponsiveNavigationService;
    }());

    var ClrMainContainer = /** @class */ (function () {
        function ClrMainContainer(elRef, responsiveNavService) {
            this.elRef = elRef;
            this.responsiveNavService = responsiveNavService;
        }
        ClrMainContainer.prototype.ngOnInit = function () {
            var _this = this;
            this._classList = this.elRef.nativeElement.classList;
            this._subscription = this.responsiveNavService.navControl.subscribe({
                next: function (message) {
                    _this.processMessage(message);
                },
            });
        };
        ClrMainContainer.prototype.processMessage = function (message) {
            var navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
            if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
                this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
                this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
            }
            else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                this.controlNav(message.controlCode, navClass);
            }
            else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
                this.controlNav(message.controlCode, navClass);
            }
        };
        ClrMainContainer.prototype.controlNav = function (controlCode, navClass) {
            if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
                this._classList.add(navClass);
            }
            else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
                this._classList.remove(navClass);
            }
            else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
                this._classList.toggle(navClass);
            }
        };
        ClrMainContainer.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        ClrMainContainer.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: ResponsiveNavigationService }
        ]; };
ClrMainContainer.ɵfac = function ClrMainContainer_Factory(t) { return new (t || ClrMainContainer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ResponsiveNavigationService)); };
ClrMainContainer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrMainContainer, selectors: [["clr-main-container"]], hostVars: 2, hostBindings: function ClrMainContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("main-container", true);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrMainContainer, [{
        type: core.Directive,
        args: [{ selector: 'clr-main-container', host: { '[class.main-container]': 'true' } }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ResponsiveNavigationService }]; }, null); })();
        return ClrMainContainer;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
    var ClrMainContainerModule = /** @class */ (function () {
        function ClrMainContainerModule() {
        }
ClrMainContainerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrMainContainerModule });
ClrMainContainerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrMainContainerModule_Factory(t) { return new (t || ClrMainContainerModule)(); }, imports: [[common.CommonModule, ClrIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrMainContainerModule, { declarations: [ClrMainContainer], imports: [ɵngcc1.CommonModule, ClrIconModule], exports: [ClrMainContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrMainContainerModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule],
                declarations: [CLR_LAYOUT_DIRECTIVES],
                exports: [CLR_LAYOUT_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrMainContainerModule;
    }());

    var MainContainerWillyWonka = /** @class */ (function (_super) {
        __extends(MainContainerWillyWonka, _super);
        function MainContainerWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
MainContainerWillyWonka.ɵfac = function MainContainerWillyWonka_Factory(t) { return ɵMainContainerWillyWonka_BaseFactory(t || MainContainerWillyWonka); };
MainContainerWillyWonka.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MainContainerWillyWonka, selectors: [["clr-main-container"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
var ɵMainContainerWillyWonka_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MainContainerWillyWonka);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MainContainerWillyWonka, [{
        type: core.Directive,
        args: [{ selector: 'clr-main-container' }]
    }], null, null); })();
        return MainContainerWillyWonka;
    }(WillyWonka));

    var NavDetectionOompaLoompa = /** @class */ (function (_super) {
        __extends(NavDetectionOompaLoompa, _super);
        function NavDetectionOompaLoompa(cdr, willyWonka, responsiveNavService) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-header should only be used inside of a clr-main-container');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.responsiveNavService = responsiveNavService;
            return _this;
        }
        Object.defineProperty(NavDetectionOompaLoompa.prototype, "flavor", {
            // NavDetectionOompaLoompa is the addition of the nav levels
            // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
            get: function () {
                return this.responsiveNavService.responsiveNavList.reduce(function (sum, navLevel) { return sum + navLevel; }, 0);
            },
            enumerable: true,
            configurable: true
        });
        NavDetectionOompaLoompa.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: MainContainerWillyWonka, decorators: [{ type: core.Optional }] },
            { type: ResponsiveNavigationService }
        ]; };
        NavDetectionOompaLoompa = __decorate([ __param(1, core.Optional())
        ], NavDetectionOompaLoompa);
NavDetectionOompaLoompa.ɵfac = function NavDetectionOompaLoompa_Factory(t) { return new (t || NavDetectionOompaLoompa)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MainContainerWillyWonka, 8), ɵngcc0.ɵɵdirectiveInject(ResponsiveNavigationService)); };
NavDetectionOompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NavDetectionOompaLoompa, selectors: [["clr-header"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavDetectionOompaLoompa, [{
        type: core.Directive,
        args: [{ selector: 'clr-header' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: MainContainerWillyWonka, decorators: [{
                type: core.Optional
            }] }, { type: ResponsiveNavigationService }]; }, null); })();
        return NavDetectionOompaLoompa;
    }(OompaLoompa));

    var ClrHeader = /** @class */ (function () {
        function ClrHeader(responsiveNavService, commonStrings) {
            var _this = this;
            this.responsiveNavService = responsiveNavService;
            this.commonStrings = commonStrings;
            this.isNavLevel1OnPage = false;
            this.isNavLevel2OnPage = false;
            this.openNavLevel = null;
            this.responsiveNavCodes = ResponsiveNavCodes;
            this._subscription = this.responsiveNavService.registeredNavs.subscribe({
                next: function (navLevelList) {
                    _this.initializeNavTriggers(navLevelList);
                },
            });
        }
        // reset triggers. handles cases when an application has different nav levels on different pages.
        ClrHeader.prototype.resetNavTriggers = function () {
            this.isNavLevel1OnPage = false;
            this.isNavLevel2OnPage = false;
        };
        // decides which triggers to show on the header
        ClrHeader.prototype.initializeNavTriggers = function (navList) {
            var _this = this;
            this.resetNavTriggers();
            if (navList.length > 2) {
                console.error('More than 2 Nav Levels detected.');
                return;
            }
            navList.forEach(function (navLevel) {
                if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                    _this.isNavLevel1OnPage = true;
                }
                else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                    _this.isNavLevel2OnPage = true;
                }
            });
        };
        // closes the nav that is open
        ClrHeader.prototype.closeOpenNav = function () {
            this.responsiveNavService.closeAllNavs();
        };
        // toggles the nav that is open
        ClrHeader.prototype.toggleNav = function (navLevel) {
            this.openNavLevel = this.openNavLevel === navLevel ? null : navLevel;
            this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_TOGGLE, navLevel);
        };
        ClrHeader.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        ClrHeader.ctorParameters = function () { return [
            { type: ResponsiveNavigationService },
            { type: ClrCommonStringsService }
        ]; };
ClrHeader.ɵfac = function ClrHeader_Factory(t) { return new (t || ClrHeader)(ɵngcc0.ɵɵdirectiveInject(ResponsiveNavigationService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrHeader, selectors: [["clr-header"]], hostVars: 2, hostBindings: function ClrHeader_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("header", true);
    } }, ngContentSelectors: _c1, decls: 4, vars: 2, consts: [["type", "button", "class", "header-hamburger-trigger", 3, "click", 4, "ngIf"], ["type", "button", "class", "header-overflow-trigger", 3, "click", 4, "ngIf"], [1, "header-backdrop", 3, "click"], ["type", "button", 1, "header-hamburger-trigger", 3, "click"], ["type", "button", 1, "header-overflow-trigger", 3, "click"]], template: function ClrHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrHeader_button_0_Template, 2, 1, "button", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, ClrHeader_button_2_Template, 2, 1, "button", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵlistener("click", function ClrHeader_Template_div_click_3_listener() { return ctx.closeOpenNav(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isNavLevel1OnPage);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isNavLevel2OnPage);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrHeader, [{
        type: core.Component,
        args: [{
                selector: 'clr-header',
                template: "\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel1OnPage\"\n            class=\"header-hamburger-trigger\"\n            [attr.aria-label]=\"(openNavLevel !== responsiveNavCodes.NAV_LEVEL_1) ? commonStrings.keys.open : commonStrings.keys.close\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_1)\">\n            <span></span>\n        </button>\n        <ng-content></ng-content>\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel2OnPage\"\n            class=\"header-overflow-trigger\"\n            [attr.aria-label]=\"(openNavLevel !== responsiveNavCodes.NAV_LEVEL_2) ? commonStrings.keys.open : commonStrings.keys.close\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_2)\">\n            <span></span>\n        </button>\n        <div class=\"header-backdrop\" (click)=\"closeOpenNav()\"></div>\n    ",
                host: { '[class.header]': 'true' }
            }]
    }], function () { return [{ type: ResponsiveNavigationService }, { type: ClrCommonStringsService }]; }, null); })();
        return ClrHeader;
    }());

    var ClrNavLevel = /** @class */ (function () {
        function ClrNavLevel(responsiveNavService, elementRef) {
            this.responsiveNavService = responsiveNavService;
            this.elementRef = elementRef;
        }
        ClrNavLevel.prototype.ngOnInit = function () {
            if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
                console.error('Nav Level can only be 1 or 2');
                return;
            }
            this.responsiveNavService.registerNav(this.level);
            this.addNavClass(this.level);
        };
        ClrNavLevel.prototype.addNavClass = function (level) {
            var navHostClassList = this.elementRef.nativeElement.classList;
            if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
                navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
            }
            else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
                navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
            }
        };
        Object.defineProperty(ClrNavLevel.prototype, "level", {
            get: function () {
                return this._level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrNavLevel.prototype, "responsiveNavCodes", {
            // getter to access the responsive navigation codes from the template
            get: function () {
                return ResponsiveNavCodes;
            },
            enumerable: true,
            configurable: true
        });
        ClrNavLevel.prototype.open = function () {
            this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
        };
        ClrNavLevel.prototype.close = function () {
            this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
        };
        // TODO: Figure out whats the best way to do this. Possible methods
        // 1. HostListener (current solution)
        // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
        // why
        ClrNavLevel.prototype.onMouseClick = function (target) {
            var current = target; // Get the element in the DOM on which the mouse was clicked
            var navHost = this.elementRef.nativeElement; // Get the current nav native HTML element
            // Start checking if current and navHost are equal.
            // If not traverse to the parentNode and check again.
            while (current) {
                if (current === navHost) {
                    return;
                }
                else if (current.classList.contains('nav-link')) {
                    this.close();
                    return;
                }
                current = current.parentNode;
            }
        };
        ClrNavLevel.prototype.ngOnDestroy = function () {
            this.responsiveNavService.unregisterNav(this.level);
        };
        ClrNavLevel.ctorParameters = function () { return [
            { type: ResponsiveNavigationService },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('clr-nav-level')
        ], ClrNavLevel.prototype, "_level", void 0);
        __decorate([
            core.HostListener('click', ['$event.target'])
        ], ClrNavLevel.prototype, "onMouseClick", null);
ClrNavLevel.ɵfac = function ClrNavLevel_Factory(t) { return new (t || ClrNavLevel)(ɵngcc0.ɵɵdirectiveInject(ResponsiveNavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrNavLevel.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrNavLevel, selectors: [["", "clr-nav-level", ""]], hostBindings: function ClrNavLevel_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrNavLevel_click_HostBindingHandler($event) { return ctx.onMouseClick($event.target); });
    } }, inputs: { _level: ["clr-nav-level", "_level"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrNavLevel, [{
        type: core.Directive,
        args: [{ selector: '[clr-nav-level]' }]
    }], function () { return [{ type: ResponsiveNavigationService }, { type: ɵngcc0.ElementRef }]; }, { onMouseClick: [{
            type: core.HostListener,
            args: ['click', ['$event.target']]
        }], _level: [{
            type: core.Input,
            args: ['clr-nav-level']
        }] }); })();
        return ClrNavLevel;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_NAVIGATION_DIRECTIVES = [
        ClrHeader,
        ClrNavLevel,
        NavDetectionOompaLoompa,
        MainContainerWillyWonka,
    ];
    var ClrNavigationModule = /** @class */ (function () {
        function ClrNavigationModule() {
        }
ClrNavigationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrNavigationModule });
ClrNavigationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrNavigationModule_Factory(t) { return new (t || ClrNavigationModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrDropdownModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrNavigationModule, { declarations: [ClrHeader,
        ClrNavLevel,
        NavDetectionOompaLoompa,
        MainContainerWillyWonka], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrDropdownModule], exports: [ClrHeader,
        ClrNavLevel,
        NavDetectionOompaLoompa,
        MainContainerWillyWonka] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrNavigationModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrDropdownModule],
                declarations: [CLR_NAVIGATION_DIRECTIVES],
                exports: [CLR_NAVIGATION_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrNavigationModule;
    }());

    var TemplateRefContainer = /** @class */ (function () {
        function TemplateRefContainer() {
        }
        __decorate([
            core.ViewChild(core.TemplateRef)
        ], TemplateRefContainer.prototype, "template", void 0);
TemplateRefContainer.ɵfac = function TemplateRefContainer_Factory(t) { return new (t || TemplateRefContainer)(); };
TemplateRefContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TemplateRefContainer, selectors: [["ng-component"]], viewQuery: function TemplateRefContainer_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(core.TemplateRef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function TemplateRefContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TemplateRefContainer_ng_template_0_Template, 1, 0, "ng-template");
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateRefContainer, [{
        type: core.Component,
        args: [{
                template: "\n      <ng-template>\n        <ng-content></ng-content>\n      </ng-template>\n    "
            }]
    }], function () { return []; }, { template: [{
            type: core.ViewChild,
            args: [core.TemplateRef]
        }] }); })();
        return TemplateRefContainer;
    }());

    var TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];

    var ClrTemplateRefModule = /** @class */ (function () {
        function ClrTemplateRefModule() {
        }
ClrTemplateRefModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrTemplateRefModule });
ClrTemplateRefModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrTemplateRefModule_Factory(t) { return new (t || ClrTemplateRefModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrTemplateRefModule, { declarations: [TemplateRefContainer], imports: [ɵngcc1.CommonModule], exports: [TemplateRefContainer] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTemplateRefModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [TEMPLATE_REF_DIRECTIVES],
                entryComponents: [TEMPLATE_REF_DIRECTIVES],
                exports: [TEMPLATE_REF_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrTemplateRefModule;
    }());

    var TabsWillyWonka = /** @class */ (function (_super) {
        __extends(TabsWillyWonka, _super);
        function TabsWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
TabsWillyWonka.ɵfac = function TabsWillyWonka_Factory(t) { return ɵTabsWillyWonka_BaseFactory(t || TabsWillyWonka); };
TabsWillyWonka.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabsWillyWonka, selectors: [["clr-tabs"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
var ɵTabsWillyWonka_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TabsWillyWonka);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabsWillyWonka, [{
        type: core.Directive,
        args: [{ selector: 'clr-tabs' }]
    }], null, null); })();
        return TabsWillyWonka;
    }(WillyWonka));

    var ActiveOompaLoompa = /** @class */ (function (_super) {
        __extends(ActiveOompaLoompa, _super);
        function ActiveOompaLoompa(cdr, willyWonka, id, ifActive) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clrTabLink and clr-tab-content should only be used inside of a clr-tabs');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.ifActive = ifActive;
            _this.id = id;
            return _this;
        }
        Object.defineProperty(ActiveOompaLoompa.prototype, "flavor", {
            get: function () {
                return this.ifActive.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ActiveOompaLoompa.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: TabsWillyWonka, decorators: [{ type: core.Optional }] },
            { type: Number, decorators: [{ type: core.Inject, args: [IF_ACTIVE_ID,] }] },
            { type: IfActiveService }
        ]; };
        ActiveOompaLoompa = __decorate([ __param(1, core.Optional()),
            __param(2, core.Inject(IF_ACTIVE_ID))
        ], ActiveOompaLoompa);
ActiveOompaLoompa.ɵfac = function ActiveOompaLoompa_Factory(t) { return new (t || ActiveOompaLoompa)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(TabsWillyWonka, 8), ɵngcc0.ɵɵdirectiveInject(IF_ACTIVE_ID), ɵngcc0.ɵɵdirectiveInject(IfActiveService)); };
ActiveOompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ActiveOompaLoompa, selectors: [["", "clrTabLink", ""], ["clr-tab-content"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActiveOompaLoompa, [{
        type: core.Directive,
        args: [{ selector: '[clrTabLink], clr-tab-content' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: TabsWillyWonka, decorators: [{
                type: core.Optional
            }] }, { type: Number, decorators: [{
                type: core.Inject,
                args: [IF_ACTIVE_ID]
            }] }, { type: IfActiveService }]; }, null); })();
        return ActiveOompaLoompa;
    }(OompaLoompa));

    // TODO: if we find more components that could use this, consider moving this to utils
    var AriaService = /** @class */ (function () {
        function AriaService() {
        }
AriaService.ɵfac = function AriaService_Factory(t) { return new (t || AriaService)(); };
AriaService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AriaService, factory: function (t) { return AriaService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AriaService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return AriaService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var TabsLayout;
    (function (TabsLayout) {
        TabsLayout["HORIZONTAL"] = "horizontal";
        TabsLayout["VERTICAL"] = "vertical";
    })(TabsLayout || (TabsLayout = {}));

    var TabsService = /** @class */ (function () {
        function TabsService() {
            this._children = [];
            this.layout = TabsLayout.HORIZONTAL;
        }
        TabsService.prototype.register = function (tab) {
            this._children.push(tab);
        };
        Object.defineProperty(TabsService.prototype, "children", {
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsService.prototype, "activeTab", {
            get: function () {
                return this.children.find(function (tab) {
                    return tab.active;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsService.prototype, "overflowTabs", {
            get: function () {
                if (this.layout === TabsLayout.VERTICAL) {
                    return [];
                }
                else {
                    return this.children.filter(function (tab) { return tab.tabLink.inOverflow === true; });
                }
            },
            enumerable: true,
            configurable: true
        });
        TabsService.prototype.unregister = function (tab) {
            var index = this.children.indexOf(tab);
            if (index > -1) {
                this.children.splice(index, 1);
            }
        };
TabsService.ɵfac = function TabsService_Factory(t) { return new (t || TabsService)(); };
TabsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TabsService, factory: function (t) { return TabsService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabsService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return TabsService;
    }());

    var nbTabContentComponents = 0;
    var ClrTabContent = /** @class */ (function () {
        function ClrTabContent(ifActiveService, id, ariaService, tabsService) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.ariaService = ariaService;
            this.tabsService = tabsService;
            if (!this.tabContentId) {
                this.tabContentId = 'clr-tab-content-' + nbTabContentComponents++;
            }
        }
        Object.defineProperty(ClrTabContent.prototype, "templateRef", {
            // The template must be applied on the top-down phase of view-child initialization to prevent
            // components in the content from initializing before a content container exists.
            // Some child components need their container for sizing calculations.
            /* tslint:disable:no-unused-variable */
            set: function (value) {
                this.viewRef = this.tabsService.tabContentViewContainer.createEmbeddedView(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "ariaLabelledBy", {
            /* tslint:enable:no-unused-variable */
            get: function () {
                return this.ariaService.ariaLabelledBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "tabContentId", {
            get: function () {
                return this.ariaService.ariaControls;
            },
            set: function (id) {
                this.ariaService.ariaControls = id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "active", {
            get: function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabContent.prototype.ngOnDestroy = function () {
            var index = this.tabsService.tabContentViewContainer.indexOf(this.viewRef);
            if (index > -1) {
                this.tabsService.tabContentViewContainer.remove(index);
            }
        };
        ClrTabContent.ctorParameters = function () { return [
            { type: IfActiveService },
            { type: Number, decorators: [{ type: core.Inject, args: [IF_ACTIVE_ID,] }] },
            { type: AriaService },
            { type: TabsService }
        ]; };
        __decorate([
            core.ViewChild('tabContentProjectedRef', { static: true })
        ], ClrTabContent.prototype, "templateRef", null);
        __decorate([
            core.Input('id')
        ], ClrTabContent.prototype, "tabContentId", null);
        ClrTabContent = __decorate([ __param(1, core.Inject(IF_ACTIVE_ID))
        ], ClrTabContent);
ClrTabContent.ɵfac = function ClrTabContent_Factory(t) { return new (t || ClrTabContent)(ɵngcc0.ɵɵdirectiveInject(IfActiveService), ɵngcc0.ɵɵdirectiveInject(IF_ACTIVE_ID), ɵngcc0.ɵɵdirectiveInject(AriaService), ɵngcc0.ɵɵdirectiveInject(TabsService)); };
ClrTabContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTabContent, selectors: [["clr-tab-content"]], viewQuery: function ClrTabContent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c73, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, inputs: { tabContentId: ["id", "tabContentId"] }, ngContentSelectors: _c1, decls: 2, vars: 0, consts: [["tabContentProjectedRef", ""], ["role", "tabpanel", 1, "tab-content", 3, "id", "hidden"]], template: function ClrTabContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrTabContent_ng_template_0_Template, 2, 7, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTabContent, [{
        type: core.Component,
        args: [{
                selector: 'clr-tab-content',
                template: "\n    <ng-template #tabContentProjectedRef>\n      <section [id]=\"tabContentId\" role=\"tabpanel\" class=\"tab-content\" [class.active]=\"active\"\n               [hidden]=\"!active\"\n               [attr.aria-labelledby]=\"ariaLabelledBy\"\n               [attr.aria-expanded]=\"active\"\n               [attr.aria-hidden]=\"!active\">\n        <ng-content></ng-content>\n      </section>\n    </ng-template>\n    "
            }]
    }], function () { return [{ type: IfActiveService }, { type: Number, decorators: [{
                type: core.Inject,
                args: [IF_ACTIVE_ID]
            }] }, { type: AriaService }, { type: TabsService }]; }, { tabContentId: [{
            type: core.Input,
            args: ['id']
        }], templateRef: [{
            type: core.ViewChild,
            args: ['tabContentProjectedRef', { static: true }]
        }] }); })();
        return ClrTabContent;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var nbTabsComponent = 0;
    var TABS_ID = new core.InjectionToken('TABS_ID');
    function tokenFactory$1() {
        return 'clr-tabs-' + nbTabsComponent++;
    }
    var TABS_ID_PROVIDER = {
        provide: TABS_ID,
        useFactory: tokenFactory$1,
    };

    var nbTabLinkComponents = 0;
    var ClrTabLink = /** @class */ (function () {
        function ClrTabLink(ifActiveService, id, ariaService, el, cfr, viewContainerRef, tabsService, tabsId) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.ariaService = ariaService;
            this.el = el;
            this.cfr = cfr;
            this.viewContainerRef = viewContainerRef;
            this.tabsService = tabsService;
            this.tabsId = tabsId;
            if (!this.tabLinkId) {
                this.tabLinkId = 'clr-tab-link-' + nbTabLinkComponents++;
            }
            // Tab links can be rendered in one of two places: in the main area or inside the overflow dropdown menu.
            // Here, we create a container so that its template can be used to create embeddedView on the fly.
            // See TabsService's renderView() method and how it's used in Tabs class for an example.
            var factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
            this.templateRefContainer = this.viewContainerRef.createComponent(factory, undefined, undefined, [
                [this.el.nativeElement],
            ]).instance;
        }
        Object.defineProperty(ClrTabLink.prototype, "inOverflow", {
            get: function () {
                return this._inOverflow && this.tabsService.layout !== TabsLayout.VERTICAL;
            },
            set: function (inOverflow) {
                this._inOverflow = inOverflow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabLink.prototype, "addLinkClasses", {
            get: function () {
                return !this.inOverflow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabLink.prototype, "ariaControls", {
            get: function () {
                return this.ariaService.ariaControls;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabLink.prototype, "tabLinkId", {
            get: function () {
                return this.ariaService.ariaLabelledBy;
            },
            set: function (id) {
                this.ariaService.ariaLabelledBy = id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabLink.prototype.activate = function () {
            this.ifActiveService.current = this.id;
        };
        Object.defineProperty(ClrTabLink.prototype, "active", {
            get: function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabLink.prototype, "tabindex", {
            get: function () {
                return this.active ? 0 : -1;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabLink.ctorParameters = function () { return [
            { type: IfActiveService },
            { type: Number, decorators: [{ type: core.Inject, args: [IF_ACTIVE_ID,] }] },
            { type: AriaService },
            { type: core.ElementRef },
            { type: core.ComponentFactoryResolver },
            { type: core.ViewContainerRef },
            { type: TabsService },
            { type: Number, decorators: [{ type: core.Inject, args: [TABS_ID,] }] }
        ]; };
        __decorate([
            core.Input('clrTabLinkInOverflow')
        ], ClrTabLink.prototype, "inOverflow", null);
        __decorate([
            core.HostBinding('class.btn-link'),
            core.HostBinding('class.nav-link')
        ], ClrTabLink.prototype, "addLinkClasses", null);
        __decorate([
            core.HostBinding('attr.aria-controls')
        ], ClrTabLink.prototype, "ariaControls", null);
        __decorate([
            core.HostBinding('id'),
            core.Input('id')
        ], ClrTabLink.prototype, "tabLinkId", null);
        __decorate([
            core.HostListener('click')
        ], ClrTabLink.prototype, "activate", null);
        __decorate([
            core.HostBinding('class.active'),
            core.HostBinding('attr.aria-selected')
        ], ClrTabLink.prototype, "active", null);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], ClrTabLink.prototype, "tabindex", null);
        ClrTabLink = __decorate([ __param(1, core.Inject(IF_ACTIVE_ID)),
            __param(7, core.Inject(TABS_ID))
        ], ClrTabLink);
ClrTabLink.ɵfac = function ClrTabLink_Factory(t) { return new (t || ClrTabLink)(ɵngcc0.ɵɵdirectiveInject(IfActiveService), ɵngcc0.ɵɵdirectiveInject(IF_ACTIVE_ID), ɵngcc0.ɵɵdirectiveInject(AriaService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(TabsService), ɵngcc0.ɵɵdirectiveInject(TABS_ID)); };
ClrTabLink.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrTabLink, selectors: [["", "clrTabLink", ""]], hostAttrs: ["role", "tab", "type", "button"], hostVars: 13, hostBindings: function ClrTabLink_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrTabLink_click_HostBindingHandler() { return ctx.activate(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.tabLinkId);
        ɵngcc0.ɵɵattribute("aria-hidden", false)("aria-controls", ctx.ariaControls)("aria-selected", ctx.active)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("btn", true)("btn-link", ctx.addLinkClasses)("nav-link", ctx.addLinkClasses)("active", ctx.active);
    } }, inputs: { tabLinkId: ["id", "tabLinkId"], inOverflow: ["clrTabLinkInOverflow", "inOverflow"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTabLink, [{
        type: core.Directive,
        args: [{
                selector: '[clrTabLink]',
                host: {
                    '[attr.aria-hidden]': 'false',
                    '[class.btn]': 'true',
                    role: 'tab',
                    type: 'button'
                }
            }]
    }], function () { return [{ type: IfActiveService }, { type: Number, decorators: [{
                type: core.Inject,
                args: [IF_ACTIVE_ID]
            }] }, { type: AriaService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }, { type: TabsService }, { type: Number, decorators: [{
                type: core.Inject,
                args: [TABS_ID]
            }] }]; }, { tabLinkId: [{
            type: core.HostBinding,
            args: ['id']
        }, {
            type: core.Input,
            args: ['id']
        }], inOverflow: [{
            type: core.Input,
            args: ['clrTabLinkInOverflow']
        }], addLinkClasses: [{
            type: core.HostBinding,
            args: ['class.btn-link']
        }, {
            type: core.HostBinding,
            args: ['class.nav-link']
        }], ariaControls: [{
            type: core.HostBinding,
            args: ['attr.aria-controls']
        }], activate: [{
            type: core.HostListener,
            args: ['click']
        }], active: [{
            type: core.HostBinding,
            args: ['class.active']
        }, {
            type: core.HostBinding,
            args: ['attr.aria-selected']
        }], tabindex: [{
            type: core.HostBinding,
            args: ['attr.tabindex']
        }] }); })();
        return ClrTabLink;
    }());

    var ClrTab = /** @class */ (function () {
        function ClrTab(ifActiveService, id, tabsService) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.tabsService = tabsService;
            tabsService.register(this);
        }
        ClrTab.prototype.ngOnDestroy = function () {
            this.tabsService.unregister(this);
        };
        Object.defineProperty(ClrTab.prototype, "active", {
            get: function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTab.ctorParameters = function () { return [
            { type: IfActiveService },
            { type: Number, decorators: [{ type: core.Inject, args: [IF_ACTIVE_ID,] }] },
            { type: TabsService }
        ]; };
        __decorate([
            core.ContentChild(ClrTabLink, { static: true })
        ], ClrTab.prototype, "tabLink", void 0);
        __decorate([
            core.ContentChild(ClrTabContent, { static: true })
        ], ClrTab.prototype, "tabContent", void 0);
        ClrTab = __decorate([ __param(1, core.Inject(IF_ACTIVE_ID))
        ], ClrTab);
ClrTab.ɵfac = function ClrTab_Factory(t) { return new (t || ClrTab)(ɵngcc0.ɵɵdirectiveInject(IfActiveService), ɵngcc0.ɵɵdirectiveInject(IF_ACTIVE_ID), ɵngcc0.ɵɵdirectiveInject(TabsService)); };
ClrTab.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTab, selectors: [["clr-tab"]], contentQueries: function ClrTab_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrTabLink, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrTabContent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabLink = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabContent = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([IF_ACTIVE_ID_PROVIDER, AriaService])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTab_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTab, [{
        type: core.Component,
        args: [{
                selector: 'clr-tab',
                template: "\n        <ng-content></ng-content>\n    ",
                providers: [IF_ACTIVE_ID_PROVIDER, AriaService]
            }]
    }], function () { return [{ type: IfActiveService }, { type: Number, decorators: [{
                type: core.Inject,
                args: [IF_ACTIVE_ID]
            }] }, { type: TabsService }]; }, { tabLink: [{
            type: core.ContentChild,
            args: [ClrTabLink, { static: true }]
        }], tabContent: [{
            type: core.ContentChild,
            args: [ClrTabContent, { static: true }]
        }] }); })();
        return ClrTab;
    }());

    var ClrTabOverflowContent = /** @class */ (function () {
        function ClrTabOverflowContent() {
        }
ClrTabOverflowContent.ɵfac = function ClrTabOverflowContent_Factory(t) { return new (t || ClrTabOverflowContent)(); };
ClrTabOverflowContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTabOverflowContent, selectors: [["clr-tab-overflow-content"]], hostVars: 2, hostBindings: function ClrTabOverflowContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("dropdown-menu", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTabOverflowContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTabOverflowContent, [{
        type: core.Component,
        args: [{
                selector: 'clr-tab-overflow-content',
                template: "\n        <ng-content></ng-content>\n    ",
                host: {
                    '[class.dropdown-menu]': 'true'
                }
            }]
    }], function () { return []; }, null); })();
        return ClrTabOverflowContent;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrFocusDirection;
    (function (ClrFocusDirection) {
        ClrFocusDirection["VERTICAL"] = "vertical";
        ClrFocusDirection["HORIZONTAL"] = "horizontal";
        ClrFocusDirection["BOTH"] = "both";
    })(ClrFocusDirection || (ClrFocusDirection = {}));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrKeyFocusItem = /** @class */ (function () {
        function ClrKeyFocusItem(elementRef, platformId) {
            this.elementRef = elementRef;
            this.platformId = platformId;
        }
        Object.defineProperty(ClrKeyFocusItem.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        ClrKeyFocusItem.prototype.focus = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                this.elementRef.nativeElement.focus();
            }
        };
        ClrKeyFocusItem.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        __decorate([
            core.HostBinding('attr.tabindex')
        ], ClrKeyFocusItem.prototype, "tabIndex", void 0);
        ClrKeyFocusItem = __decorate([ __param(1, core.Inject(core.PLATFORM_ID))
        ], ClrKeyFocusItem);
ClrKeyFocusItem.ɵfac = function ClrKeyFocusItem_Factory(t) { return new (t || ClrKeyFocusItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
ClrKeyFocusItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrKeyFocusItem, selectors: [["", "clrKeyFocusItem", ""]], hostVars: 1, hostBindings: function ClrKeyFocusItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrKeyFocusItem, [{
        type: core.Directive,
        args: [{
                selector: '[clrKeyFocusItem]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { tabIndex: [{
            type: core.HostBinding,
            args: ['attr.tabindex']
        }] }); })();
        return ClrKeyFocusItem;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrKeyFocus = /** @class */ (function () {
        function ClrKeyFocus(elementRef) {
            this.elementRef = elementRef;
            this.direction = ClrFocusDirection.VERTICAL;
            this.focusOnLoad = false;
            this.focusChange = new core.EventEmitter();
            this._current = 0;
            this.subscriptions = [];
        }
        Object.defineProperty(ClrKeyFocus.prototype, "focusableItems", {
            get: function () {
                if (this._focusableItems) {
                    return this._focusableItems;
                }
                else {
                    return this.clrKeyFocusItems.toArray();
                }
            },
            set: function (elements) {
                // We accept a list of focusable elements (HTMLElements or existing Directives) or auto query for clrKeyFocusItem
                // We accept a list reference in the cases where we cannot use ContentChildren to query
                // ContentChildren can be unavailable if content is projected outside the scope of the component (see tabs).
                if (elements && elements.length) {
                    this._focusableItems = elements;
                    this.initializeFocus();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrKeyFocus.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrKeyFocus.prototype, "current", {
            get: function () {
                return this._current;
            },
            set: function (value) {
                if (this._current !== value) {
                    this._current = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrKeyFocus.prototype, "currentItem", {
            get: function () {
                return this.focusableItems[this._current];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrKeyFocus.prototype, "currentItemElement", {
            get: function () {
                return this.currentItem.nativeElement ? this.currentItem.nativeElement : this.currentItem;
            },
            enumerable: true,
            configurable: true
        });
        ClrKeyFocus.prototype.focusCurrent = function () {
            this.currentItem.focus();
            this.focusChange.next(this._current);
        };
        ClrKeyFocus.prototype.moveTo = function (position) {
            if (this.positionInRange(position)) {
                this.current = position;
                this.focusCurrent();
            }
        };
        ClrKeyFocus.prototype.ngAfterContentInit = function () {
            this.subscriptions.push(this.listenForItemUpdates());
            this.initializeFocus();
        };
        ClrKeyFocus.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ClrKeyFocus.prototype.handleKeyboardEvent = function (event) {
            // Make sure event was originated on the current item's element
            if (this.currentItemElement !== event.target) {
                var position = this.getItemPosition(event.target);
                if (this.positionInRange(position)) {
                    this.current = position;
                }
            }
            if (this.prevKeyPressed(event) && this.currentFocusIsNotFirstItem()) {
                this.moveTo(this.current - 1);
            }
            else if (this.nextKeyPressed(event) && this.currentFocusIsNotLastItem()) {
                this.moveTo(this.current + 1);
            }
            else if (event.code === KeyCodes.Home) {
                this.moveTo(0);
            }
            else if (event.code === KeyCodes.End) {
                this.moveTo(this.focusableItems.length - 1);
            }
            preventArrowKeyScroll(event);
        };
        ClrKeyFocus.prototype.setClickedItemCurrent = function (event) {
            var position = this.getItemPosition(event.target);
            if (position > -1) {
                this.moveTo(position);
            }
        };
        ClrKeyFocus.prototype.getItemPosition = function (item) {
            if (this._focusableItems) {
                return this.focusableItems.indexOf(item);
            }
            else {
                return this.focusableItems.map(function (_item) { return _item.nativeElement; }).indexOf(item);
            }
        };
        ClrKeyFocus.prototype.positionInRange = function (position) {
            return position >= 0 && position < this.focusableItems.length;
        };
        ClrKeyFocus.prototype.currentFocusIsNotFirstItem = function () {
            return this._current - 1 >= 0;
        };
        ClrKeyFocus.prototype.currentFocusIsNotLastItem = function () {
            return this._current + 1 < this.focusableItems.length;
        };
        ClrKeyFocus.prototype.initializeFocus = function () {
            if (this.focusableItems && this.focusableItems.length) {
                // It is possible that the focus was on an element, whose index is no longer available.
                // This can happen when some of the focusable elements are being removed.
                // In such cases, the new focus is initialized on the last focusable element.
                if (this._current >= this.focusableItems.length) {
                    this._current = this.focusableItems.length - 1;
                }
                if (this.focusOnLoad) {
                    this.currentItem.focus();
                    this.focusChange.next();
                }
            }
        };
        ClrKeyFocus.prototype.listenForItemUpdates = function () {
            var _this = this;
            return this.clrKeyFocusItems.changes.subscribe(function () {
                _this.initializeFocus();
            });
        };
        ClrKeyFocus.prototype.nextKeyPressed = function (event) {
            var keyCodes = getKeyCodes(event);
            switch (this.direction) {
                case ClrFocusDirection.VERTICAL:
                    return event.key === keyCodes.ArrowDown;
                case ClrFocusDirection.HORIZONTAL:
                    return event.key === keyCodes.ArrowRight;
                case ClrFocusDirection.BOTH:
                    return event.key === keyCodes.ArrowDown || event.key === keyCodes.ArrowRight;
                default:
                    return false;
            }
        };
        ClrKeyFocus.prototype.prevKeyPressed = function (event) {
            var keyCodes = getKeyCodes(event);
            switch (this.direction) {
                case ClrFocusDirection.VERTICAL:
                    return event.key === keyCodes.ArrowUp;
                case ClrFocusDirection.HORIZONTAL:
                    return event.key === keyCodes.ArrowLeft;
                case ClrFocusDirection.BOTH:
                    return event.key === keyCodes.ArrowUp || event.key === keyCodes.ArrowLeft;
                default:
                    return false;
            }
        };
        ClrKeyFocus.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('clrDirection')
        ], ClrKeyFocus.prototype, "direction", void 0);
        __decorate([
            core.Input('clrFocusOnLoad')
        ], ClrKeyFocus.prototype, "focusOnLoad", void 0);
        __decorate([
            core.Output('clrFocusChange')
        ], ClrKeyFocus.prototype, "focusChange", void 0);
        __decorate([
            core.ContentChildren(ClrKeyFocusItem, { descendants: true })
        ], ClrKeyFocus.prototype, "clrKeyFocusItems", void 0);
        __decorate([
            core.Input('clrKeyFocus')
        ], ClrKeyFocus.prototype, "focusableItems", null);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], ClrKeyFocus.prototype, "handleKeyboardEvent", null);
        __decorate([
            core.HostListener('click', ['$event'])
        ], ClrKeyFocus.prototype, "setClickedItemCurrent", null);
ClrKeyFocus.ɵfac = function ClrKeyFocus_Factory(t) { return new (t || ClrKeyFocus)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrKeyFocus.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrKeyFocus, selectors: [["", "clrKeyFocus", ""]], contentQueries: function ClrKeyFocus_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrKeyFocusItem, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clrKeyFocusItems = _t);
    } }, hostBindings: function ClrKeyFocus_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ClrKeyFocus_keydown_HostBindingHandler($event) { return ctx.handleKeyboardEvent($event); })("click", function ClrKeyFocus_click_HostBindingHandler($event) { return ctx.setClickedItemCurrent($event); });
    } }, inputs: { direction: ["clrDirection", "direction"], focusOnLoad: ["clrFocusOnLoad", "focusOnLoad"], focusableItems: ["clrKeyFocus", "focusableItems"] }, outputs: { focusChange: "clrFocusChange" }, attrs: _c74, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrKeyFocus_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrKeyFocus, [{
        type: core.Component,
        args: [{
                selector: '[clrKeyFocus]',
                template: '<ng-content></ng-content>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { direction: [{
            type: core.Input,
            args: ['clrDirection']
        }], focusOnLoad: [{
            type: core.Input,
            args: ['clrFocusOnLoad']
        }], focusChange: [{
            type: core.Output,
            args: ['clrFocusChange']
        }], focusableItems: [{
            type: core.Input,
            args: ['clrKeyFocus']
        }], handleKeyboardEvent: [{
            type: core.HostListener,
            args: ['keydown', ['$event']]
        }], setClickedItemCurrent: [{
            type: core.HostListener,
            args: ['click', ['$event']]
        }], clrKeyFocusItems: [{
            type: core.ContentChildren,
            args: [ClrKeyFocusItem, { descendants: true }]
        }] }); })();
        return ClrKeyFocus;
    }());

    var ClrTabs = /** @class */ (function () {
        function ClrTabs(ifActiveService, toggleService, tabsService, tabsId, commonStrings) {
            this.ifActiveService = ifActiveService;
            this.toggleService = toggleService;
            this.tabsService = tabsService;
            this.tabsId = tabsId;
            this.commonStrings = commonStrings;
            this.subscriptions = [];
            this._tabLinkDirectives = [];
            this.tabLinkElements = [];
            // in order to check focus is triggered by click
            // we are using this _mousedown flag
            this._mousedown = false;
        }
        Object.defineProperty(ClrTabs.prototype, "overflowPosition", {
            get: function () {
                return this._tabLinkDirectives.filter(function (link) { return !link.inOverflow; }).length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "tabContentViewContainer", {
            /* tslint:disable:no-unused-variable */
            set: function (value) {
                this.tabsService.tabContentViewContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "layout", {
            get: function () {
                return this.tabsService.layout;
            },
            /* tslint:enable:no-unused-variable */
            set: function (layout) {
                if (Object.keys(TabsLayout)
                    .map(function (key) {
                    return TabsLayout[key];
                })
                    .indexOf(layout) >= 0) {
                    this.tabsService.layout = layout;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "tabLinkDirectives", {
            get: function () {
                return this._tabLinkDirectives;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "activeTabInOverflow", {
            get: function () {
                return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "activeTabPosition", {
            get: function () {
                return this._tabLinkDirectives.findIndex(function (link) { return link.active; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "tabIds", {
            get: function () {
                return this.tabsService.children.map(function (tab) { return tab.tabLink.tabLinkId; }).join(' ');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "isCurrentInOverflow", {
            get: function () {
                return this.keyFocus.current >= this.overflowPosition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "isVertical", {
            get: function () {
                return this.layout === TabsLayout.VERTICAL;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabs.prototype.toggleOverflowOnPosition = function (position) {
            // we need to check current position to determine
            // whether we need to open the tab overflow or not
            this.toggleService.open = position >= this.overflowPosition;
        };
        Object.defineProperty(ClrTabs.prototype, "tabOverflowEl", {
            set: function (value) {
                this._tabOverflowEl = value && value.nativeElement;
                if (this.toggleService.open && value) {
                    // only when tab overflow view element is registered,
                    // we need to move the focus to the first item
                    this.keyFocus.focusCurrent();
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrTabs.prototype.resetKeyFocusCurrentToActive = function (event) {
            var keyFocusContainsFocus = this.keyFocus.nativeElement.contains(event.relatedTarget);
            if (!keyFocusContainsFocus && this.keyFocus.current !== this.activeTabPosition) {
                this.keyFocus.current = this.activeTabPosition;
            }
        };
        ClrTabs.prototype.toggleOverflowOnClick = function () {
            if (this.isCurrentInOverflow && this.toggleService.open) {
                this.keyFocus.moveTo(this.overflowPosition - 1);
            }
            else {
                this.keyFocus.moveTo(this.overflowPosition);
            }
            // once click handler completes running,
            // reset the _mousedown flag
            this._mousedown = false;
        };
        ClrTabs.prototype.openOverflowOnFocus = function () {
            // This method should be called only on keyboard generated focus
            // when the active tab is in the overflow
            if (!this._mousedown && !this.toggleService.open) {
                this.keyFocus.moveTo(this.activeTabPosition);
            }
        };
        ClrTabs.prototype.closeOnFocusOut = function (event) {
            if (!this._tabOverflowEl.contains(event.relatedTarget) &&
                this.toggleService.open &&
                !this._mousedown) {
                this.toggleService.open = false;
                // if the focus is out of overflow and lands on the active tab link
                // which is currently visible, set the key focus current to activeTabPosition
                if (this.tabLinkElements[this.activeTabPosition] === event.relatedTarget) {
                    this.keyFocus.current = this.activeTabPosition;
                }
            }
        };
        ClrTabs.prototype.closeOnEscapeKey = function () {
            // Move current to the last visible focusable item
            this.keyFocus.moveTo(this.overflowPosition - 1);
        };
        ClrTabs.prototype.closeOnOutsideClick = function (event, tabOverflowTrigger) {
            // Exit early if the event target is the trigger element itself or element that's inside the trigger element.
            // This is because we have another handler on the tabOverflowTrigger element itself.
            // As this handler method is on the document level so the event bubbles up to it and conflicts
            // with the tabOverflowTrigger handler resulting in opening the tab overflow and closing it right away consecutively.
            if (event.target === tabOverflowTrigger || tabOverflowTrigger.contains(event.target)) {
                return;
            }
            // Move current to the last visible focusable item
            if (!this._tabOverflowEl.contains(event.target) && this.isCurrentInOverflow) {
                this.keyFocus.moveTo(this.overflowPosition - 1);
            }
        };
        ClrTabs.prototype.listenForTabLinkChanges = function () {
            var _this = this;
            return this.tabs.changes.pipe(operators.startWith(this.tabs.map(function (tab) { return tab.tabLink; }))).subscribe(function () {
                _this._tabLinkDirectives = _this.tabs.map(function (tab) { return tab.tabLink; });
                _this.tabLinkElements = _this._tabLinkDirectives.map(function (tab) { return tab.el.nativeElement; });
            });
        };
        ClrTabs.prototype.ngAfterContentInit = function () {
            this.subscriptions.push(this.listenForTabLinkChanges());
            if (typeof this.ifActiveService.current === 'undefined' && this.tabLinkDirectives[0]) {
                this.tabLinkDirectives[0].activate();
            }
            // set initial current position
            this.keyFocus.current = this.activeTabPosition;
        };
        ClrTabs.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) {
                sub.unsubscribe();
            });
        };
        ClrTabs.ctorParameters = function () { return [
            { type: IfActiveService },
            { type: ClrPopoverToggleService },
            { type: TabsService },
            { type: Number, decorators: [{ type: core.Inject, args: [TABS_ID,] }] },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.ViewChild('tabContentViewContainer', { static: true, read: core.ViewContainerRef })
        ], ClrTabs.prototype, "tabContentViewContainer", null);
        __decorate([
            core.Input('clrLayout')
        ], ClrTabs.prototype, "layout", null);
        __decorate([
            core.ContentChildren(ClrTab)
        ], ClrTabs.prototype, "tabs", void 0);
        __decorate([
            core.ViewChild(ClrKeyFocus, { static: true })
        ], ClrTabs.prototype, "keyFocus", void 0);
        __decorate([
            core.HostBinding('class.tabs-vertical')
        ], ClrTabs.prototype, "isVertical", null);
        __decorate([
            core.ViewChild(ClrTabOverflowContent, { read: core.ElementRef })
        ], ClrTabs.prototype, "tabOverflowEl", null);
        ClrTabs = __decorate([ __param(3, core.Inject(TABS_ID))
        ], ClrTabs);
ClrTabs.ɵfac = function ClrTabs_Factory(t) { return new (t || ClrTabs)(ɵngcc0.ɵɵdirectiveInject(IfActiveService), ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(TabsService), ɵngcc0.ɵɵdirectiveInject(TABS_ID), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrTabs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTabs, selectors: [["clr-tabs"]], contentQueries: function ClrTabs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTab, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, viewQuery: function ClrTabs_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c75, true, core.ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(ClrTabOverflowContent, true, core.ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(ClrKeyFocus, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabContentViewContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabOverflowEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.keyFocus = _t.first);
    } }, hostVars: 2, hostBindings: function ClrTabs_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("tabs-vertical", ctx.isVertical);
    } }, inputs: { layout: ["clrLayout", "layout"] }, features: [ɵngcc0.ɵɵProvidersFeature([IfActiveService, ClrPopoverToggleService, TabsService, TABS_ID_PROVIDER])], decls: 5, vars: 4, consts: [["role", "tablist", "clrDirection", "both", 1, "nav", 3, "clrKeyFocus", "clrFocusChange", "focusout"], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["tabContentViewContainer", ""], ["role", "presentation", 1, "nav-item"], [3, "ngTemplateOutlet"], ["role", "presentation", 1, "tabs-overflow", "bottom-right"], ["role", "application", 1, "nav-item"], ["type", "button", "aria-hidden", "true", 1, "btn", "btn-link", "nav-link", "dropdown-toggle", 3, "mousedown", "focus", "click"], ["tabOverflowTrigger", ""], ["shape", "ellipsis-horizontal"], [3, "keydown.esc", "click", "focusout", 4, "ngIf"], [3, "keydown.esc", "click", "focusout"], [3, "ngTemplateOutlet", 4, "ngIf"]], template: function ClrTabs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵlistener("clrFocusChange", function ClrTabs_Template_ul_clrFocusChange_0_listener($event) { return ctx.toggleOverflowOnPosition($event); })("focusout", function ClrTabs_Template_ul_focusout_0_listener($event) { return ctx.resetKeyFocusCurrentToActive($event); });
        ɵngcc0.ɵɵtemplate(1, ClrTabs_ng_container_1_Template, 2, 1, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, ClrTabs_ng_container_2_Template, 7, 11, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(3, null, 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("clrKeyFocus", ctx.tabLinkElements);
        ɵngcc0.ɵɵattribute("aria-owns", ctx.tabIds);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabLinkDirectives);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tabsService.overflowTabs.length > 0);
    } }, directives: [ClrKeyFocus, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ClrIconCustomTag,
        ClrTabOverflowContent], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTabs, [{
        type: core.Component,
        args: [{
                selector: 'clr-tabs',
                template: "\n        <ul class=\"nav\" role=\"tablist\" [attr.aria-owns]=\"tabIds\" [clrKeyFocus]=\"tabLinkElements\" clrDirection=\"both\" (clrFocusChange)=\"toggleOverflowOnPosition($event)\" (focusout)=\"resetKeyFocusCurrentToActive($event)\">\n            <!--tab links-->\n            <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                <ng-container *ngIf=\"link.tabsId === tabsId && !link.inOverflow\">\n                    <li role=\"presentation\" class=\"nav-item\">\n                        <ng-container [ngTemplateOutlet]=\"link.templateRefContainer.template\"></ng-container>\n                    </li>\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"tabsService.overflowTabs.length > 0\">\n                <div class=\"tabs-overflow bottom-right\" role=\"presentation\" \n                  [class.open]=\"toggleService.open\">\n                    <li role=\"application\" class=\"nav-item\">\n                        <button #tabOverflowTrigger class=\"btn btn-link nav-link dropdown-toggle\" type=\"button\" aria-hidden=\"true\" \n                        [attr.tabindex]=\"activeTabInOverflow && !toggleService.open? 0: -1\"\n                        [class.active]=\"activeTabInOverflow\"\n                        [class.open]=\"toggleService.open\"\n                        (mousedown)=\"_mousedown = true\"\n                        (focus)=\"openOverflowOnFocus()\"\n                        (click)=\"toggleOverflowOnClick()\">\n                            <clr-icon shape=\"ellipsis-horizontal\"\n                              [class.is-info]=\"toggleService.open\"\n                              [attr.title]=\"commonStrings.keys.more\"></clr-icon>\n                        </button>\n                    </li>\n                    <!--tab links in overflow menu-->\n                    <clr-tab-overflow-content *ngIf=\"toggleService.open\"  \n                      (document:keydown.esc)=\"closeOnEscapeKey()\" \n                      (document:click)=\"closeOnOutsideClick($event, tabOverflowTrigger)\"\n                      (focusout)=\"closeOnFocusOut($event)\">\n                        <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                            <ng-container *ngIf=\"link.tabsId === tabsId && link.inOverflow\"\n                                          [ngTemplateOutlet]=\"link.templateRefContainer.template\">\n                            </ng-container>\n                        </ng-container>\n                    </clr-tab-overflow-content>\n                </div>\n            </ng-container>\n        </ul>\n        <ng-container #tabContentViewContainer></ng-container>\n    ",
                providers: [IfActiveService, ClrPopoverToggleService, TabsService, TABS_ID_PROVIDER]
            }]
    }], function () { return [{ type: IfActiveService }, { type: ClrPopoverToggleService }, { type: TabsService }, { type: Number, decorators: [{
                type: core.Inject,
                args: [TABS_ID]
            }] }, { type: ClrCommonStringsService }]; }, { tabContentViewContainer: [{
            type: core.ViewChild,
            args: ['tabContentViewContainer', { static: true, read: core.ViewContainerRef }]
        }], layout: [{
            type: core.Input,
            args: ['clrLayout']
        }], isVertical: [{
            type: core.HostBinding,
            args: ['class.tabs-vertical']
        }], tabOverflowEl: [{
            type: core.ViewChild,
            args: [ClrTabOverflowContent, { read: core.ElementRef }]
        }], tabs: [{
            type: core.ContentChildren,
            args: [ClrTab]
        }], keyFocus: [{
            type: core.ViewChild,
            args: [ClrKeyFocus, { static: true }]
        }] }); })();
        return ClrTabs;
    }());

    var KEY_FOCUS_DIRECTIVES = [ClrKeyFocus, ClrKeyFocusItem];
    var ClrKeyFocusModule = /** @class */ (function () {
        function ClrKeyFocusModule() {
        }
ClrKeyFocusModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrKeyFocusModule });
ClrKeyFocusModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrKeyFocusModule_Factory(t) { return new (t || ClrKeyFocusModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrKeyFocusModule, { declarations: [ClrKeyFocus,
        ClrKeyFocusItem], imports: [ɵngcc1.CommonModule], exports: [ClrKeyFocus,
        ClrKeyFocusItem] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrKeyFocusModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [KEY_FOCUS_DIRECTIVES],
                exports: [KEY_FOCUS_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrKeyFocusModule;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_TABS_DIRECTIVES = [
        ClrTabContent,
        ClrTab,
        ClrTabs,
        ClrTabOverflowContent,
        ClrTabLink,
        TabsWillyWonka,
        ActiveOompaLoompa,
    ];
    var ClrTabsModule = /** @class */ (function () {
        function ClrTabsModule() {
        }
ClrTabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrTabsModule });
ClrTabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrTabsModule_Factory(t) { return new (t || ClrTabsModule)(); }, imports: [[common.CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule],
        ClrConditionalModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrTabsModule, { declarations: [ClrTabContent,
        ClrTab,
        ClrTabs,
        ClrTabOverflowContent,
        ClrTabLink,
        TabsWillyWonka,
        ActiveOompaLoompa], imports: [ɵngcc1.CommonModule, ClrConditionalModule,
        ClrIconModule,
        ClrTemplateRefModule,
        ClrKeyFocusModule], exports: [ClrTabContent,
        ClrTab,
        ClrTabs,
        ClrTabOverflowContent,
        ClrTabLink,
        TabsWillyWonka,
        ActiveOompaLoompa,
        ClrConditionalModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTabsModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule],
                declarations: [CLR_TABS_DIRECTIVES],
                exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule]
            }]
    }], function () { return []; }, null); })();
        return ClrTabsModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var VerticalNavGroupRegistrationService = /** @class */ (function () {
        function VerticalNavGroupRegistrationService() {
            this.navGroupCount = 0;
        }
        VerticalNavGroupRegistrationService.prototype.registerNavGroup = function () {
            this.navGroupCount++;
        };
        VerticalNavGroupRegistrationService.prototype.unregisterNavGroup = function () {
            this.navGroupCount--;
        };
VerticalNavGroupRegistrationService.ɵfac = function VerticalNavGroupRegistrationService_Factory(t) { return new (t || VerticalNavGroupRegistrationService)(); };
VerticalNavGroupRegistrationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: VerticalNavGroupRegistrationService, factory: function (t) { return VerticalNavGroupRegistrationService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VerticalNavGroupRegistrationService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return VerticalNavGroupRegistrationService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var VerticalNavIconService = /** @class */ (function () {
        function VerticalNavIconService() {
            this._icons = 0;
        }
        Object.defineProperty(VerticalNavIconService.prototype, "hasIcons", {
            get: function () {
                return this._icons > 0;
            },
            enumerable: true,
            configurable: true
        });
        VerticalNavIconService.prototype.registerIcon = function () {
            this._icons++;
        };
        VerticalNavIconService.prototype.unregisterIcon = function () {
            this._icons--;
        };
VerticalNavIconService.ɵfac = function VerticalNavIconService_Factory(t) { return new (t || VerticalNavIconService)(); };
VerticalNavIconService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: VerticalNavIconService, factory: function (t) { return VerticalNavIconService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VerticalNavIconService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return VerticalNavIconService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var VerticalNavService = /** @class */ (function () {
        function VerticalNavService() {
            this._animateOnCollapsed = new rxjs.Subject();
            this._collapsedChanged = new rxjs.Subject();
            this._collapsed = false;
            this._collapsible = false;
        }
        Object.defineProperty(VerticalNavService.prototype, "animateOnCollapsed", {
            get: function () {
                return this._animateOnCollapsed.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsedChanged", {
            get: function () {
                return this._collapsedChanged.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsed", {
            get: function () {
                return this._collapsed;
            },
            set: function (value) {
                value = !!value;
                if (this.collapsible && this._collapsed !== value) {
                    this.updateCollapseBehavior(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsible", {
            get: function () {
                return this._collapsible;
            },
            set: function (value) {
                value = !!value;
                if (this._collapsible !== value) {
                    if (!value && this.collapsed) {
                        this.updateCollapseBehavior(false);
                    }
                    this._collapsible = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        VerticalNavService.prototype.updateCollapseBehavior = function (value) {
            this._animateOnCollapsed.next(value);
            this._collapsed = value;
            this._collapsedChanged.next(value);
        };
VerticalNavService.ɵfac = function VerticalNavService_Factory(t) { return new (t || VerticalNavService)(); };
VerticalNavService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: VerticalNavService, factory: function (t) { return VerticalNavService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VerticalNavService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return VerticalNavService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrVerticalNav = /** @class */ (function () {
        function ClrVerticalNav(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
            var _this = this;
            this._navService = _navService;
            this._navIconService = _navIconService;
            this._navGroupRegistrationService = _navGroupRegistrationService;
            this.commonStrings = commonStrings;
            this._collapsedChanged = new core.EventEmitter(true);
            this._sub = this._navService.collapsedChanged.subscribe(function (value) {
                _this._collapsedChanged.emit(value);
            });
        }
        Object.defineProperty(ClrVerticalNav.prototype, "collapsible", {
            get: function () {
                return this._navService.collapsible;
            },
            set: function (value) {
                this._navService.collapsible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "collapsed", {
            get: function () {
                return this._navService.collapsed;
            },
            set: function (value) {
                this._navService.collapsed = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "hasNavGroups", {
            get: function () {
                return this._navGroupRegistrationService.navGroupCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "hasIcons", {
            get: function () {
                return this._navIconService.hasIcons;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "ariaExpanded", {
            get: function () {
                if (!this.collapsible) {
                    return null;
                }
                return !this.collapsed ? 'true' : 'false';
            },
            enumerable: true,
            configurable: true
        });
        ClrVerticalNav.prototype.toggleByButton = function () {
            this.collapsed = !this.collapsed;
        };
        ClrVerticalNav.prototype.ngOnDestroy = function () {
            this._sub.unsubscribe();
        };
        ClrVerticalNav.ctorParameters = function () { return [
            { type: VerticalNavService },
            { type: VerticalNavIconService },
            { type: VerticalNavGroupRegistrationService },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.Input('clrVerticalNavCollapsible')
        ], ClrVerticalNav.prototype, "collapsible", null);
        __decorate([
            core.Input('clrVerticalNavCollapsed')
        ], ClrVerticalNav.prototype, "collapsed", null);
        __decorate([
            core.Output('clrVerticalNavCollapsedChange')
        ], ClrVerticalNav.prototype, "_collapsedChanged", void 0);
ClrVerticalNav.ɵfac = function ClrVerticalNav_Factory(t) { return new (t || ClrVerticalNav)(ɵngcc0.ɵɵdirectiveInject(VerticalNavService), ɵngcc0.ɵɵdirectiveInject(VerticalNavIconService), ɵngcc0.ɵɵdirectiveInject(VerticalNavGroupRegistrationService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrVerticalNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrVerticalNav, selectors: [["clr-vertical-nav"]], hostAttrs: [1, "clr-vertical-nav"], hostVars: 6, hostBindings: function ClrVerticalNav_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("is-collapsed", ctx.collapsed)("has-nav-groups", ctx.hasNavGroups)("has-icons", ctx.hasIcons);
    } }, inputs: { collapsible: ["clrVerticalNavCollapsible", "collapsible"], collapsed: ["clrVerticalNavCollapsed", "collapsed"] }, outputs: { _collapsedChanged: "clrVerticalNavCollapsedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService])], ngContentSelectors: _c1, decls: 4, vars: 2, consts: [["type", "button", "class", "nav-trigger", 3, "on-collapse", "click", 4, "ngIf"], [1, "nav-content"], ["class", "nav-btn", "aria-hidden", "true", "tabindex", "-1", 3, "click", 4, "ngIf"], ["type", "button", 1, "nav-trigger", 3, "click"], ["shape", "angle-double", 1, "nav-trigger-icon"], ["aria-hidden", "true", "tabindex", "-1", 1, "nav-btn", 3, "click"]], template: function ClrVerticalNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ClrVerticalNav_button_0_Template, 2, 6, "button", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵtemplate(3, ClrVerticalNav_button_3_Template, 1, 1, "button", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.collapsible);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.collapsible && ctx.collapsed);
    } }, directives: [ɵngcc1.NgIf, ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrVerticalNav, [{
        type: core.Component,
        args: [{
                selector: 'clr-vertical-nav',
                template: "<!--\n  ~ Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<button type=\"button\" class=\"nav-trigger\"\n        [class.on-collapse]=\"collapsed\"\n        [attr.aria-expanded]=\"ariaExpanded\"\n        [attr.aria-label]=\"commonStrings.keys.verticalNavToggle\"\n        (click)=\"toggleByButton()\"\n        *ngIf=\"collapsible\">\n    <clr-icon shape=\"angle-double\"\n              class=\"nav-trigger-icon\"\n              [attr.dir]=\"(this.collapsed) ? 'right' : 'left'\"\n              [attr.title]=\"(this.collapsed) ? commonStrings.keys.expand : commonStrings.keys.collapse\"></clr-icon>\n</button>\n<!-- Click handler on .nav-content is bad but required :-( -->\n<div class=\"nav-content\">\n    <ng-content></ng-content>\n    <button (click)=\"collapsed = false\" class=\"nav-btn\" aria-hidden=\"true\" tabindex=\"-1\"\n      [attr.aria-label]=\"commonStrings.keys.verticalNavToggle\"\n      *ngIf=\"collapsible && collapsed\"></button>\n</div>\n",
                providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
                host: {
                    class: 'clr-vertical-nav',
                    '[class.is-collapsed]': 'collapsed',
                    '[class.has-nav-groups]': 'hasNavGroups',
                    '[class.has-icons]': 'hasIcons'
                }
            }]
    }], function () { return [{ type: VerticalNavService }, { type: VerticalNavIconService }, { type: VerticalNavGroupRegistrationService }, { type: ClrCommonStringsService }]; }, { _collapsedChanged: [{
            type: core.Output,
            args: ['clrVerticalNavCollapsedChange']
        }], collapsible: [{
            type: core.Input,
            args: ['clrVerticalNavCollapsible']
        }], collapsed: [{
            type: core.Input,
            args: ['clrVerticalNavCollapsed']
        }] }); })();
        return ClrVerticalNav;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var VerticalNavGroupService = /** @class */ (function () {
        function VerticalNavGroupService() {
            this._expandChange = new rxjs.Subject();
        }
        Object.defineProperty(VerticalNavGroupService.prototype, "expandChange", {
            get: function () {
                return this._expandChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        VerticalNavGroupService.prototype.expand = function () {
            this._expandChange.next(true);
        };
VerticalNavGroupService.ɵfac = function VerticalNavGroupService_Factory(t) { return new (t || VerticalNavGroupService)(); };
VerticalNavGroupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: VerticalNavGroupService, factory: function (t) { return VerticalNavGroupService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VerticalNavGroupService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return VerticalNavGroupService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var EXPANDED_STATE = 'expanded';
    var COLLAPSED_STATE = 'collapsed';
    var ClrVerticalNavGroup = /** @class */ (function () {
        function ClrVerticalNavGroup(_itemExpand, _navGroupRegistrationService, _navGroupService, _navService, commonStrings) {
            var _this = this;
            this._itemExpand = _itemExpand;
            this._navGroupRegistrationService = _navGroupRegistrationService;
            this._navGroupService = _navGroupService;
            this._navService = _navService;
            this.commonStrings = commonStrings;
            this.wasExpanded = false;
            this.expandedChange = new core.EventEmitter(true);
            this._subscriptions = [];
            this._expandAnimationState = COLLAPSED_STATE;
            this._navGroupRegistrationService.registerNavGroup();
            // FIXME: This subscription handles a corner case
            // Vertical Nav collapse requires the animation to run first and then
            // remove the nodes from the DOM. If the user directly sets the input
            // on the clrIfExpanded directive, we have no chance to run the animation
            // and wait for it to complete. This subscription makes sure that the
            // animation states are correct for that edge case.
            this._subscriptions.push(this._itemExpand.expandChange.subscribe(function (value) {
                if (value && _this.expandAnimationState === COLLAPSED_STATE) {
                    if (_this._navService.collapsed) {
                        _this._navService.collapsed = false;
                    }
                    _this.expandAnimationState = EXPANDED_STATE;
                }
                else if (!value && _this.expandAnimationState === EXPANDED_STATE) {
                    _this.expandAnimationState = COLLAPSED_STATE;
                }
            }));
            // 1. If the nav is collapsing, close the open nav group + save its state
            // 2. If the nav is expanding, expand the nav group if the previous state was expanded
            this._subscriptions.push(this._navService.animateOnCollapsed.subscribe(function (goingToCollapse) {
                if (goingToCollapse && _this.expanded) {
                    _this.wasExpanded = true;
                    _this.expandAnimationState = COLLAPSED_STATE;
                }
                else if (!goingToCollapse && _this.wasExpanded) {
                    _this.expandGroup();
                    _this.wasExpanded = false;
                }
            }));
            // If a link is clicked, expand the nav group
            this._subscriptions.push(this._navGroupService.expandChange.subscribe(function (expand) {
                if (expand && !_this.expanded) {
                    _this.expandGroup();
                }
            }));
        }
        Object.defineProperty(ClrVerticalNavGroup.prototype, "expanded", {
            get: function () {
                return this._itemExpand.expanded;
            },
            set: function (value) {
                if (this._itemExpand.expanded !== value) {
                    this._itemExpand.expanded = value;
                    this.expandedChange.emit(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNavGroup.prototype, "userExpandedInput", {
            set: function (value) {
                value = !!value;
                if (this.expanded !== value) {
                    // We have to call toggleExpand because some cases require animations to occur first
                    // Directly setting the Expand service value skips the animation and can result in
                    // nodes in the DOM but the nav group still being collapsed
                    this.toggleExpand();
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrVerticalNavGroup.prototype.expandGroup = function () {
            this.expanded = true;
            // Expanded animation occurs after Expand.expand is set to true
            this.expandAnimationState = EXPANDED_STATE;
        };
        ClrVerticalNavGroup.prototype.collapseGroup = function () {
            // If a Vertical Nav Group toggle button is clicked while the Vertical Nav is in Collapsed state,
            // the Vertical Nav should be expanded first.
            this.expandAnimationState = COLLAPSED_STATE;
        };
        // closes a group after the collapse animation
        ClrVerticalNavGroup.prototype.expandAnimationDone = function ($event) {
            if ($event.toState === COLLAPSED_STATE) {
                this.expanded = false;
            }
        };
        Object.defineProperty(ClrVerticalNavGroup.prototype, "expandAnimationState", {
            get: function () {
                return this._expandAnimationState;
            },
            set: function (value) {
                if (value !== this._expandAnimationState) {
                    this._expandAnimationState = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrVerticalNavGroup.prototype.toggleExpand = function () {
            if (this.expanded) {
                this.collapseGroup();
            }
            else {
                // If nav is collasped, first open the nav
                if (this._navService.collapsed) {
                    this._navService.collapsed = false;
                }
                // then expand the nav group
                this.expandGroup();
            }
        };
        ClrVerticalNavGroup.prototype.ngAfterContentInit = function () {
            // This makes sure that if someone marks a nav group expanded in a collapsed nav
            // the expanded property is switched back to collapsed state.
            if (this._navService.collapsed && this.expanded) {
                this.wasExpanded = true;
                this.expandAnimationState = COLLAPSED_STATE;
            }
        };
        ClrVerticalNavGroup.prototype.ngOnDestroy = function () {
            this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            this._navGroupRegistrationService.unregisterNavGroup();
        };
        ClrVerticalNavGroup.ctorParameters = function () { return [
            { type: IfExpandService },
            { type: VerticalNavGroupRegistrationService },
            { type: VerticalNavGroupService },
            { type: VerticalNavService },
            { type: ClrCommonStringsService }
        ]; };
        __decorate([
            core.HostBinding('class.is-expanded')
        ], ClrVerticalNavGroup.prototype, "expanded", null);
        __decorate([
            core.Input('clrVerticalNavGroupExpanded')
        ], ClrVerticalNavGroup.prototype, "userExpandedInput", null);
        __decorate([
            core.Output('clrVerticalNavGroupExpandedChange')
        ], ClrVerticalNavGroup.prototype, "expandedChange", void 0);
ClrVerticalNavGroup.ɵfac = function ClrVerticalNavGroup_Factory(t) { return new (t || ClrVerticalNavGroup)(ɵngcc0.ɵɵdirectiveInject(IfExpandService), ɵngcc0.ɵɵdirectiveInject(VerticalNavGroupRegistrationService), ɵngcc0.ɵɵdirectiveInject(VerticalNavGroupService), ɵngcc0.ɵɵdirectiveInject(VerticalNavService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService)); };
ClrVerticalNavGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrVerticalNavGroup, selectors: [["clr-vertical-nav-group"]], hostAttrs: [1, "nav-group"], hostVars: 2, hostBindings: function ClrVerticalNavGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("is-expanded", ctx.expanded);
    } }, inputs: { userExpandedInput: ["clrVerticalNavGroupExpanded", "userExpandedInput"] }, outputs: { expandedChange: "clrVerticalNavGroupExpandedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([IfExpandService, VerticalNavGroupService])], ngContentSelectors: _c77, decls: 9, vars: 5, consts: [[1, "nav-group-content"], ["type", "button", 1, "nav-group-trigger", 3, "click"], [1, "nav-group-text"], ["shape", "caret", 1, "nav-group-trigger-icon"], [1, "nav-group-children"]], template: function ClrVerticalNavGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c76);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "button", 1);
        ɵngcc0.ɵɵlistener("click", function ClrVerticalNavGroup_Template_button_click_2_listener() { return ctx.toggleExpand(); });
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵprojection(5, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(6, "clr-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 4);
        ɵngcc0.ɵɵlistener("@clrExpand.done", function ClrVerticalNavGroup_Template_div_animation_clrExpand_done_7_listener($event) { return ctx.expandAnimationDone($event); });
        ɵngcc0.ɵɵprojection(8, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded)("aria-label", ctx.commonStrings.keys.verticalNavGroupToggle);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵattribute("dir", ctx.expanded ? "down" : "right")("title", ctx.expanded ? ctx.commonStrings.keys.collapse : ctx.commonStrings.keys.expand);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("@clrExpand", ctx.expandAnimationState);
    } }, directives: [ClrIconCustomTag], encapsulation: 2, data: { animation: [
            animations.trigger('clrExpand', [
                animations.state(EXPANDED_STATE, animations.style({ height: '*' })),
                animations.state(COLLAPSED_STATE, animations.style({ height: 0, 'overflow-y': 'hidden', visibility: 'hidden' })),
                animations.transition(EXPANDED_STATE + " <=> " + COLLAPSED_STATE, animations.animate('0.2s ease-in-out')),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrVerticalNavGroup, [{
        type: core.Component,
        args: [{
                selector: 'clr-vertical-nav-group',
                template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"nav-group-content\">\n    <ng-content select=\"[clrVerticalNavLink]\"></ng-content>\n    <button\n        class=\"nav-group-trigger\"\n        type=\"button\"\n        [attr.aria-expanded]=\"expanded\"\n        [attr.aria-label]=\"commonStrings.keys.verticalNavGroupToggle\"\n        (click)=\"toggleExpand()\">\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <div class=\"nav-group-text\">\n            <ng-content></ng-content>\n        </div>\n        <clr-icon shape=\"caret\"\n                  class=\"nav-group-trigger-icon\"\n                  [attr.dir]=\"(this.expanded) ? 'down' : 'right'\"\n                  [attr.title]=\"(this.expanded) ? commonStrings.keys.collapse : commonStrings.keys.expand\">\n        </clr-icon>\n    </button>\n</div>\n<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->\n<div class=\"nav-group-children\"\n     [@clrExpand]=\"expandAnimationState\"\n     (@clrExpand.done)=\"expandAnimationDone($event)\">\n    <ng-content select=\"[clrIfExpanded], clr-vertical-nav-group-children\"></ng-content>\n</div>\n",
                providers: [IfExpandService, VerticalNavGroupService],
                animations: [
                    animations.trigger('clrExpand', [
                        animations.state(EXPANDED_STATE, animations.style({ height: '*' })),
                        animations.state(COLLAPSED_STATE, animations.style({ height: 0, 'overflow-y': 'hidden', visibility: 'hidden' })),
                        animations.transition(EXPANDED_STATE + " <=> " + COLLAPSED_STATE, animations.animate('0.2s ease-in-out')),
                    ]),
                ],
                host: { class: 'nav-group' }
            }]
    }], function () { return [{ type: IfExpandService }, { type: VerticalNavGroupRegistrationService }, { type: VerticalNavGroupService }, { type: VerticalNavService }, { type: ClrCommonStringsService }]; }, { expandedChange: [{
            type: core.Output,
            args: ['clrVerticalNavGroupExpandedChange']
        }], expanded: [{
            type: core.HostBinding,
            args: ['class.is-expanded']
        }], userExpandedInput: [{
            type: core.Input,
            args: ['clrVerticalNavGroupExpanded']
        }] }); })();
        return ClrVerticalNavGroup;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrVerticalNavGroupChildren = /** @class */ (function () {
        function ClrVerticalNavGroupChildren() {
        }
ClrVerticalNavGroupChildren.ɵfac = function ClrVerticalNavGroupChildren_Factory(t) { return new (t || ClrVerticalNavGroupChildren)(); };
ClrVerticalNavGroupChildren.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrVerticalNavGroupChildren, selectors: [["clr-vertical-nav-group-children"]], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrVerticalNavGroupChildren_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrVerticalNavGroupChildren, [{
        type: core.Component,
        args: [{
                selector: 'clr-vertical-nav-group-children',
                template: "\n        <ng-content></ng-content>\n    "
            }]
    }], function () { return []; }, null); })();
        return ClrVerticalNavGroupChildren;
    }());

    var ClrVerticalNavIcon = /** @class */ (function () {
        function ClrVerticalNavIcon(_verticalNavIconService) {
            this._verticalNavIconService = _verticalNavIconService;
            this._verticalNavIconService.registerIcon();
        }
        ClrVerticalNavIcon.prototype.ngOnDestroy = function () {
            this._verticalNavIconService.unregisterIcon();
        };
        ClrVerticalNavIcon.ctorParameters = function () { return [
            { type: VerticalNavIconService }
        ]; };
ClrVerticalNavIcon.ɵfac = function ClrVerticalNavIcon_Factory(t) { return new (t || ClrVerticalNavIcon)(ɵngcc0.ɵɵdirectiveInject(VerticalNavIconService)); };
ClrVerticalNavIcon.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrVerticalNavIcon, selectors: [["", "clrVerticalNavIcon", ""]], hostAttrs: [1, "nav-icon"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrVerticalNavIcon, [{
        type: core.Directive,
        args: [{ selector: '[clrVerticalNavIcon]', host: { class: 'nav-icon' } }]
    }], function () { return [{ type: VerticalNavIconService }]; }, null); })();
        return ClrVerticalNavIcon;
    }());

    var ClrVerticalNavLink = /** @class */ (function () {
        function ClrVerticalNavLink(_navGroupService) {
            this._navGroupService = _navGroupService;
        }
        ClrVerticalNavLink.prototype.expandParentNavGroup = function () {
            if (this._navGroupService) {
                this._navGroupService.expand();
            }
        };
        ClrVerticalNavLink.ctorParameters = function () { return [
            { type: VerticalNavGroupService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.HostListener('click')
        ], ClrVerticalNavLink.prototype, "expandParentNavGroup", null);
        ClrVerticalNavLink = __decorate([ __param(0, core.Optional())
        ], ClrVerticalNavLink);
ClrVerticalNavLink.ɵfac = function ClrVerticalNavLink_Factory(t) { return new (t || ClrVerticalNavLink)(ɵngcc0.ɵɵdirectiveInject(VerticalNavGroupService, 8)); };
ClrVerticalNavLink.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrVerticalNavLink, selectors: [["", "clrVerticalNavLink", ""]], hostAttrs: [1, "nav-link"], hostBindings: function ClrVerticalNavLink_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrVerticalNavLink_click_HostBindingHandler() { return ctx.expandParentNavGroup(); });
    } }, attrs: _c78, ngContentSelectors: _c80, decls: 3, vars: 0, consts: [[1, "nav-text"]], template: function ClrVerticalNavLink_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c79);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "span", 0);
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrVerticalNavLink, [{
        type: core.Component,
        args: [{
                selector: '[clrVerticalNavLink]',
                template: "\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <span class=\"nav-text\">\n            <ng-content></ng-content>    \n        </span>\n    ",
                host: { class: 'nav-link' }
            }]
    }], function () { return [{ type: VerticalNavGroupService, decorators: [{
                type: core.Optional
            }] }]; }, { expandParentNavGroup: [{
            type: core.HostListener,
            args: ['click']
        }] }); })();
        return ClrVerticalNavLink;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_VERTICAL_NAV_DIRECTIVES = [
        ClrVerticalNav,
        ClrVerticalNavLink,
        ClrVerticalNavGroup,
        ClrVerticalNavGroupChildren,
        ClrVerticalNavIcon,
    ];
    var ClrVerticalNavModule = /** @class */ (function () {
        function ClrVerticalNavModule() {
        }
ClrVerticalNavModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrVerticalNavModule });
ClrVerticalNavModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrVerticalNavModule_Factory(t) { return new (t || ClrVerticalNavModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule],
        ClrConditionalModule,
        ClrIconModule,
        ClrFocusOnViewInitModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrVerticalNavModule, { declarations: [ClrVerticalNav,
        ClrVerticalNavLink,
        ClrVerticalNavGroup,
        ClrVerticalNavGroupChildren,
        ClrVerticalNavIcon], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrConditionalModule,
        ClrFocusOnViewInitModule], exports: [ClrVerticalNav,
        ClrVerticalNavLink,
        ClrVerticalNavGroup,
        ClrVerticalNavGroupChildren,
        ClrVerticalNavIcon,
        ClrConditionalModule,
        ClrIconModule,
        ClrFocusOnViewInitModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrVerticalNavModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule],
                declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
                exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
            }]
    }], function () { return []; }, null); })();
        return ClrVerticalNavModule;
    }());

    var ClrLayoutModule = /** @class */ (function () {
        function ClrLayoutModule() {
        }
ClrLayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrLayoutModule });
ClrLayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrLayoutModule_Factory(t) { return new (t || ClrLayoutModule)(); }, imports: [ClrMainContainerModule,
        ClrNavigationModule,
        ClrTabsModule,
        ClrVerticalNavModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrLayoutModule, { exports: [ClrMainContainerModule,
        ClrNavigationModule,
        ClrTabsModule,
        ClrVerticalNavModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrLayoutModule, [{
        type: core.NgModule,
        args: [{ exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule] }]
    }], function () { return []; }, null); })();
        return ClrLayoutModule;
    }());

    var ScrollingService = /** @class */ (function () {
        function ScrollingService(_document) {
            this._document = _document;
        }
        ScrollingService.prototype.stopScrolling = function () {
            this._document.body.classList.add('no-scrolling');
        };
        ScrollingService.prototype.resumeScrolling = function () {
            if (this._document.body.classList.contains('no-scrolling')) {
                this._document.body.classList.remove('no-scrolling');
            }
        };
        ScrollingService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        ScrollingService = __decorate([ __param(0, core.Inject(common.DOCUMENT))
        ], ScrollingService);
ScrollingService.ɵfac = function ScrollingService_Factory(t) { return new (t || ScrollingService)(ɵngcc0.ɵɵinject(common.DOCUMENT)); };
ScrollingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScrollingService, factory: function (t) { return ScrollingService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScrollingService, [{
        type: core.Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }]; }, null); })();
        return ScrollingService;
    }());

    var ClrModal = /** @class */ (function () {
        function ClrModal(_scrollingService, commonStrings, modalId) {
            this._scrollingService = _scrollingService;
            this.commonStrings = commonStrings;
            this.modalId = modalId;
            this._open = false;
            this._openChanged = new core.EventEmitter(false);
            this.closable = true;
            this.staticBackdrop = true;
            this.skipAnimation = 'false';
            // presently this is only used by wizards
            this.bypassScrollService = false;
            this.stopClose = false;
            this.altClose = new core.EventEmitter(false);
        }
        // Detect when _open is set to true and set no-scrolling to true
        ClrModal.prototype.ngOnChanges = function (changes) {
            if (!this.bypassScrollService && changes && changes.hasOwnProperty('_open')) {
                if (changes._open.currentValue) {
                    this._scrollingService.stopScrolling();
                }
                else {
                    this._scrollingService.resumeScrolling();
                }
            }
        };
        ClrModal.prototype.ngOnDestroy = function () {
            this._scrollingService.resumeScrolling();
        };
        ClrModal.prototype.open = function () {
            if (this._open) {
                return;
            }
            this._open = true;
            this._openChanged.emit(true);
        };
        ClrModal.prototype.close = function () {
            if (this.stopClose) {
                this.altClose.emit(false);
                return;
            }
            if (!this.closable || !this._open) {
                return;
            }
            this._open = false;
            // SPECME
            this.focusTrap.setPreviousFocus(); // Handles moving focus back to the element that had it before.
        };
        ClrModal.prototype.fadeDone = function (e) {
            if (e.toState === 'void') {
                // TODO: Investigate if we can decouple from animation events
                this._openChanged.emit(false);
            }
        };
        ClrModal.ctorParameters = function () { return [
            { type: ScrollingService },
            { type: ClrCommonStringsService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        __decorate([
            core.ViewChild(FocusTrapDirective)
        ], ClrModal.prototype, "focusTrap", void 0);
        __decorate([
            core.HostBinding('class.open'),
            core.Input('clrModalOpen')
        ], ClrModal.prototype, "_open", void 0);
        __decorate([
            core.Output('clrModalOpenChange')
        ], ClrModal.prototype, "_openChanged", void 0);
        __decorate([
            core.Input('clrModalClosable')
        ], ClrModal.prototype, "closable", void 0);
        __decorate([
            core.Input('clrModalSize')
        ], ClrModal.prototype, "size", void 0);
        __decorate([
            core.Input('clrModalStaticBackdrop')
        ], ClrModal.prototype, "staticBackdrop", void 0);
        __decorate([
            core.Input('clrModalSkipAnimation')
        ], ClrModal.prototype, "skipAnimation", void 0);
        __decorate([
            core.Input('clrModalOverrideScrollService')
        ], ClrModal.prototype, "bypassScrollService", void 0);
        __decorate([
            core.Input('clrModalPreventClose')
        ], ClrModal.prototype, "stopClose", void 0);
        __decorate([
            core.Output('clrModalAlternateClose')
        ], ClrModal.prototype, "altClose", void 0);
        __decorate([
            core.HostListener('body:keyup.escape')
        ], ClrModal.prototype, "close", null);
        ClrModal = __decorate([ __param(2, core.Inject(UNIQUE_ID))
        ], ClrModal);
ClrModal.ɵfac = function ClrModal_Factory(t) { return new (t || ClrModal)(ɵngcc0.ɵɵdirectiveInject(ScrollingService), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrModal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrModal, selectors: [["clr-modal"]], viewQuery: function ClrModal_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(FocusTrapDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.focusTrap = _t.first);
    } }, hostVars: 2, hostBindings: function ClrModal_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.escape", function ClrModal_keyup_escape_HostBindingHandler() { return ctx.close(); }, false, ɵngcc0.ɵɵresolveBody);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("open", ctx._open);
    } }, inputs: { _open: ["clrModalOpen", "_open"], closable: ["clrModalClosable", "closable"], staticBackdrop: ["clrModalStaticBackdrop", "staticBackdrop"], skipAnimation: ["clrModalSkipAnimation", "skipAnimation"], bypassScrollService: ["clrModalOverrideScrollService", "bypassScrollService"], stopClose: ["clrModalPreventClose", "stopClose"], size: ["clrModalSize", "size"] }, outputs: { _openChanged: "clrModalOpenChange", altClose: "clrModalAlternateClose" }, features: [ɵngcc0.ɵɵProvidersFeature([UNIQUE_ID_PROVIDER], [ScrollingService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c82, decls: 1, vars: 1, consts: [["clrFocusTrap", "", "class", "modal", 4, "ngIf"], ["clrFocusTrap", "", 1, "modal"], ["role", "dialog", "aria-modal", "true", 1, "modal-dialog"], [1, "clr-sr-only"], [1, "modal-content-wrapper"], [1, "modal-content"], [1, "modal-header"], ["type", "button", "class", "close", 3, "click", 4, "ngIf"], ["clrFocusOnViewInit", "", 1, "modal-title-wrapper", 3, "id"], ["aria-hidden", "true", 1, "modal-backdrop", 3, "click"], ["type", "button", 1, "close", 3, "click"], ["shape", "close"]], template: function ClrModal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c81);
        ɵngcc0.ɵɵtemplate(0, ClrModal_div_0_Template, 16, 14, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx._open);
    } }, directives: [ɵngcc1.NgIf, FocusTrapDirective,
        ClrFocusOnViewInit,
        ClrIconCustomTag], styles: ["[_nghost-%COMP%] { display: none; }\n        .open[_nghost-%COMP%] { display: inline; }"], data: { animation: [
            animations.trigger('fadeDown', [
                animations.transition('* => false', [animations.style({ opacity: 0, transform: 'translate(0, -25%)' }), animations.animate('0.2s ease-in-out')]),
                animations.transition('false => *', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0, transform: 'translate(0, -25%)' }))]),
            ]),
            animations.trigger('fade', [
                animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate('0.2s ease-in-out', animations.style({ opacity: 0.85 }))]),
                animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0 }))]),
            ]),
        ] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrModal, [{
        type: core.Component,
        args: [{
                selector: 'clr-modal',
                viewProviders: [ScrollingService],
                template: "\n<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div clrFocusTrap class=\"modal\" *ngIf=\"_open\">\n    <!--fixme: revisit when ngClass works with exit animation-->\n    <div [@fadeDown]=\"skipAnimation\" (@fadeDown.done)=\"fadeDone($event)\"\n         class=\"modal-dialog\"\n         [class.modal-sm]=\"size == 'sm'\"\n         [class.modal-lg]=\"size == 'lg'\"\n         [class.modal-xl]=\"size == 'xl'\"\n         role=\"dialog\"\n         aria-modal=\"true\"\n         [attr.aria-hidden]=\"!_open\"\n         [attr.aria-labelledby]=\"modalId\">\n      <div class=\"clr-sr-only\">{{commonStrings.keys.modalContentStart}}</div>\n      <div class=\"modal-content-wrapper\">\n        <!-- only used in wizards -->\n        <ng-content select=\".modal-nav\"></ng-content>\n\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" [attr.aria-label]=\"commonStrings.keys.close\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n              <clr-icon shape=\"close\"></clr-icon>\n            </button>\n            <div class=\"modal-title-wrapper\" id=\"{{modalId}}\" clrFocusOnViewInit>\n              <ng-content select=\".modal-title\"></ng-content>\n            </div>\n          </div>\n          <ng-content select=\".modal-body\"></ng-content>\n          <ng-content select=\".modal-footer\"></ng-content>\n        </div>\n      </div>\n      <div class=\"clr-sr-only\">{{commonStrings.keys.modalContentEnd}}</div>\n    </div>\n\n    <div [@fade] class=\"modal-backdrop\"\n         aria-hidden=\"true\"\n         (click)=\"staticBackdrop || close()\"></div>\n</div>\n\n",
                animations: [
                    animations.trigger('fadeDown', [
                        animations.transition('* => false', [animations.style({ opacity: 0, transform: 'translate(0, -25%)' }), animations.animate('0.2s ease-in-out')]),
                        animations.transition('false => *', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0, transform: 'translate(0, -25%)' }))]),
                    ]),
                    animations.trigger('fade', [
                        animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate('0.2s ease-in-out', animations.style({ opacity: 0.85 }))]),
                        animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0 }))]),
                    ]),
                ],
                providers: [UNIQUE_ID_PROVIDER],
                styles: ["\n        :host { display: none; }\n        :host.open { display: inline; }\n    "]
            }]
    }], function () { return [{ type: ScrollingService }, { type: ClrCommonStringsService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, { _open: [{
            type: core.HostBinding,
            args: ['class.open']
        }, {
            type: core.Input,
            args: ['clrModalOpen']
        }], _openChanged: [{
            type: core.Output,
            args: ['clrModalOpenChange']
        }], closable: [{
            type: core.Input,
            args: ['clrModalClosable']
        }], staticBackdrop: [{
            type: core.Input,
            args: ['clrModalStaticBackdrop']
        }], skipAnimation: [{
            type: core.Input,
            args: ['clrModalSkipAnimation']
        }], bypassScrollService: [{
            type: core.Input,
            args: ['clrModalOverrideScrollService']
        }], stopClose: [{
            type: core.Input,
            args: ['clrModalPreventClose']
        }], altClose: [{
            type: core.Output,
            args: ['clrModalAlternateClose']
        }], close: [{
            type: core.HostListener,
            args: ['body:keyup.escape']
        }], focusTrap: [{
            type: core.ViewChild,
            args: [FocusTrapDirective]
        }], size: [{
            type: core.Input,
            args: ['clrModalSize']
        }] }); })();
        return ClrModal;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Allows modal overflow area to be scrollable via keyboard.
     * The modal body will focus with keyboard navigation only.
     * This allows inner focusable items to be focused without
     * the overflow scroll being focused.
     */
    var ClrModalBody = /** @class */ (function () {
        function ClrModalBody() {
            this.tabindex = 0;
        }
        ClrModalBody.prototype.mouseDown = function () {
            // tabindex = 0 binding should be removed
            // so it won't be focused when click starts with mousedown
            delete this.tabindex;
        };
        ClrModalBody.prototype.mouseUp = function () {
            // set the tabindex binding back when click is completed with mouseup
            this.tabindex = 0;
        };
        __decorate([
            core.HostListener('mousedown')
        ], ClrModalBody.prototype, "mouseDown", null);
        __decorate([
            core.HostListener('mouseup')
        ], ClrModalBody.prototype, "mouseUp", null);
ClrModalBody.ɵfac = function ClrModalBody_Factory(t) { return new (t || ClrModalBody)(); };
ClrModalBody.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrModalBody, selectors: [["", 8, "modal-body"]], hostVars: 1, hostBindings: function ClrModalBody_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function ClrModalBody_mousedown_HostBindingHandler() { return ctx.mouseDown(); })("mouseup", function ClrModalBody_mouseup_HostBindingHandler() { return ctx.mouseUp(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrModalBody, [{
        type: core.Directive,
        args: [{
                selector: '.modal-body',
                host: {
                    '[attr.tabindex]': 'tabindex'
                }
            }]
    }], function () { return []; }, { mouseDown: [{
            type: core.HostListener,
            args: ['mousedown']
        }], mouseUp: [{
            type: core.HostListener,
            args: ['mouseup']
        }] }); })();
        return ClrModalBody;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_MODAL_DIRECTIVES = [ClrModal, ClrModalBody];
    var ClrModalModule = /** @class */ (function () {
        function ClrModalModule() {
        }
ClrModalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrModalModule });
ClrModalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrModalModule_Factory(t) { return new (t || ClrModalModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrFocusTrapModule, ClrFocusOnViewInitModule],
        ClrIconModule,
        ClrFocusOnViewInitModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrModalModule, { declarations: [ClrModal,
        ClrModalBody], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrFocusTrapModule,
        ClrFocusOnViewInitModule], exports: [ClrModal,
        ClrModalBody,
        ClrIconModule,
        ClrFocusOnViewInitModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrModalModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrFocusTrapModule, ClrFocusOnViewInitModule],
                declarations: [CLR_MODAL_DIRECTIVES],
                exports: [CLR_MODAL_DIRECTIVES, ClrIconModule, ClrFocusOnViewInitModule]
            }]
    }], function () { return []; }, null); })();
        return ClrModalModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var SIGNPOST_POSITIONS = {
        'top-left': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_RIGHT, offsetY: -10, offsetX: 0 },
        'top-middle': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_CENTER, offsetY: -10, offsetX: 0 },
        'top-right': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_LEFT, offsetY: -10, offsetX: 0 },
        'right-top': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_BOTTOM, offsetY: 2, offsetX: 14 },
        'right-middle': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
        'right-bottom': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_TOP, offsetY: -1, offsetX: 14 },
        'bottom-right': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_LEFT, offsetY: 9, offsetX: -1 },
        'bottom-middle': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_CENTER, offsetY: 9, offsetX: 12 },
        'bottom-left': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_RIGHT, offsetY: 9, offsetX: 0 },
        'left-bottom': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_TOP, offsetY: 0, offsetX: -14 },
        'left-middle': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_CENTER, offsetY: 4, offsetX: -14 },
        'left-top': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_BOTTOM, offsetY: 0, offsetX: -14 },
        default: { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
    };

    // aka where the arrow / pointer is at in relation to the anchor
    var POSITIONS = [
        'top-left',
        'top-middle',
        'top-right',
        'right-top',
        'right-middle',
        'right-bottom',
        'bottom-right',
        'bottom-middle',
        'bottom-left',
        'left-bottom',
        'left-middle',
        'left-top',
    ];
    var ClrSignpostContent = /** @class */ (function (_super) {
        __extends(ClrSignpostContent, _super);
        function ClrSignpostContent(injector, parentHost, commonStrings, signpostContentId, signpostIdService, signpostFocusManager, platformId, document) {
            var _this = _super.call(this, injector, parentHost) || this;
            _this.commonStrings = commonStrings;
            _this.signpostContentId = signpostContentId;
            _this.signpostIdService = signpostIdService;
            _this.signpostFocusManager = signpostFocusManager;
            _this.platformId = platformId;
            if (!parentHost) {
                throw new Error('clr-signpost-content should only be used inside of a clr-signpost');
            }
            // Defaults
            _this.position = 'right-middle';
            _this.closeOnOutsideClick = true;
            _this.signpostIdService.setId(signpostContentId);
            _this.document = document;
            return _this;
        }
        /**********
         *
         * @description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         */
        ClrSignpostContent.prototype.close = function () {
            this.toggleService.open = false;
        };
        Object.defineProperty(ClrSignpostContent.prototype, "position", {
            get: function () {
                return this._position;
            },
            /*********
             *
             * @description
             * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
             * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
             * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
             * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
             * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
             * There are 12 possible positions to place a ClrSignpostContent container:
             * - top-left
             * - top-middle
             * - top-right
             * - right-top
             * - right-middle
             * - right-bottom
             * - bottom-right
             * - bottom-middle
             * - bottom-left
             * - left-bottom
             * - left-middle
             * - left-top
             *
             * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
             * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
             * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
             * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
             *
             * @param newPosition
             */
            set: function (position) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, this.position);
                if (position && POSITIONS.indexOf(position) > -1) {
                    this._position = position;
                }
                else {
                    this._position = 'right-middle';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, this.position);
                var setPosition = SIGNPOST_POSITIONS[this.position];
                this.anchorPoint = setPosition.anchorPoint;
                this.popoverPoint = setPosition.popoverPoint;
                this.popoverOptions.offsetY = setPosition.offsetY;
                this.popoverOptions.offsetX = setPosition.offsetX;
            },
            enumerable: true,
            configurable: true
        });
        ClrSignpostContent.prototype.ngOnDestroy = function () {
            if (common.isPlatformBrowser(this.platformId) && this.el.nativeElement.contains(this.document.activeElement)) {
                this.signpostFocusManager.focusTrigger();
            }
        };
        ClrSignpostContent.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ElementRef, decorators: [{ type: core.Optional }, { type: core.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
            { type: ClrCommonStringsService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: SignpostIdService },
            { type: SignpostFocusManager },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        __decorate([
            core.Input('clrPosition')
        ], ClrSignpostContent.prototype, "position", null);
        ClrSignpostContent = __decorate([ __param(1, core.Optional()),
            __param(1, core.Inject(POPOVER_HOST_ANCHOR)),
            __param(3, core.Inject(UNIQUE_ID)),
            __param(6, core.Inject(core.PLATFORM_ID)),
            __param(7, core.Inject(common.DOCUMENT))
        ], ClrSignpostContent);
ClrSignpostContent.ɵfac = function ClrSignpostContent_Factory(t) { return new (t || ClrSignpostContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(SignpostIdService), ɵngcc0.ɵɵdirectiveInject(SignpostFocusManager), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT)); };
ClrSignpostContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrSignpostContent, selectors: [["clr-signpost-content"]], hostVars: 3, hostBindings: function ClrSignpostContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.signpostContentId);
        ɵngcc0.ɵɵclassProp("signpost-content", true);
    } }, inputs: { position: ["clrPosition", "position"] }, features: [ɵngcc0.ɵɵProvidersFeature([UNIQUE_ID_PROVIDER]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 7, vars: 3, consts: [[1, "signpost-wrap"], [1, "popover-pointer"], [1, "signpost-content-header"], ["type", "button", 1, "signpost-action", "close", 3, "click"], ["shape", "close"], [1, "signpost-content-body"]], template: function ClrSignpostContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵlistener("click", function ClrSignpostContent_Template_button_click_3_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelement(4, "clr-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵattribute("aria-label", ctx.commonStrings.keys.signpostClose)("aria-controls", ctx.signpostContentId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("title", ctx.commonStrings.keys.close);
    } }, directives: [ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSignpostContent, [{
        type: core.Component,
        args: [{
                selector: 'clr-signpost-content',
                template: "\n      <div class=\"signpost-wrap\">\n          <div class=\"popover-pointer\"></div>\n          <div class=\"signpost-content-header\">\n              <button type=\"button\" [attr.aria-label]=\"commonStrings.keys.signpostClose\" class=\"signpost-action close\"\n                      (click)=\"close()\" [attr.aria-controls]=\"signpostContentId\">\n                  <clr-icon shape=\"close\" [attr.title]=\"commonStrings.keys.close\"></clr-icon>\n              </button>\n          </div>\n          <div class=\"signpost-content-body\">\n              <ng-content></ng-content>\n          </div>\n      </div>\n  ",
                host: { '[class.signpost-content]': 'true', '[id]': 'signpostContentId' },
                providers: [UNIQUE_ID_PROVIDER]
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [POPOVER_HOST_ANCHOR]
            }] }, { type: ClrCommonStringsService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: SignpostIdService }, { type: SignpostFocusManager }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }]; }, { position: [{
            type: core.Input,
            args: ['clrPosition']
        }] }); })();
        return ClrSignpostContent;
    }(AbstractPopover));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger];
    var ClrSignpostModule = /** @class */ (function () {
        function ClrSignpostModule() {
        }
ClrSignpostModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrSignpostModule });
ClrSignpostModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrSignpostModule_Factory(t) { return new (t || ClrSignpostModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrFocusOnViewInitModule],
        ClrConditionalModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrSignpostModule, { declarations: [ClrSignpost,
        ClrSignpostContent,
        ClrSignpostTrigger], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrFocusOnViewInitModule], exports: [ClrSignpost,
        ClrSignpostContent,
        ClrSignpostTrigger,
        ClrConditionalModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrSignpostModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrFocusOnViewInitModule],
                declarations: [CLR_SIGNPOST_DIRECTIVES],
                exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule]
            }]
    }], function () { return []; }, null); })();
        return ClrSignpostModule;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var TooltipIdService = /** @class */ (function () {
        function TooltipIdService() {
            this._id = new rxjs.Subject();
        }
        TooltipIdService.prototype.updateId = function (id) {
            this._id.next(id);
        };
        Object.defineProperty(TooltipIdService.prototype, "id", {
            get: function () {
                return this._id.asObservable();
            },
            enumerable: true,
            configurable: true
        });
TooltipIdService.ɵfac = function TooltipIdService_Factory(t) { return new (t || TooltipIdService)(); };
TooltipIdService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipIdService, factory: function (t) { return TooltipIdService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipIdService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return TooltipIdService;
    }());

    var ClrTooltip = /** @class */ (function () {
        function ClrTooltip() {
        }
ClrTooltip.ɵfac = function ClrTooltip_Factory(t) { return new (t || ClrTooltip)(); };
ClrTooltip.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTooltip, selectors: [["clr-tooltip"]], hostVars: 2, hostBindings: function ClrTooltip_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("tooltip", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            ClrPopoverToggleService,
            { provide: POPOVER_HOST_ANCHOR, useExisting: core.ElementRef },
            // TODO: consider centralizing the unique id string on a service that provides ariaAttributes that need it
            // AriaService in layout/tabs/providers might be a good starting point.
            UNIQUE_ID_PROVIDER,
            TooltipIdService,
        ])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTooltip_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTooltip, [{
        type: core.Component,
        args: [{
                selector: 'clr-tooltip',
                template: "\n        <ng-content></ng-content>\n    ",
                host: {
                    '[class.tooltip]': 'true'
                },
                providers: [
                    ClrPopoverToggleService,
                    { provide: POPOVER_HOST_ANCHOR, useExisting: core.ElementRef },
                    // TODO: consider centralizing the unique id string on a service that provides ariaAttributes that need it
                    // AriaService in layout/tabs/providers might be a good starting point.
                    UNIQUE_ID_PROVIDER,
                    TooltipIdService,
                ]
            }]
    }], function () { return []; }, null); })();
        return ClrTooltip;
    }());

    var POSITIONS$1 = ['bottom-left', 'bottom-right', 'top-left', 'top-right', 'right', 'left'];
    var SIZES = ['xs', 'sm', 'md', 'lg'];
    var ClrTooltipContent = /** @class */ (function (_super) {
        __extends(ClrTooltipContent, _super);
        function ClrTooltipContent(injector, parentHost, uniqueId, tooltipIdService) {
            var _this = _super.call(this, injector, parentHost) || this;
            _this.uniqueId = uniqueId;
            _this.tooltipIdService = tooltipIdService;
            if (!parentHost) {
                throw new Error('clr-tooltip-content should only be used inside of a clr-tooltip');
            }
            // Defaults
            _this.position = 'right';
            _this.size = 'sm';
            // Set the default id in case consumer does not supply a custom id.
            _this.updateId(uniqueId);
            return _this;
        }
        Object.defineProperty(ClrTooltipContent.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.position);
                if (position && POSITIONS$1.indexOf(position) > -1) {
                    this._position = position;
                }
                else {
                    this._position = 'right';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.position);
                // set the popover values based on direction
                switch (position) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_CENTER;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_CENTER;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_CENTER;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'right':
                        this.anchorPoint = Point.RIGHT_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'left':
                        this.anchorPoint = Point.LEFT_CENTER;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    default:
                        this.anchorPoint = Point.RIGHT_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTooltipContent.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                value ? this.updateId(value) : this.updateId('');
            },
            enumerable: true,
            configurable: true
        });
        ClrTooltipContent.prototype.updateId = function (id) {
            this._id = id;
            this.tooltipIdService.updateId(id);
        };
        Object.defineProperty(ClrTooltipContent.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.size);
                if (size && SIZES.indexOf(size) > -1) {
                    this._size = size;
                }
                else {
                    this._size = 'sm';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.size);
            },
            enumerable: true,
            configurable: true
        });
        ClrTooltipContent.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ElementRef, decorators: [{ type: core.Optional }, { type: core.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] },
            { type: TooltipIdService }
        ]; };
        __decorate([
            core.Input()
        ], ClrTooltipContent.prototype, "id", null);
        __decorate([
            core.Input('clrPosition')
        ], ClrTooltipContent.prototype, "position", null);
        __decorate([
            core.Input('clrSize')
        ], ClrTooltipContent.prototype, "size", null);
        ClrTooltipContent = __decorate([ __param(1, core.Optional()),
            __param(1, core.Inject(POPOVER_HOST_ANCHOR)),
            __param(2, core.Inject(UNIQUE_ID))
        ], ClrTooltipContent);
ClrTooltipContent.ɵfac = function ClrTooltipContent_Factory(t) { return new (t || ClrTooltipContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID), ɵngcc0.ɵɵdirectiveInject(TooltipIdService)); };
ClrTooltipContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTooltipContent, selectors: [["clr-tooltip-content"]], hostVars: 6, hostBindings: function ClrTooltipContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
        ɵngcc0.ɵɵattribute("role", "tooltip");
        ɵngcc0.ɵɵstyleProp("opacity", 1);
        ɵngcc0.ɵɵclassProp("tooltip-content", true);
    } }, inputs: { position: ["clrPosition", "position"], id: "id", size: ["clrSize", "size"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTooltipContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTooltipContent, [{
        type: core.Component,
        args: [{
                selector: 'clr-tooltip-content',
                template: "\n        <ng-content></ng-content>\n    ",
                host: {
                    '[class.tooltip-content]': 'true',
                    '[style.opacity]': '1',
                    '[attr.role]': '"tooltip"',
                    '[id]': 'id'
                }
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [POPOVER_HOST_ANCHOR]
            }] }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }, { type: TooltipIdService }]; }, { position: [{
            type: core.Input,
            args: ['clrPosition']
        }], id: [{
            type: core.Input
        }], size: [{
            type: core.Input,
            args: ['clrSize']
        }] }); })();
        return ClrTooltipContent;
    }(AbstractPopover));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTooltipTrigger = /** @class */ (function () {
        function ClrTooltipTrigger(toggleService, tooltipIdService) {
            var _this = this;
            this.toggleService = toggleService;
            this.tooltipIdService = tooltipIdService;
            this.subs = [];
            // The aria-described by comes from the id of content. It
            this.subs.push(this.tooltipIdService.id.subscribe(function (tooltipId) { return (_this.ariaDescribedBy = tooltipId); }));
        }
        ClrTooltipTrigger.prototype.showTooltip = function () {
            this.toggleService.open = true;
        };
        ClrTooltipTrigger.prototype.hideTooltip = function () {
            this.toggleService.open = false;
        };
        ClrTooltipTrigger.prototype.ngOnDestroy = function () {
            this.subs.forEach(function (sub) { return sub.unsubscribe(); });
        };
        ClrTooltipTrigger.ctorParameters = function () { return [
            { type: ClrPopoverToggleService },
            { type: TooltipIdService }
        ]; };
        __decorate([
            core.HostListener('mouseenter'),
            core.HostListener('focus')
        ], ClrTooltipTrigger.prototype, "showTooltip", null);
        __decorate([
            core.HostListener('mouseleave'),
            core.HostListener('blur')
        ], ClrTooltipTrigger.prototype, "hideTooltip", null);
ClrTooltipTrigger.ɵfac = function ClrTooltipTrigger_Factory(t) { return new (t || ClrTooltipTrigger)(ɵngcc0.ɵɵdirectiveInject(ClrPopoverToggleService), ɵngcc0.ɵɵdirectiveInject(TooltipIdService)); };
ClrTooltipTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrTooltipTrigger, selectors: [["", "clrTooltipTrigger", ""]], hostAttrs: ["tabindex", "0"], hostVars: 4, hostBindings: function ClrTooltipTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function ClrTooltipTrigger_mouseenter_HostBindingHandler() { return ctx.showTooltip(); })("focus", function ClrTooltipTrigger_focus_HostBindingHandler() { return ctx.showTooltip(); })("mouseleave", function ClrTooltipTrigger_mouseleave_HostBindingHandler() { return ctx.hideTooltip(); })("blur", function ClrTooltipTrigger_blur_HostBindingHandler() { return ctx.hideTooltip(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.ariaDescribedBy)("role", "button");
        ɵngcc0.ɵɵclassProp("tooltip-trigger", true);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTooltipTrigger, [{
        type: core.Directive,
        args: [{
                selector: '[clrTooltipTrigger]',
                host: {
                    tabindex: '0',
                    '[class.tooltip-trigger]': 'true',
                    '[attr.aria-describedby]': 'ariaDescribedBy',
                    '[attr.role]': '"button"'
                }
            }]
    }], function () { return [{ type: ClrPopoverToggleService }, { type: TooltipIdService }]; }, { showTooltip: [{
            type: core.HostListener,
            args: ['mouseenter']
        }, {
            type: core.HostListener,
            args: ['focus']
        }], hideTooltip: [{
            type: core.HostListener,
            args: ['mouseleave']
        }, {
            type: core.HostListener,
            args: ['blur']
        }] }); })();
        return ClrTooltipTrigger;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
    var ClrTooltipModule = /** @class */ (function () {
        function ClrTooltipModule() {
        }
ClrTooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrTooltipModule });
ClrTooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrTooltipModule_Factory(t) { return new (t || ClrTooltipModule)(); }, imports: [[common.CommonModule],
        ClrConditionalModule,
        ClrIconModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrTooltipModule, { declarations: [ClrTooltip,
        ClrTooltipTrigger,
        ClrTooltipContent], imports: [ɵngcc1.CommonModule], exports: [ClrTooltip,
        ClrTooltipTrigger,
        ClrTooltipContent,
        ClrConditionalModule,
        ClrIconModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTooltipModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [CLR_TOOLTIP_DIRECTIVES],
                exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule]
            }]
    }], function () { return []; }, null); })();
        return ClrTooltipModule;
    }());

    var ClrPopoverModule = /** @class */ (function () {
        function ClrPopoverModule() {
        }
ClrPopoverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrPopoverModule });
ClrPopoverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrPopoverModule_Factory(t) { return new (t || ClrPopoverModule)(); }, imports: [ClrDropdownModule,
        ClrSignpostModule,
        ClrTooltipModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrPopoverModule, { exports: [ClrDropdownModule,
        ClrSignpostModule,
        ClrTooltipModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrPopoverModule, [{
        type: core.NgModule,
        args: [{ exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule] }]
    }], function () { return []; }, null); })();
        return ClrPopoverModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ButtonHubService = /** @class */ (function () {
        function ButtonHubService() {
            this.buttonsReady = false;
            this._previousBtnClicked = new rxjs.Subject();
            this._nextBtnClicked = new rxjs.Subject();
            this._dangerBtnClicked = new rxjs.Subject();
            this._cancelBtnClicked = new rxjs.Subject();
            this._finishBtnClicked = new rxjs.Subject();
            this._customBtnClicked = new rxjs.Subject();
        }
        Object.defineProperty(ButtonHubService.prototype, "previousBtnClicked", {
            get: function () {
                return this._previousBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "nextBtnClicked", {
            get: function () {
                return this._nextBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "dangerBtnClicked", {
            get: function () {
                return this._dangerBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "cancelBtnClicked", {
            get: function () {
                return this._cancelBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "finishBtnClicked", {
            get: function () {
                return this._finishBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "customBtnClicked", {
            get: function () {
                return this._customBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        ButtonHubService.prototype.buttonClicked = function (buttonType) {
            if ('previous' === buttonType) {
                this._previousBtnClicked.next();
            }
            else if ('next' === buttonType) {
                this._nextBtnClicked.next();
            }
            else if ('finish' === buttonType) {
                this._finishBtnClicked.next();
            }
            else if ('danger' === buttonType) {
                this._dangerBtnClicked.next();
            }
            else if ('cancel' === buttonType) {
                this._cancelBtnClicked.next();
            }
            else {
                this._customBtnClicked.next(buttonType);
            }
        };
ButtonHubService.ɵfac = function ButtonHubService_Factory(t) { return new (t || ButtonHubService)(); };
ButtonHubService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ButtonHubService, factory: function (t) { return ButtonHubService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ButtonHubService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ButtonHubService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * PageCollectionService manages the collection of pages assigned to the wizard and offers
     * a number of functions useful across the wizards providers and subcomponents -- all related
     * to essentially lookups on the collection of pages.
     *
     * The easiest way to access PageCollectionService is via the wizard. The
     * following example would allow you to access your instance of the wizard from your host
     * component and thereby access the page collection via YourHostComponent.wizard.pageCollection.
     *
     * @example
     * <clr-wizard #wizard ...>
     *
     * @example
     * export class YourHostComponent {
     *   @ViewChild("wizard") wizard: Wizard;
     *   ...
     * }
     *
     * The heart of the page collection is the query list of pages, which it is assigned as a
     * reference to the Wizard.pages QueryList when the wizard is created.
     *
     */
    var PageCollectionService = /** @class */ (function () {
        function PageCollectionService() {
            // used by the navService to navigate back to first possible step after
            // pages are reset
            /**
             *
             * @memberof PageCollectionService
             */
            this._pagesReset = new rxjs.Subject();
        }
        Object.defineProperty(PageCollectionService.prototype, "pagesAsArray", {
            /**
             * Converts the PageCollectionService.pages QueryList to an array and returns it.
             *
             * Useful for many instances when you would prefer a QueryList to act like an array.
             *
             * @memberof PageCollectionService
             */
            get: function () {
                return this.pages ? this.pages.toArray() : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "pagesCount", {
            /**
             * Returns the length of the pages query list.
             *
             * @memberof PageCollectionService
             */
            get: function () {
                return this.pages ? this.pages.length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "penultimatePage", {
            /**
             * Returns the next-to-last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: function () {
                var pageCount = this.pagesCount;
                if (pageCount < 2) {
                    return;
                }
                return this.pagesAsArray[pageCount - 2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "lastPage", {
            /**
             * Returns the last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: function () {
                var pageCount = this.pagesCount;
                if (pageCount < 1) {
                    return;
                }
                return this.pagesAsArray[pageCount - 1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "firstPage", {
            /**
             * Returns the first page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: function () {
                if (!this.pagesCount) {
                    return;
                }
                return this.pagesAsArray[0];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getPageById = function (id) {
            var foundPages = this.pages.filter(function (page) { return id === page.id; });
            return this.checkResults(foundPages, id);
        };
        /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getPageByIndex = function (index) {
            var pageCount = this.pagesCount;
            var pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
            if (index < 0) {
                throw new Error('Cannot retrieve page with index of ' + index);
            }
            if (index > pagesLastIndex) {
                throw new Error('Page index is greater than length of pages array.');
            }
            return this.pagesAsArray[index];
        };
        /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getPageIndex = function (page) {
            var index = this.pagesAsArray.indexOf(page);
            if (index < 0) {
                throw new Error('Requested page cannot be found in collection of pages.');
            }
            return index;
        };
        /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.checkResults = function (results, requestedPageId) {
            var foundPagesCount = results.length || 0;
            if (foundPagesCount > 1) {
                throw new Error('More than one page has the requested id ' + requestedPageId + '.');
            }
            else if (foundPagesCount < 1) {
                throw new Error('No page can be found with the id ' + requestedPageId + '.');
            }
            else {
                return results[0];
            }
        };
        /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.pageRange = function (start, end) {
            var pages = [];
            if (start < 0 || end < 0) {
                return [];
            }
            if (start === null || typeof start === 'undefined' || isNaN(start)) {
                return [];
            }
            if (end === null || typeof end === 'undefined' || isNaN(end)) {
                return [];
            }
            if (end > this.pagesCount) {
                end = this.pagesCount;
            }
            pages = this.pagesAsArray;
            if (end - start === 0) {
                // just return the one page they want
                return [this.getPageByIndex(start)];
            }
            // slice end does not include item referenced by end index, which is weird for users
            // incrementing end index here to correct that so users and other methods
            // don't have to think about it
            end = end + 1;
            // slice does not return the last one in the range but it does include the first one
            // does not modify original array
            return pages.slice(start, end);
        };
        /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getPageRangeFromPages = function (page, otherPage) {
            var pageIndex = this.getPageIndex(page);
            var otherPageIndex = this.getPageIndex(otherPage);
            var startIndex;
            var endIndex;
            if (pageIndex <= otherPageIndex) {
                startIndex = pageIndex;
                endIndex = otherPageIndex;
            }
            else {
                startIndex = otherPageIndex;
                endIndex = pageIndex;
            }
            return this.pageRange(startIndex, endIndex);
        };
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getPreviousPage = function (page) {
            var myPageIndex = this.getPageIndex(page);
            var previousPageIndex = myPageIndex - 1;
            if (previousPageIndex < 0) {
                return null;
            }
            return this.getPageByIndex(previousPageIndex);
        };
        /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.previousPageIsCompleted = function (page) {
            var previousPage;
            if (!page) {
                return false;
            }
            previousPage = this.getPreviousPage(page);
            if (null === previousPage) {
                // page is the first page. no previous page.
                return true;
            }
            return previousPage.completed;
        };
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getNextPage = function (page) {
            var myPageIndex = this.getPageIndex(page);
            var nextPageIndex = myPageIndex + 1;
            if (nextPageIndex >= this.pagesAsArray.length) {
                return null;
            }
            return this.getPageByIndex(nextPageIndex);
        };
        /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.getStepItemIdForPage = function (page) {
            var pageId = page.id;
            var pageIdParts = pageId.split('-').reverse();
            pageIdParts[1] = 'step';
            return pageIdParts.reverse().join('-');
        };
        /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.commitPage = function (page) {
            var pageHasOverrides = page.stopNext || page.preventDefault;
            page.completed = true;
            if (!pageHasOverrides) {
                // prevent loop of event emission; alternate flows work off
                // of event emitters this is how they break that cycle.
                page.onCommit.emit(page.id);
            }
        };
        Object.defineProperty(PageCollectionService.prototype, "pagesReset", {
            /**
             * An observable that the navigation service listens to in order to know when
             * the page collection completed states have been reset to false so that way it
             * can also reset the navigation to make the first page in the page collection
             * current/active.
             *
             * @memberof PageCollectionService
             */
            get: function () {
                return this._pagesReset.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.reset = function () {
            this.pagesAsArray.forEach(function (page) {
                page.completed = false;
            });
            this._pagesReset.next(true);
        };
        /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.updateCompletedStates = function () {
            var firstIncompleteIndex = this.findFirstIncompletePageIndex();
            if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
                // all complete no need to do anything
                return;
            }
            this.pagesAsArray.forEach(function (page, index) {
                if (index > firstIncompleteIndex) {
                    page.completed = false;
                }
            });
        };
        /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * @memberof PageCollectionService
         */
        PageCollectionService.prototype.findFirstIncompletePageIndex = function () {
            var returnIndex = null;
            this.pagesAsArray.forEach(function (page, index) {
                if (null === returnIndex && false === page.completed) {
                    returnIndex = index;
                }
            });
            // fallthrough, all completed, return last page
            if (null === returnIndex) {
                returnIndex = this.pagesCount - 1;
            }
            return returnIndex;
        };
        PageCollectionService.prototype.findFirstIncompletePage = function () {
            var myIncompleteIndex = this.findFirstIncompletePageIndex();
            return this.pagesAsArray[myIncompleteIndex];
        };
PageCollectionService.ɵfac = function PageCollectionService_Factory(t) { return new (t || PageCollectionService)(); };
PageCollectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PageCollectionService, factory: function (t) { return PageCollectionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PageCollectionService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return PageCollectionService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Performs navigation functions for a wizard and manages the current page. Presented as a
     * separate service to encapsulate the behavior of navigating and completing the wizard so
     * that it can be shared across the wizard and its sub-components.
     *
     * The easiest way to access the navigation service is there a reference on your wizard. The
     * Following example would allow you to access your instance of the wizard from your host
     * component and thereby access the navigation service via YourHostComponent.wizard.navService.
     *
     * @example
     * <clr-wizard #wizard ...>
     *
     * @example
     * export class YourHostComponent {
     *   @ViewChild("wizard") wizard: Wizard;
     *   ...
     * }
     *
     */
    var WizardNavigationService = /** @class */ (function () {
        /**
         * Creates an instance of WizardNavigationService. Also sets up subscriptions
         * that listen to the button service to determine when a button has been clicked
         * in the wizard. Is also responsible for taking action when the page collection
         * requests that navigation be reset to its pristine state.
         *
         * @memberof WizardNavigationService
         */
        function WizardNavigationService(pageCollection, buttonService) {
            var _this = this;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            /**
             *
             * @memberof WizardNavigationService
             */
            this._currentChanged = new rxjs.Subject();
            /**
             * A Boolean flag used by the ClrWizardPage to avoid a race condition when pages are
             * loading and there is no current page defined.
             *
             * @memberof WizardNavigationService
             */
            this.navServiceLoaded = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.forceForward (clrWizardForceForwardNavigation) input. When true,
             * navigating backwards in the stepnav menu will reset any skipped pages' completed
             * state to false.
             *
             * This is useful when a wizard executes validation on a page-by-page basis when
             * the next button is clicked.
             *
             * @memberof WizardNavigationService
             */
            this.forceForwardNavigation = false;
            /**
             * @memberof WizardNavigationService
             */
            this._movedToNextPage = new rxjs.Subject();
            /**
             * @memberof WizardNavigationService
             */
            this._wizardFinished = new rxjs.Subject();
            /**
             * @memberof WizardNavigationService
             */
            this._movedToPreviousPage = new rxjs.Subject();
            /**
             * @memberof WizardNavigationService
             */
            this._cancelWizard = new rxjs.Subject();
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopCancel (clrWizardPreventDefaultCancel) input. When true, the cancel
             * routine is subverted and must be reinstated in the host component calling Wizard.close()
             * at some point.
             *
             * @memberof WizardNavigationService
             */
            this.wizardHasAltCancel = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopNext (clrWizardPreventDefaultNext) input. When true, the next and finish
             * routines are subverted and must be reinstated in the host component calling Wizard.next(),
             * Wizard.forceNext(), Wizard.finish(), or Wizard.forceFinish().
             *
             * @memberof WizardNavigationService
             */
            this.wizardHasAltNext = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopNavigation (clrWizardPreventNavigation) input. When true, all
             * navigational elements in the wizard are disabled.
             *
             * This is intended to freeze the wizard in place. Events are not fired so this is
             * not a way to implement alternate functionality for navigation.
             *
             * @memberof WizardNavigationService
             */
            this.wizardStopNavigation = false;
            /**
             * A boolean flag shared with the stepnav items that prevents user clicks on
             * stepnav items from navigating the wizard.
             *
             * @memberof WizardNavigationService
             */
            this.wizardDisableStepnav = false;
            this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(function () {
                var currentPage = _this.currentPage;
                if (_this.currentPageIsFirst || currentPage.previousStepDisabled) {
                    return;
                }
                currentPage.previousButtonClicked.emit(currentPage);
                if (!currentPage.preventDefault) {
                    _this.previous();
                }
            });
            this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('next');
            });
            this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('danger');
            });
            this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('finish');
            });
            this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe(function (type) {
                if (!_this.wizardStopNavigation) {
                    _this.currentPage.customButtonClicked.emit(type);
                }
            });
            this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(function () {
                if (_this.wizardStopNavigation) {
                    return;
                }
                if (_this.currentPage.preventDefault) {
                    _this.currentPage.pageOnCancel.emit(_this.currentPage);
                }
                else {
                    _this.cancel();
                }
            });
            this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(function () {
                _this.setFirstPageCurrent();
            });
        }
        /**
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.ngOnDestroy = function () {
            this.previousButtonSubscription.unsubscribe();
            this.nextButtonSubscription.unsubscribe();
            this.dangerButtonSubscription.unsubscribe();
            this.finishButtonSubscription.unsubscribe();
            this.customButtonSubscription.unsubscribe();
            this.cancelButtonSubscription.unsubscribe();
            this.pagesResetSubscription.unsubscribe();
        };
        Object.defineProperty(WizardNavigationService.prototype, "currentPageChanged", {
            /**
             * An Observable that is predominantly used amongst the subcomponents and services
             * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
             * (clrWizardPageOnLoad) output instead of this Observable.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
                // A BREAKING CHANGE SO AWAITING MINOR RELEASE
                return this._currentChanged.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageTitle", {
            /**
             * @memberof WizardNavigationService
             */
            get: function () {
                // when the querylist of pages is empty. this is the first place it fails...
                if (!this.currentPage) {
                    return null;
                }
                return this.currentPage.title;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageIsFirst", {
            /**
             * Returns a Boolean that tells you whether or not the current page is the first
             * page in the Wizard.
             *
             * This is helpful for determining whether a page is navigable.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                return this.pageCollection.firstPage === this.currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageIsLast", {
            /**
             * Returns a Boolean that tells you whether or not the current page is the
             * last page in the Wizard.
             *
             * This is used to determine which buttons should display in the wizard footer.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                return this.pageCollection.lastPage === this.currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPage", {
            /**
             * Returns the ClrWizardPage object of the current page or null.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                if (!this._currentPage) {
                    return null;
                }
                return this._currentPage;
            },
            /**
             * Accepts a ClrWizardPage object, since that object to be the current/active
             * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
             * event for that page.
             *
             * Note that all of this work is bypassed if the ClrWizardPage object is already
             * the current page.
             *
             * @memberof WizardNavigationService
             */
            set: function (page) {
                if (this._currentPage !== page && !this.wizardStopNavigation) {
                    this._currentPage = page;
                    page.onLoad.emit(page.id);
                    this._currentChanged.next(page);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "movedToNextPage", {
            /**
             * An observable used internally to alert the wizard that forward navigation
             * has occurred. It is recommended that you use the Wizard.onMoveNext
             * (clrWizardOnNext) output instead of this one.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                return this._movedToNextPage.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "wizardFinished", {
            /**
             * An observable used internally to alert the wizard that the nav service
             * has approved completion of the wizard.
             *
             * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
             * output instead of this one.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                return this._wizardFinished.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.next = function () {
            if (this.currentPageIsLast) {
                this.checkAndCommitCurrentPage('finish');
            }
            else {
                this.checkAndCommitCurrentPage('next');
            }
        };
        /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.forceNext = function () {
            var currentPage = this.currentPage;
            var nextPage = this.pageCollection.getNextPage(currentPage);
            // catch errant null or undefineds that creep in
            if (!nextPage) {
                throw new Error('The wizard has no next page to go to.');
            }
            if (this.wizardStopNavigation) {
                return;
            }
            if (!currentPage.completed) {
                // this is a state that alt next flows can get themselves in...
                this.pageCollection.commitPage(currentPage);
            }
            this.currentPage = nextPage;
        };
        /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.checkAndCommitCurrentPage = function (buttonType) {
            var currentPage = this.currentPage;
            var iAmTheLastPage;
            var isNext;
            var isDanger;
            var isDangerNext;
            var isDangerFinish;
            var isFinish;
            if (!currentPage.readyToComplete || this.wizardStopNavigation) {
                return;
            }
            iAmTheLastPage = this.currentPageIsLast;
            isNext = buttonType === 'next';
            isDanger = buttonType === 'danger';
            isDangerNext = isDanger && !iAmTheLastPage;
            isDangerFinish = isDanger && iAmTheLastPage;
            isFinish = buttonType === 'finish' || isDangerFinish;
            if (isFinish && !iAmTheLastPage) {
                return;
            }
            currentPage.primaryButtonClicked.emit(buttonType);
            if (isFinish) {
                currentPage.finishButtonClicked.emit(currentPage);
            }
            else if (isDanger) {
                currentPage.dangerButtonClicked.emit();
            }
            else if (isNext) {
                currentPage.nextButtonClicked.emit();
            }
            if (currentPage.stopNext || currentPage.preventDefault) {
                currentPage.onCommit.emit(currentPage.id);
                return;
            }
            // order is very important with these emitters!
            if (isFinish) {
                // mark page as complete
                if (!this.wizardHasAltNext) {
                    this.pageCollection.commitPage(currentPage);
                }
                this._wizardFinished.next();
            }
            if (this.wizardHasAltNext) {
                this.pageCollection.commitPage(currentPage);
                if (isNext || isDangerNext) {
                    this._movedToNextPage.next(true);
                }
                // jump out here, no matter what type we're looking at
                return;
            }
            if (isNext || isDangerNext) {
                this.forceNext();
            }
            if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
                this._movedToNextPage.next(true);
            }
        };
        /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.finish = function () {
            this.checkAndCommitCurrentPage('finish');
        };
        Object.defineProperty(WizardNavigationService.prototype, "movedToPreviousPage", {
            /**
             * Notifies the wizard when backwards navigation has occurred via the
             * previous button.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                return this._movedToPreviousPage.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.previous = function () {
            var previousPage;
            if (this.currentPageIsFirst || this.wizardStopNavigation) {
                return;
            }
            previousPage = this.pageCollection.getPreviousPage(this.currentPage);
            if (!previousPage) {
                return;
            }
            this._movedToPreviousPage.next(true);
            if (this.forceForwardNavigation) {
                this.currentPage.completed = false;
            }
            this.currentPage = previousPage;
        };
        Object.defineProperty(WizardNavigationService.prototype, "notifyWizardCancel", {
            /**
             * Notifies the wizard that a user is trying to cancel it.
             *
             * @memberof WizardNavigationService
             */
            get: function () {
                return this._cancelWizard.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.cancel = function () {
            this._cancelWizard.next();
        };
        /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.goTo = function (pageToGoToOrId, lazyComplete) {
            if (lazyComplete === void 0) { lazyComplete = false; }
            var pageToGoTo;
            var currentPage;
            var myPages;
            var pagesToCheck;
            var okayToMove;
            var goingForward;
            var currentPageIndex;
            var goToPageIndex;
            myPages = this.pageCollection;
            pageToGoTo = typeof pageToGoToOrId === 'string' ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
            currentPage = this.currentPage;
            // no point in going to the current page. you're there already!
            // also hard block on any navigation when stopNavigation is true
            if (pageToGoTo === currentPage || this.wizardStopNavigation) {
                return;
            }
            currentPageIndex = myPages.getPageIndex(currentPage);
            goToPageIndex = myPages.getPageIndex(pageToGoTo);
            goingForward = goToPageIndex > currentPageIndex;
            pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
            okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
            if (!okayToMove) {
                return;
            }
            if (goingForward && lazyComplete) {
                pagesToCheck.forEach(function (page) {
                    if (page !== pageToGoTo) {
                        page.completed = true;
                    }
                });
            }
            else if (!goingForward && this.forceForwardNavigation) {
                pagesToCheck.forEach(function (page) {
                    page.completed = false;
                });
            }
            this.currentPage = pageToGoTo;
        };
        /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.canGoTo = function (pagesToCheck) {
            var okayToMove = true;
            var myPages = this.pageCollection;
            // previous page can be important when moving because if it's completed it
            // allows us to move to the page even if it's incomplete...
            var previousPagePasses;
            if (!pagesToCheck || pagesToCheck.length < 1) {
                return false;
            }
            pagesToCheck.forEach(function (page) {
                var previousPage;
                if (!okayToMove) {
                    return;
                }
                if (page.completed) {
                    // default is true. just jump out instead of complicating it.
                    return;
                }
                // so we know our page is not completed...
                previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
                previousPagePasses = previousPage === null || previousPage.completed === true;
                // we are false if not the current page AND previous page is not completed
                // (but must have a previous page)
                if (!page.current && !previousPagePasses) {
                    okayToMove = false;
                }
                // falls through to true as default
            });
            return okayToMove;
        };
        /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.setLastEnabledPageCurrent = function () {
            var allPages = this.pageCollection.pagesAsArray;
            var lastCompletedPageIndex = null;
            allPages.forEach(function (page, index) {
                if (page.completed) {
                    lastCompletedPageIndex = index;
                }
            });
            if (lastCompletedPageIndex === null) {
                // always is at least the first item...
                lastCompletedPageIndex = 0;
            }
            else if (lastCompletedPageIndex + 1 < allPages.length) {
                lastCompletedPageIndex = lastCompletedPageIndex + 1;
            }
            this.currentPage = allPages[lastCompletedPageIndex];
        };
        /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.setFirstPageCurrent = function () {
            this.currentPage = this.pageCollection.pagesAsArray[0];
        };
        /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * @memberof WizardNavigationService
         */
        WizardNavigationService.prototype.updateNavigation = function () {
            var toSetCurrent;
            var currentPageRemoved;
            this.pageCollection.updateCompletedStates();
            currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
            if (currentPageRemoved) {
                toSetCurrent = this.pageCollection.findFirstIncompletePage();
                this.currentPage = toSetCurrent;
            }
        };
        WizardNavigationService.ctorParameters = function () { return [
            { type: PageCollectionService },
            { type: ButtonHubService }
        ]; };
WizardNavigationService.ɵfac = function WizardNavigationService_Factory(t) { return new (t || WizardNavigationService)(ɵngcc0.ɵɵinject(PageCollectionService), ɵngcc0.ɵɵinject(ButtonHubService)); };
WizardNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: WizardNavigationService, factory: function (t) { return WizardNavigationService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WizardNavigationService, [{
        type: core.Injectable
    }], function () { return [{ type: PageCollectionService }, { type: ButtonHubService }]; }, null); })();
        return WizardNavigationService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var HeaderActionService = /** @class */ (function () {
        // this service communicates information about the presence/display of header actions
        // across the wizard
        function HeaderActionService(navService) {
            this.navService = navService;
        }
        Object.defineProperty(HeaderActionService.prototype, "wizardHasHeaderActions", {
            get: function () {
                var wizardHdrActions = this.wizardHeaderActions;
                if (!wizardHdrActions) {
                    return false;
                }
                return wizardHdrActions.toArray().length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "currentPageHasHeaderActions", {
            get: function () {
                return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "showWizardHeaderActions", {
            get: function () {
                return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "displayHeaderActionsWrapper", {
            get: function () {
                return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
            },
            enumerable: true,
            configurable: true
        });
        HeaderActionService.ctorParameters = function () { return [
            { type: WizardNavigationService }
        ]; };
HeaderActionService.ɵfac = function HeaderActionService_Factory(t) { return new (t || HeaderActionService)(ɵngcc0.ɵɵinject(WizardNavigationService)); };
HeaderActionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HeaderActionService, factory: function (t) { return HeaderActionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeaderActionService, [{
        type: core.Injectable
    }], function () { return [{ type: WizardNavigationService }]; }, null); })();
        return HeaderActionService;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var wizardHeaderActionIndex = 0;
    var ClrWizardHeaderAction = /** @class */ (function () {
        function ClrWizardHeaderAction() {
            // title is explanatory text added to the header action
            this.title = '';
            // If our host has an ID attribute, we use this instead of our index.
            this._id = (wizardHeaderActionIndex++).toString();
            this.disabled = false;
            this.headerActionClicked = new core.EventEmitter(false);
        }
        Object.defineProperty(ClrWizardHeaderAction.prototype, "id", {
            get: function () {
                return "clr-wizard-header-action-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        ClrWizardHeaderAction.prototype.click = function () {
            if (this.disabled) {
                return;
            }
            // passing the header action id allows users to have one method that
            // routes to many different actions based on the type of header action
            // clicked. this is further aided by users being able to specify ids
            // for their header actions.
            this.headerActionClicked.emit(this._id);
        };
        __decorate([
            core.Input('title')
        ], ClrWizardHeaderAction.prototype, "title", void 0);
        __decorate([
            core.Input('id')
        ], ClrWizardHeaderAction.prototype, "_id", void 0);
        __decorate([
            core.Input('clrWizardHeaderActionDisabled')
        ], ClrWizardHeaderAction.prototype, "disabled", void 0);
        __decorate([
            core.Output('actionClicked')
        ], ClrWizardHeaderAction.prototype, "headerActionClicked", void 0);
ClrWizardHeaderAction.ɵfac = function ClrWizardHeaderAction_Factory(t) { return new (t || ClrWizardHeaderAction)(); };
ClrWizardHeaderAction.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrWizardHeaderAction, selectors: [["clr-wizard-header-action"]], hostAttrs: [1, "clr-wizard-header-action-wrapper"], inputs: { title: "title", _id: ["id", "_id"], disabled: ["clrWizardHeaderActionDisabled", "disabled"] }, outputs: { headerActionClicked: "actionClicked" }, ngContentSelectors: _c1, decls: 2, vars: 4, consts: [["type", "button", 1, "btn", "clr-wizard-header-action", "btn-link", 3, "id", "title", "click"]], template: function ClrWizardHeaderAction_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ClrWizardHeaderAction_Template_button_click_0_listener() { return ctx.click(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
        ɵngcc0.ɵɵproperty("id", ctx.id)("title", ctx.title);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardHeaderAction, [{
        type: core.Component,
        args: [{
                selector: 'clr-wizard-header-action',
                template: "\n        <button \n            type=\"button\"\n            class=\"btn clr-wizard-header-action btn-link\"\n            [id]=\"id\"\n            [class.disabled]=\"disabled\"\n            (click)=\"click()\"\n            [title]=\"title\">\n            <ng-content></ng-content>\n        </button>\n    ",
                host: { class: 'clr-wizard-header-action-wrapper' }
            }]
    }], function () { return []; }, { title: [{
            type: core.Input,
            args: ['title']
        }], _id: [{
            type: core.Input,
            args: ['id']
        }], disabled: [{
            type: core.Input,
            args: ['clrWizardHeaderActionDisabled']
        }], headerActionClicked: [{
            type: core.Output,
            args: ['actionClicked']
        }] }); })();
        return ClrWizardHeaderAction;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardPageButtons = /** @class */ (function () {
        function ClrWizardPageButtons(pageButtonsTemplateRef) {
            this.pageButtonsTemplateRef = pageButtonsTemplateRef;
        }
        ClrWizardPageButtons.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
ClrWizardPageButtons.ɵfac = function ClrWizardPageButtons_Factory(t) { return new (t || ClrWizardPageButtons)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
ClrWizardPageButtons.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrWizardPageButtons, selectors: [["", "clrPageButtons", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardPageButtons, [{
        type: core.Directive,
        args: [{ selector: '[clrPageButtons]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
        return ClrWizardPageButtons;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardPageHeaderActions = /** @class */ (function () {
        function ClrWizardPageHeaderActions(pageHeaderActionsTemplateRef) {
            this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
        }
        ClrWizardPageHeaderActions.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
ClrWizardPageHeaderActions.ɵfac = function ClrWizardPageHeaderActions_Factory(t) { return new (t || ClrWizardPageHeaderActions)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
ClrWizardPageHeaderActions.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrWizardPageHeaderActions, selectors: [["", "clrPageHeaderActions", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardPageHeaderActions, [{
        type: core.Directive,
        args: [{ selector: '[clrPageHeaderActions]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
        return ClrWizardPageHeaderActions;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardPageNavTitle = /** @class */ (function () {
        function ClrWizardPageNavTitle(pageNavTitleTemplateRef) {
            this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
        }
        ClrWizardPageNavTitle.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
ClrWizardPageNavTitle.ɵfac = function ClrWizardPageNavTitle_Factory(t) { return new (t || ClrWizardPageNavTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
ClrWizardPageNavTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrWizardPageNavTitle, selectors: [["", "clrPageNavTitle", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardPageNavTitle, [{
        type: core.Directive,
        args: [{ selector: '[clrPageNavTitle]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
        return ClrWizardPageNavTitle;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardPageTitle = /** @class */ (function () {
        function ClrWizardPageTitle(pageTitleTemplateRef) {
            this.pageTitleTemplateRef = pageTitleTemplateRef;
        }
        ClrWizardPageTitle.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
ClrWizardPageTitle.ɵfac = function ClrWizardPageTitle_Factory(t) { return new (t || ClrWizardPageTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
ClrWizardPageTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrWizardPageTitle, selectors: [["", "clrPageTitle", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardPageTitle, [{
        type: core.Directive,
        args: [{ selector: '[clrPageTitle]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
        return ClrWizardPageTitle;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var wizardPageIndex = 0;
    /**
     * The ClrWizardPage component is responsible for displaying the content of each step
     * in the wizard workflow.
     *
     * ClrWizardPage component has hooks into the navigation service (ClrWizardPage.navService),
     * page collection (ClrWizardPage.pageCollection), and button service
     * (ClrWizardPage.buttonService). These three providers are shared across the components
     * within each instance of a Wizard.
     *
     */
    var ClrWizardPage = /** @class */ (function () {
        /**
         * Creates an instance of ClrWizardPage.
         *
         * @memberof WizardPage
         */
        function ClrWizardPage(navService, pageCollection, buttonService) {
            this.navService = navService;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            /**
             *
             * @memberof WizardPage
             *
             */
            this._nextStepDisabled = false;
            /**
             * Emits when the value of ClrWizardPage.nextStepDisabled changes.
             * Should emit the new value of nextStepDisabled.
             *
             * @memberof WizardPage
             *
             */
            this.nextStepDisabledChange = new core.EventEmitter();
            /**
             *
             * @memberof WizardPage
             *
             */
            this._previousStepDisabled = false;
            /**
             * Emits when the value of ClrWizardPage.previousStepDisabled changes.
             * Should emit the new value of previousStepDisabled.
             *
             * @memberof WizardPage
             *
             */
            this.previousStepDisabledChange = new core.EventEmitter();
            /**
             *
             * @memberof WizardPage
             *
             */
            this._hasError = false;
            /**
             * Overrides all actions from the page level, so you can use an alternate function for
             * validation or data-munging with a ClrWizardPage.onCommit (clrWizardPageOnCommit output),
             * ClrWizardPage.onCancel (clrWizardPageOnCancel output), or one
             * of the granular page-level button click event emitters.
             *
             * @memberof WizardPage
             *
             */
            this.preventDefault = false;
            /**
             *
             * @memberof WizardPage
             *
             */
            this._stopCancel = false;
            /**
             *
             * @memberof WizardPage
             *
             */
            this.stopCancelChange = new core.EventEmitter();
            /**
             *
             * @memberof WizardPage
             *
             */
            this._stopNext = false;
            /**
             * An event emitter carried over from a legacy version of ClrWizardPage.
             * Fires an event on ClrWizardPage whenever the next or finish buttons
             * are clicked and the page is the current page of the Wizard.
             *
             * Note that this does not automatically emit an event when a custom
             * button is used in place of a next or finish button.
             *
             * @memberof WizardPage
             *
             */
            this.onCommit = new core.EventEmitter(false);
            /**
             * Emits an event when ClrWizardPage becomes the current page of the
             * Wizard.
             *
             * @memberof WizardPage
             *
             */
            this.onLoad = new core.EventEmitter();
            /**
             * Emits an event when the ClrWizardPage invokes the cancel routine for the wizard.
             *
             * Can be used in conjunction with the ClrWizardPage.stopCancel
             * (clrWizardPagePreventDefaultCancel) or ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) inputs to implement custom cancel
             * functionality at the page level. This is useful if you would like to do
             * validation, save data, or warn users before cancelling the wizard.
             *
             * Note that this requires you to call Wizard.close() from the host component.
             * This constitues a full replacement of the cancel functionality.
             *
             * @memberof WizardPage
             *
             */
            this.pageOnCancel = new core.EventEmitter();
            /**
             * Emits an event when the finish button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom finish
             * functionality at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to complete
             * the wizard.
             *
             * Note that this requires you to call Wizard.finish() or Wizard.forceFinish()
             * from the host component. This combination creates a full replacement of
             * the finish functionality.
             *
             * @memberof WizardPage
             *
             */
            this.finishButtonClicked = new core.EventEmitter();
            /**
             * Emits an event when the previous button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom backwards
             * navigation at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to go
             * backwards in the wizard.
             *
             * Note that this requires you to call Wizard.previous()
             * from the host component. This combination creates a full replacement of
             * the backwards navigation functionality.
             *
             * @memberof WizardPage
             *
             */
            this.previousButtonClicked = new core.EventEmitter();
            /**
             * Emits an event when the next button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * navigation at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to go
             * to the next page in the wizard.
             *
             * Note that this requires you to call Wizard.forceNext() or Wizard.next()
             * from the host component. This combination creates a full replacement of
             * the forward navigation functionality.
             *
             * @memberof WizardPage
             *
             */
            this.nextButtonClicked = new core.EventEmitter();
            /**
             * Emits an event when a danger button is clicked and the ClrWizardPage is
             * the wizard's current page. By default, a danger button will act as
             * either a "next" or "finish" button depending on if the ClrWizardPage is the
             * last page or not.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * or finish navigation at the page level when the danger button is clicked.
             * This is useful if you would like to do validation, save data, or warn
             * users before allowing them to go to the next page in the wizard or
             * finish the wizard.
             *
             * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
             * Wizard.forceNext() or Wizard.next() from the host component. This
             * combination creates a full replacement of the forward navigation and
             * finish functionality.
             *
             * @memberof WizardPage
             *
             */
            this.dangerButtonClicked = new core.EventEmitter();
            /**
             * Emits an event when a next, finish, or danger button is clicked and the
             * ClrWizardPage is the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * or finish navigation at the page level, regardless of the type of
             * primary button.
             *
             * This is useful if you would like to do validation, save data, or warn
             * users before allowing them to go to the next page in the wizard or
             * finish the wizard.
             *
             * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
             * Wizard.forceNext() or Wizard.next() from the host component. This
             * combination creates a full replacement of the forward navigation and
             * finish functionality.
             *
             * @memberof WizardPage
             *
             */
            this.primaryButtonClicked = new core.EventEmitter();
            this.customButtonClicked = new core.EventEmitter();
            /**
             * An input value that is used internally to generate the ClrWizardPage ID as
             * well as the step nav item ID.
             *
             * Typed as any because it should be able to accept numbers as well as
             * strings. Passing an index for wizard whose pages are created with an
             * ngFor loop is a common use case.
             *
             * @memberof WizardPage
             *
             */
            this._id = (wizardPageIndex++).toString();
            /**
             *
             * @memberof WizardPage
             *
             */
            this._complete = false;
        }
        Object.defineProperty(ClrWizardPage.prototype, "nextStepDisabled", {
            /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the next page.
             *
             * Useful for in-page validation because it prevents forward navigation
             * and visibly disables the next button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this._nextStepDisabled;
            },
            /**
             * Sets whether the page should allow forward navigation.
             *
             * @memberof WizardPage
             *
             */
            set: function (val) {
                var valBool = !!val;
                if (valBool !== this._nextStepDisabled) {
                    this._nextStepDisabled = valBool;
                    this.nextStepDisabledChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "previousStepDisabled", {
            /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the previous page.
             *
             * Useful for in-page validation because it prevents backward navigation
             * and visibly disables the previous button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this._previousStepDisabled;
            },
            /**
             * Sets whether the page should allow backward navigation.
             *
             * @memberof WizardPage
             *
             */
            set: function (val) {
                var valBool = !!val;
                if (valBool !== this._previousStepDisabled) {
                    this._previousStepDisabled = valBool;
                    this.previousStepDisabledChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasError", {
            /**
             * A getter that tells whether or not the page has an error.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this._hasError;
            },
            /**
             * Sets whether the page has an error and also resolve the "falsy" value. The
             * current logic treat a "0" or an empty string as false and likewise will treat any
             * "truthy" value as true.
             *
             * @memberof WizardPage
             *
             */
            set: function (val) {
                var valBool = !!val;
                if (valBool !== this._hasError) {
                    this._hasError = valBool;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "stopCancel", {
            /**
             * A getter that retrieves whether the page is preventing the cancel action.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this._stopCancel;
            },
            /**
             * Overrides the cancel action from the page level. Allows you to use an
             * alternate function for validation or data-munging before cancelling the
             * wizard when combined with the ClrWizardPage.onCancel
             * (the clrWizardPageOnCancel output).
             *
             * Requires that you manually close the wizard from your host component,
             * usually with a call to Wizard.forceNext() or wizard.next();
             *
             * @memberof ClrWizardPage
             */
            set: function (val) {
                var valBool = !!val;
                if (valBool !== this._stopCancel) {
                    this._stopCancel = valBool;
                    this.stopCancelChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "stopNext", {
            /**
             * A getter that tells you whether the page is preventing the next action.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this._stopNext;
            },
            /**
             * Overrides forward navigation from the page level. Allows you to use an
             * alternate function for validation or data-munging before moving the
             * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
             * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
             * (clrWizardPageNext) outputs.
             *
             * Requires that you manually tell the wizard to navigate forward from
             * the hostComponent, usually with a call to Wizard.forceNext() or
             * wizard.next();
             *
             * @memberof ClrWizardPage
             */
            set: function (val) {
                var valBool = !!val;
                if (valBool !== this._stopNext) {
                    this._stopNext = valBool;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "id", {
            /**
             * A read-only getter that generates an ID string for the wizard page from
             * either the value passed to the ClrWizardPage "id" input or a wizard page
             * counter shared across all wizard pages in the application.
             *
             * Note that the value passed into the ID input Will be prefixed with
             * "clr-wizard-page-".
             *
             * @readonly
             *
             * @memberof ClrWizardPage
             */
            get: function () {
                // covers things like null, undefined, false, and empty string
                // while allowing zero to pass
                var idIsNonZeroFalsy = !this._id && this._id !== 0;
                // in addition to non-zero falsy we also want to make sure _id is not a negative
                // number.
                if (idIsNonZeroFalsy || this._id < 0) {
                    // guard here in the event that input becomes undefined or null by accident
                    this._id = (wizardPageIndex++).toString();
                }
                return "clr-wizard-page-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "readyToComplete", {
            /**
             * A read-only getter that serves as a convenience for those who would rather
             * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
             * ClrWizardPage.readyToComplete is more logical and declarative.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return !this.nextStepDisabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "completed", {
            /**
             * A page is marked as completed if it is both readyToComplete and completed,
             * as in the next or finish action has been executed while this page was current.
             *
             * Note there is and open question about how to handle pages that are marked
             * complete but who are no longer readyToComplete. This might indicate an error
             * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
             * and only returns that the page is incomplete.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this._complete && this.readyToComplete;
                // FOR V2: UNWIND COMPLETED, READYTOCOMPLETE, AND ERRORS
                // SUCH THAT ERRORS IS ITS OWN INPUT. IF A STEP IS
                // INCOMPLETE AND ERRORED, ERRORED WILL NOT SHOW.
                // FIRST QUESTION: AM I GREY OR COLORED?
                // SECOND QUESTION: AM I GREEN OR RED?
            },
            /**
             * A ClrWizardPage can be manually set to completed using this boolean setter.
             * It is recommended that users rely on the convenience functions in the wizard
             * and navigation service instead of manually setting pages’ completion state.
             *
             * @memberof ClrWizardPage
             */
            set: function (value) {
                this._complete = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "current", {
            /**
             * Checks with the navigation service to see if it is the current page.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this.navService.currentPage === this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "disabled", {
            get: function () {
                return !this.enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "enabled", {
            /**
             * A read-only getter that returns whether or not the page is navigable
             * in the wizard. A wizard page can be navigated to if it is completed
             * or the page before it is completed.
             *
             * This getter handles the logic for enabling or disabling the links in
             * the step nav on the left Side of the wizard.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this.current || this.completed || this.previousCompleted;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "previousCompleted", {
            /**
             * A read-only getter that returns whether or not the page before this
             * ClrWizardPage is completed. This is useful for determining whether or not
             * a page is navigable if it is not current or already completed.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                var previousPage = this.pageCollection.getPreviousPage(this);
                if (!previousPage) {
                    return true;
                }
                return previousPage.completed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "title", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this.pageTitle.pageTitleTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "navTitle", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                if (this.pageNavTitle) {
                    return this.pageNavTitle.pageNavTitleTemplateRef;
                }
                return this.pageTitle.pageTitleTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "headerActions", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                if (!this._headerActions) {
                    return;
                }
                return this._headerActions.pageHeaderActionsTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasHeaderActions", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return !!this._headerActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "buttons", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                if (!this._buttons) {
                    return;
                }
                return this._buttons.pageButtonsTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasButtons", {
            /**
             * A read-only getter that returns a boolean that says whether or
             * not the ClrWizardPage includes buttons. Used to determine if the
             * Wizard should override the default button set defined as
             * its direct children.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return !!this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * @memberof WizardPage
         *
         */
        ClrWizardPage.prototype.makeCurrent = function () {
            this.navService.currentPage = this;
        };
        /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * @memberof WizardPage
         *
         */
        ClrWizardPage.prototype.ngOnInit = function () {
            var navService = this.navService;
            if (!navService.currentPage && !navService.navServiceLoaded) {
                this.makeCurrent();
                this.navService.navServiceLoaded = true;
            }
        };
        Object.defineProperty(ClrWizardPage.prototype, "stepItemId", {
            /**
             * A read-only getter that returns the id used by the step nav item associated with the page.
             *
             * ClrWizardPage needs this ID string for aria information.
             *
             * @memberof WizardPage
             *
             */
            get: function () {
                return this.pageCollection.getStepItemIdForPage(this);
            },
            enumerable: true,
            configurable: true
        });
        ClrWizardPage.ctorParameters = function () { return [
            { type: WizardNavigationService },
            { type: PageCollectionService },
            { type: ButtonHubService }
        ]; };
        __decorate([
            core.ContentChild(ClrWizardPageTitle, { static: true })
        ], ClrWizardPage.prototype, "pageTitle", void 0);
        __decorate([
            core.ContentChild(ClrWizardPageNavTitle, { static: true })
        ], ClrWizardPage.prototype, "pageNavTitle", void 0);
        __decorate([
            core.ContentChild(ClrWizardPageButtons, { static: true })
        ], ClrWizardPage.prototype, "_buttons", void 0);
        __decorate([
            core.ContentChild(ClrWizardPageHeaderActions, { static: true })
        ], ClrWizardPage.prototype, "_headerActions", void 0);
        __decorate([
            core.Input('clrWizardPageNextDisabled')
        ], ClrWizardPage.prototype, "nextStepDisabled", null);
        __decorate([
            core.Output('clrWizardPageNextDisabledChange')
        ], ClrWizardPage.prototype, "nextStepDisabledChange", void 0);
        __decorate([
            core.Input('clrWizardPagePreviousDisabled')
        ], ClrWizardPage.prototype, "previousStepDisabled", null);
        __decorate([
            core.Output('clrWizardPagePreviousDisabledChange')
        ], ClrWizardPage.prototype, "previousStepDisabledChange", void 0);
        __decorate([
            core.Input('clrWizardPageHasError')
        ], ClrWizardPage.prototype, "hasError", null);
        __decorate([
            core.Input('clrWizardPagePreventDefault')
        ], ClrWizardPage.prototype, "preventDefault", void 0);
        __decorate([
            core.Input('clrWizardPagePreventDefaultCancel')
        ], ClrWizardPage.prototype, "stopCancel", null);
        __decorate([
            core.Output('clrWizardPagePreventDefaultCancelChange')
        ], ClrWizardPage.prototype, "stopCancelChange", void 0);
        __decorate([
            core.Input('clrWizardPagePreventDefaultNext')
        ], ClrWizardPage.prototype, "stopNext", null);
        __decorate([
            core.Output('clrWizardPageOnCommit')
        ], ClrWizardPage.prototype, "onCommit", void 0);
        __decorate([
            core.Output('clrWizardPageOnLoad')
        ], ClrWizardPage.prototype, "onLoad", void 0);
        __decorate([
            core.Output('clrWizardPageOnCancel')
        ], ClrWizardPage.prototype, "pageOnCancel", void 0);
        __decorate([
            core.Output('clrWizardPageFinish')
        ], ClrWizardPage.prototype, "finishButtonClicked", void 0);
        __decorate([
            core.Output('clrWizardPagePrevious')
        ], ClrWizardPage.prototype, "previousButtonClicked", void 0);
        __decorate([
            core.Output('clrWizardPageNext')
        ], ClrWizardPage.prototype, "nextButtonClicked", void 0);
        __decorate([
            core.Output('clrWizardPageDanger')
        ], ClrWizardPage.prototype, "dangerButtonClicked", void 0);
        __decorate([
            core.Output('clrWizardPagePrimary')
        ], ClrWizardPage.prototype, "primaryButtonClicked", void 0);
        __decorate([
            core.Output('clrWizardPageCustomButton')
        ], ClrWizardPage.prototype, "customButtonClicked", void 0);
        __decorate([
            core.Input('id')
        ], ClrWizardPage.prototype, "_id", void 0);
ClrWizardPage.ɵfac = function ClrWizardPage_Factory(t) { return new (t || ClrWizardPage)(ɵngcc0.ɵɵdirectiveInject(WizardNavigationService), ɵngcc0.ɵɵdirectiveInject(PageCollectionService), ɵngcc0.ɵɵdirectiveInject(ButtonHubService)); };
ClrWizardPage.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrWizardPage, selectors: [["clr-wizard-page"]], contentQueries: function ClrWizardPage_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrWizardPageTitle, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrWizardPageNavTitle, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrWizardPageButtons, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrWizardPageHeaderActions, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pageTitle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pageNavTitle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._buttons = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._headerActions = _t.first);
    } }, hostVars: 7, hostBindings: function ClrWizardPage_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
        ɵngcc0.ɵɵattribute("aria-hidden", !ctx.current)("aria-labelledby", ctx.stepItemId);
        ɵngcc0.ɵɵclassProp("active", ctx.current)("clr-wizard-page", true);
    } }, inputs: { preventDefault: ["clrWizardPagePreventDefault", "preventDefault"], _id: ["id", "_id"], nextStepDisabled: ["clrWizardPageNextDisabled", "nextStepDisabled"], previousStepDisabled: ["clrWizardPagePreviousDisabled", "previousStepDisabled"], hasError: ["clrWizardPageHasError", "hasError"], stopCancel: ["clrWizardPagePreventDefaultCancel", "stopCancel"], stopNext: ["clrWizardPagePreventDefaultNext", "stopNext"] }, outputs: { nextStepDisabledChange: "clrWizardPageNextDisabledChange", previousStepDisabledChange: "clrWizardPagePreviousDisabledChange", stopCancelChange: "clrWizardPagePreventDefaultCancelChange", onCommit: "clrWizardPageOnCommit", onLoad: "clrWizardPageOnLoad", pageOnCancel: "clrWizardPageOnCancel", finishButtonClicked: "clrWizardPageFinish", previousButtonClicked: "clrWizardPagePrevious", nextButtonClicked: "clrWizardPageNext", dangerButtonClicked: "clrWizardPageDanger", primaryButtonClicked: "clrWizardPagePrimary", customButtonClicked: "clrWizardPageCustomButton" }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrWizardPage_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardPage, [{
        type: core.Component,
        args: [{
                selector: 'clr-wizard-page',
                template: '<ng-content></ng-content>',
                host: {
                    '[id]': 'id',
                    '[attr.aria-hidden]': '!current',
                    '[attr.aria-labelledby]': 'stepItemId',
                    '[class.active]': 'current',
                    '[class.clr-wizard-page]': 'true'
                }
            }]
    }], function () { return [{ type: WizardNavigationService }, { type: PageCollectionService }, { type: ButtonHubService }]; }, { nextStepDisabledChange: [{
            type: core.Output,
            args: ['clrWizardPageNextDisabledChange']
        }], previousStepDisabledChange: [{
            type: core.Output,
            args: ['clrWizardPagePreviousDisabledChange']
        }], preventDefault: [{
            type: core.Input,
            args: ['clrWizardPagePreventDefault']
        }], stopCancelChange: [{
            type: core.Output,
            args: ['clrWizardPagePreventDefaultCancelChange']
        }], onCommit: [{
            type: core.Output,
            args: ['clrWizardPageOnCommit']
        }], onLoad: [{
            type: core.Output,
            args: ['clrWizardPageOnLoad']
        }], pageOnCancel: [{
            type: core.Output,
            args: ['clrWizardPageOnCancel']
        }], finishButtonClicked: [{
            type: core.Output,
            args: ['clrWizardPageFinish']
        }], previousButtonClicked: [{
            type: core.Output,
            args: ['clrWizardPagePrevious']
        }], nextButtonClicked: [{
            type: core.Output,
            args: ['clrWizardPageNext']
        }], dangerButtonClicked: [{
            type: core.Output,
            args: ['clrWizardPageDanger']
        }], primaryButtonClicked: [{
            type: core.Output,
            args: ['clrWizardPagePrimary']
        }], customButtonClicked: [{
            type: core.Output,
            args: ['clrWizardPageCustomButton']
        }], _id: [{
            type: core.Input,
            args: ['id']
        }], nextStepDisabled: [{
            type: core.Input,
            args: ['clrWizardPageNextDisabled']
        }], previousStepDisabled: [{
            type: core.Input,
            args: ['clrWizardPagePreviousDisabled']
        }], hasError: [{
            type: core.Input,
            args: ['clrWizardPageHasError']
        }], stopCancel: [{
            type: core.Input,
            args: ['clrWizardPagePreventDefaultCancel']
        }], stopNext: [{
            type: core.Input,
            args: ['clrWizardPagePreventDefaultNext']
        }], pageTitle: [{
            type: core.ContentChild,
            args: [ClrWizardPageTitle, { static: true }]
        }], pageNavTitle: [{
            type: core.ContentChild,
            args: [ClrWizardPageNavTitle, { static: true }]
        }], _buttons: [{
            type: core.ContentChild,
            args: [ClrWizardPageButtons, { static: true }]
        }], _headerActions: [{
            type: core.ContentChild,
            args: [ClrWizardPageHeaderActions, { static: true }]
        }] }); })();
        return ClrWizardPage;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizard = /** @class */ (function () {
        function ClrWizard(platformId, navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
            this.platformId = platformId;
            this.navService = navService;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            this.headerActionService = headerActionService;
            this.elementRef = elementRef;
            /**
             * Set the modal size of the wizard. Set using `[clrWizardSize]` input.
             */
            this.size = 'xl';
            /**
             * Tells the modal part of the wizard whether it should have a close "X"
             * in the top right corner. Set using `[clrWizardClosable]` input.
             */
            this.closable = true;
            this._forceForward = false;
            this._open = false;
            this._stopNext = false;
            this._stopCancel = false;
            this._stopNavigation = false;
            this._disableStepnav = false;
            /**
             * Used to communicate to the underlying modal that animations are not
             * wanted. Primary use is for the display of static/inline wizards.
             * Set using `[clrWizardPreventModalAnimation]` input.
             */
            /** @deprecated since 3.0, input should be removed in 4.0 because is only related to inline wizards */
            this._stopModalAnimations = false;
            /**
             * Emits when the wizard is opened or closed.
             * Listen via `(clrWizardOpenChange)` event.
             */
            this._openChanged = new core.EventEmitter(false);
            /**
             * Emits when the wizard is canceled. Listen via `(clrWizardOnCancel)` event.
             * Can be combined with the `[clrWizardPreventDefaultCancel]` input to create
             * wizard-level custom cancel routines.
             */
            this.onCancel = new core.EventEmitter(false);
            /**
             * Emits when the wizard is completed. Listen via `(clrWizardOnFinish)` event.
             * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
             * wizard-level custom completion routines.
             */
            this.wizardFinished = new core.EventEmitter(false);
            /**
             * Emits when the wizard is reset. Listen via `(clrWizardOnReset)` event.
             */
            this.onReset = new core.EventEmitter(false);
            /**
             * Emits when the current page has changed. Listen via `(clrWizardCurrentPageChanged)` event.
             * output. Useful for non-blocking validation.
             */
            this.currentPageChanged = new core.EventEmitter(false);
            /**
             * Emits when the wizard moves to the next page. Listen via `(clrWizardOnNext)` event.
             * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
             * wizard-level custom navigation routines, which are useful for validation.
             */
            this.onMoveNext = new core.EventEmitter(false);
            /**
             * Emits when the wizard moves to the previous page. Can be useful for validation.
             * Listen via `(clrWizardOnPrevious)` event.
             */
            this.onMovePrevious = new core.EventEmitter(false);
            this.subscriptions = [];
            this.subscriptions.push(this.listenForNextPageChanges(), this.listenForPreviousPageChanges(), this.listenForCancelChanges(), this.listenForFinishedChanges(), this.listenForPageChanges());
            this.differ = differs.find([]).create(null);
        }
        Object.defineProperty(ClrWizard.prototype, "forceForward", {
            get: function () {
                return this._forceForward;
            },
            /**
             * Resets page completed states when navigating backwards.
             * Set using `[clrWizardForceForwardNavigation]` input.
             */
            set: function (value) {
                this._forceForward = !!value;
                this.navService.forceForwardNavigation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "clrWizardOpen", {
            /**
             * Toggles open/close of the wizard component.
             * Set using the `[clrWizardOpen]` input.
             */
            set: function (open) {
                if (open) {
                    this.buttonService.buttonsReady = true;
                }
                this._open = open;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopNext", {
            get: function () {
                return this._stopNext;
            },
            /**
             * Prevents ClrWizard from moving to the next page or closing itself on finishing.
             * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
             * will require you to create your own calls to .next() and .finish() in your
             * host component to make the ClrWizard work as expected.
             */
            set: function (value) {
                this._stopNext = !!value;
                this.navService.wizardHasAltNext = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopCancel", {
            get: function () {
                return this._stopCancel;
            },
            /**
             * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
             * Set using the `[clrWizardPreventDefaultCancel]` input.
             *
             * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
             * to make the ClrWizard work as expected. Useful for doing checks or prompts
             * before closing a ClrWizard.
             */
            set: function (value) {
                this._stopCancel = !!value;
                this.navService.wizardHasAltCancel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopNavigation", {
            get: function () {
                return this._stopNavigation;
            },
            /**
             * Prevents ClrWizard from performing any form of navigation away from the current
             * page. Set using the `[clrWizardPreventNavigation]` input.
             * Note that stopNavigation is meant to freeze the wizard in place, typically
             * during a long validation or background action where you want the wizard to
             * display loading content but not allow the user to execute navigation in
             * the stepnav, close X, or the  back, finish, or next buttons.
             */
            set: function (value) {
                this._stopNavigation = !!value;
                this.navService.wizardStopNavigation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "disableStepnav", {
            get: function () {
                return this._disableStepnav;
            },
            /**
             * Prevents clicks on the links in the stepnav from working.
             * Set using `[clrWizardDisableStepnav]` input.
             * A more granular bypassing of navigation which can be useful when your
             * ClrWizard is in a state of completion and you don't want users to be
             * able to jump backwards and change things.
             */
            set: function (value) {
                this._disableStepnav = !!value;
                this.navService.wizardDisableStepnav = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopModalAnimations", {
            get: function () {
                return this._stopModalAnimations ? 'true' : 'false';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "currentPage", {
            get: function () {
                return this.navService.currentPage;
            },
            set: function (page) {
                this.navService.goTo(page, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isLast", {
            get: function () {
                return this.navService.currentPageIsLast;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isFirst", {
            get: function () {
                return this.navService.currentPageIsFirst;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isStatic", {
            get: function () {
                return this.elementRef.nativeElement.classList.contains('clr-wizard--inline');
            },
            enumerable: true,
            configurable: true
        });
        ClrWizard.prototype.ngAfterContentInit = function () {
            this.pageCollection.pages = this.pages;
            this.headerActionService.wizardHeaderActions = this.headerActions;
            this.initializeButtons();
        };
        ClrWizard.prototype.ngDoCheck = function () {
            this.updateNavOnPageChanges();
        };
        ClrWizard.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        /**
         * Marks Wizard as finished. By default it does not execute event
         * emissions or checks before completing and closing. This method is commonly
         * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
         *
         * If `skipChecksAndEmits` is true, the wizard will complete and close
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         */
        ClrWizard.prototype.finish = function (skipChecksAndEmits) {
            if (skipChecksAndEmits === void 0) { skipChecksAndEmits = true; }
            if (skipChecksAndEmits) {
                this.forceFinish();
            }
            else {
                this.navService.finish();
            }
        };
        /**
         * Marks the wizard as finished but does run checks and emissions.
         * Good for a last step in an alternate workflow. Does the same thing as
         * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
         */
        ClrWizard.prototype.forceFinish = function () {
            if (this.stopNavigation) {
                return;
            }
            this.close();
        };
        /**
         * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
         */
        ClrWizard.prototype.open = function () {
            this._open = true;
            if (!this.currentPage) {
                this.navService.setFirstPageCurrent();
            }
            // Only render buttons when wizard is opened, to avoid chocolate errors
            this.buttonService.buttonsReady = true;
            this._openChanged.emit(true);
        };
        /**
         * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
         */
        ClrWizard.prototype.close = function () {
            if (this.stopNavigation) {
                return;
            }
            this._open = false;
            this._openChanged.emit(false);
        };
        /**
         * Used to open and close the wizard. By default the wizard will
         * close if invoked with no parameter. If parameter is true wizard will open
         * else if false will close.
         */
        ClrWizard.prototype.toggle = function (open) {
            if (open) {
                this.open();
            }
            else {
                this.close();
            }
        };
        /**
         * Moves the wizard to the previous page.
         */
        ClrWizard.prototype.previous = function () {
            this.navService.previous();
        };
        /**
         * By default, `next()` does not execute event emissions.
         * This method is commonly called as part of an alternative navigation
         * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
         * regardless of the state of its current page. This is useful for alternative
         * navigation where event emissions have already been done and firing them again
         * may cause an event loop.
         *
         * If `skipChecksAndEmits` is false, the wizard will execute default checks
         * and emit events as normal. This is useful for custom buttons or programmatic
         * workflows that are not executing the wizards default checks and emissions.
         * It is another way to navigate without having to rewrite the wizard’s default
         * functionality from scratch.
         */
        ClrWizard.prototype.next = function (skipChecksAndEmits) {
            if (skipChecksAndEmits === void 0) { skipChecksAndEmits = true; }
            if (skipChecksAndEmits) {
                this.forceNext();
            }
            else {
                this.navService.next();
            }
        };
        /**
         * Moves the wizard to the next page without the checks and emissions.
         * Good for a last step in an alternate workflow.
         * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
         */
        ClrWizard.prototype.forceNext = function () {
            this.navService.forceNext();
        };
        /**
         * Cancels and closes the wizard. Do not use this for an override of the cancel
         * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
         * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
         * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
         */
        ClrWizard.prototype.cancel = function () {
            this.navService.cancel();
        };
        /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
         */
        ClrWizard.prototype.modalCancel = function () {
            if (this.closable) {
                this.checkAndCancel();
            }
        };
        /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
         */
        ClrWizard.prototype.checkAndCancel = function () {
            var currentPage = this.currentPage;
            var currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
            if (this.stopNavigation) {
                return;
            }
            currentPage.pageOnCancel.emit();
            if (!currentPageHasOverrides) {
                this.onCancel.emit();
            }
            if (!this.stopCancel && !currentPageHasOverrides) {
                this.close();
            }
        };
        /**
         * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
         * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
         */
        ClrWizard.prototype.goTo = function (pageId) {
            if (!pageId) {
                return;
            }
            this.navService.goTo(pageId);
        };
        /**
         * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
         * be the current page, resetting the wizard navigation.
         * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
         */
        ClrWizard.prototype.reset = function () {
            this.pageCollection.reset();
            this.onReset.next();
        };
        ClrWizard.prototype.listenForNextPageChanges = function () {
            var _this = this;
            return this.navService.movedToNextPage.pipe(operators.filter(function () { return common.isPlatformBrowser(_this.platformId); })).subscribe(function () {
                _this.onMoveNext.emit();
                _this.wizardTitle.nativeElement.focus();
            });
        };
        ClrWizard.prototype.listenForPreviousPageChanges = function () {
            var _this = this;
            return this.navService.movedToPreviousPage.pipe(operators.filter(function () { return common.isPlatformBrowser(_this.platformId); })).subscribe(function () {
                _this.onMovePrevious.emit();
                _this.wizardTitle.nativeElement.focus();
            });
        };
        ClrWizard.prototype.listenForCancelChanges = function () {
            var _this = this;
            return this.navService.notifyWizardCancel.subscribe(function () { return _this.checkAndCancel(); });
        };
        ClrWizard.prototype.listenForFinishedChanges = function () {
            var _this = this;
            return this.navService.wizardFinished.subscribe(function () { return _this.emitWizardFinished(); });
        };
        ClrWizard.prototype.listenForPageChanges = function () {
            var _this = this;
            return this.navService.currentPageChanged.subscribe(function () { return _this.currentPageChanged.emit(); });
        };
        ClrWizard.prototype.updateNavOnPageChanges = function () {
            var _this = this;
            var changes = this.differ.diff(this.pages);
            if (changes) {
                changes.forEachAddedItem(function () { return _this.navService.updateNavigation(); });
                changes.forEachRemovedItem(function () { return _this.navService.updateNavigation(); });
            }
        };
        ClrWizard.prototype.initializeButtons = function () {
            // Only trigger buttons ready if default is open (inlined)
            if (this._open) {
                this.buttonService.buttonsReady = true;
            }
        };
        ClrWizard.prototype.emitWizardFinished = function () {
            if (!this.stopNext) {
                this.forceFinish();
            }
            this.wizardFinished.emit();
        };
        ClrWizard.ctorParameters = function () { return [
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: WizardNavigationService },
            { type: PageCollectionService },
            { type: ButtonHubService },
            { type: HeaderActionService },
            { type: core.ElementRef },
            { type: core.IterableDiffers }
        ]; };
        __decorate([
            core.Input('clrWizardSize')
        ], ClrWizard.prototype, "size", void 0);
        __decorate([
            core.Input('clrWizardClosable')
        ], ClrWizard.prototype, "closable", void 0);
        __decorate([
            core.Input('clrWizardForceForwardNavigation')
        ], ClrWizard.prototype, "forceForward", null);
        __decorate([
            core.Input('clrWizardOpen')
        ], ClrWizard.prototype, "clrWizardOpen", null);
        __decorate([
            core.Input('clrWizardPreventDefaultNext')
        ], ClrWizard.prototype, "stopNext", null);
        __decorate([
            core.Input('clrWizardPreventDefaultCancel')
        ], ClrWizard.prototype, "stopCancel", null);
        __decorate([
            core.Input('clrWizardPreventNavigation')
        ], ClrWizard.prototype, "stopNavigation", null);
        __decorate([
            core.Input('clrWizardDisableStepnav')
        ], ClrWizard.prototype, "disableStepnav", null);
        __decorate([
            core.Input('clrWizardPreventModalAnimation')
        ], ClrWizard.prototype, "_stopModalAnimations", void 0);
        __decorate([
            core.Output('clrWizardOpenChange')
        ], ClrWizard.prototype, "_openChanged", void 0);
        __decorate([
            core.Output('clrWizardOnCancel')
        ], ClrWizard.prototype, "onCancel", void 0);
        __decorate([
            core.Output('clrWizardOnFinish')
        ], ClrWizard.prototype, "wizardFinished", void 0);
        __decorate([
            core.Output('clrWizardOnReset')
        ], ClrWizard.prototype, "onReset", void 0);
        __decorate([
            core.Output('clrWizardCurrentPageChanged')
        ], ClrWizard.prototype, "currentPageChanged", void 0);
        __decorate([
            core.Output('clrWizardOnNext')
        ], ClrWizard.prototype, "onMoveNext", void 0);
        __decorate([
            core.Output('clrWizardOnPrevious')
        ], ClrWizard.prototype, "onMovePrevious", void 0);
        __decorate([
            core.ContentChildren(ClrWizardPage, { descendants: true })
        ], ClrWizard.prototype, "pages", void 0);
        __decorate([
            core.ContentChildren(ClrWizardHeaderAction)
        ], ClrWizard.prototype, "headerActions", void 0);
        __decorate([
            core.ViewChild('wizardTitle')
        ], ClrWizard.prototype, "wizardTitle", void 0);
        ClrWizard = __decorate([ __param(0, core.Inject(core.PLATFORM_ID))
        ], ClrWizard);
ClrWizard.ɵfac = function ClrWizard_Factory(t) { return new (t || ClrWizard)(ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(WizardNavigationService), ɵngcc0.ɵɵdirectiveInject(PageCollectionService), ɵngcc0.ɵɵdirectiveInject(ButtonHubService), ɵngcc0.ɵɵdirectiveInject(HeaderActionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
ClrWizard.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrWizard, selectors: [["clr-wizard"]], contentQueries: function ClrWizard_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrWizardPage, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrWizardHeaderAction, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pages = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerActions = _t);
    } }, viewQuery: function ClrWizard_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c83, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wizardTitle = _t.first);
    } }, hostVars: 10, hostBindings: function ClrWizard_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-wizard", true)("wizard-md", ctx.size == "md")("wizard-lg", ctx.size == "lg")("wizard-xl", ctx.size == "xl")("lastPage", ctx.navService.currentPageIsLast);
    } }, inputs: { size: ["clrWizardSize", "size"], closable: ["clrWizardClosable", "closable"], _stopModalAnimations: ["clrWizardPreventModalAnimation", "_stopModalAnimations"], forceForward: ["clrWizardForceForwardNavigation", "forceForward"], clrWizardOpen: "clrWizardOpen", stopNext: ["clrWizardPreventDefaultNext", "stopNext"], stopCancel: ["clrWizardPreventDefaultCancel", "stopCancel"], stopNavigation: ["clrWizardPreventNavigation", "stopNavigation"], disableStepnav: ["clrWizardDisableStepnav", "disableStepnav"] }, outputs: { _openChanged: "clrWizardOpenChange", onCancel: "clrWizardOnCancel", wizardFinished: "clrWizardOnFinish", onReset: "clrWizardOnReset", currentPageChanged: "clrWizardCurrentPageChanged", onMoveNext: "clrWizardOnNext", onMovePrevious: "clrWizardOnPrevious" }, features: [ɵngcc0.ɵɵProvidersFeature([WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService])], ngContentSelectors: _c85, decls: 17, vars: 11, consts: [[3, "clrModalOpen", "clrModalSize", "clrModalClosable", "clrModalStaticBackdrop", "clrModalSkipAnimation", "clrModalOverrideScrollService", "clrModalPreventClose", "clrModalAlternateClose"], [1, "modal-nav", "clr-wizard-stepnav-wrapper"], [1, "clr-wizard-title"], [1, "modal-title"], ["tabindex", "-1", 1, "modal-title-text"], ["wizardTitle", ""], [3, "ngTemplateOutlet"], ["class", "modal-header-actions-wrapper", 4, "ngIf"], [1, "modal-body"], ["clr-wizard-pages-wrapper", "", 1, "clr-wizard-content"], [1, "modal-footer", "clr-wizard-footer"], [1, "clr-wizard-footer-buttons"], ["class", "clr-wizard-footer-buttons-wrapper", 4, "ngIf"], [1, "modal-header-actions-wrapper"], [4, "ngIf"], [1, "clr-wizard-footer-buttons-wrapper"]], template: function ClrWizard_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c84);
        ɵngcc0.ɵɵelementStart(0, "clr-modal", 0);
        ɵngcc0.ɵɵlistener("clrModalAlternateClose", function ClrWizard_Template_clr_modal_clrModalAlternateClose_0_listener() { return ctx.modalCancel(); });
        ɵngcc0.ɵɵelementStart(1, "nav", 1);
        ɵngcc0.ɵɵelementStart(2, "h1", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "clr-wizard-stepnav");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "h2", 3);
        ɵngcc0.ɵɵelementStart(6, "span", 4, 5);
        ɵngcc0.ɵɵtemplate(8, ClrWizard_ng_template_8_Template, 0, 0, "ng-template", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, ClrWizard_div_9_Template, 3, 2, "div", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 8);
        ɵngcc0.ɵɵelementStart(11, "main", 9);
        ɵngcc0.ɵɵprojection(12, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "div", 10);
        ɵngcc0.ɵɵelementStart(14, "div", 11);
        ɵngcc0.ɵɵtemplate(15, ClrWizard_div_15_Template, 2, 0, "div", 12);
        ɵngcc0.ɵɵtemplate(16, ClrWizard_div_16_Template, 2, 1, "div", 12);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("clrModalOpen", ctx._open)("clrModalSize", ctx.size)("clrModalClosable", ctx.closable)("clrModalStaticBackdrop", true)("clrModalSkipAnimation", ctx.stopModalAnimations)("clrModalOverrideScrollService", ctx.isStatic)("clrModalPreventClose", true);
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.navService.currentPageTitle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.headerActionService.displayHeaderActionsWrapper);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navService.currentPage && !ctx.navService.currentPage.hasButtons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navService.currentPage && ctx.navService.currentPage.hasButtons);
    } }, directives: function () { return [ClrModal,
        ClrWizardStepnav, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf, ClrModalBody]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizard, [{
        type: core.Component,
        args: [{
                selector: 'clr-wizard',
                providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                template: "<!--\n  ~ Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n    [clrModalOpen]=\"_open\"\n    [clrModalSize]=\"size\"\n    [clrModalClosable]=\"closable\"\n    [clrModalStaticBackdrop]=\"true\"\n    [clrModalSkipAnimation]=\"stopModalAnimations\"\n    [clrModalOverrideScrollService]=\"isStatic\"\n    [clrModalPreventClose]=\"true\"\n    (clrModalAlternateClose)=\"modalCancel()\">\n\n    <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n        <h1 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h1>\n        <clr-wizard-stepnav></clr-wizard-stepnav>\n    </nav>\n\n    <h2 class=\"modal-title\">\n        <span tabindex=\"-1\" #wizardTitle class=\"modal-title-text\">\n            <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n        </span>\n\n        <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n            <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                <ng-content select=\"clr-wizard-header-action\"></ng-content>\n            </div>\n            <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n            </div>\n        </div>\n    </h2>\n\n    <div class=\"modal-body\">\n        <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n            <ng-content></ng-content>\n        </main>\n    </div>\n    <div class=\"modal-footer clr-wizard-footer\">\n        <div class=\"clr-wizard-footer-buttons\">\n            <div *ngIf=\"navService.currentPage && !navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-content select=\"clr-wizard-button\"></ng-content>\n            </div>\n            <div *ngIf=\"navService.currentPage && navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n            </div>\n        </div>\n    </div>\n</clr-modal>\n",
                host: {
                    '[class.clr-wizard]': 'true',
                    '[class.wizard-md]': "size == 'md'",
                    '[class.wizard-lg]': "size == 'lg'",
                    '[class.wizard-xl]': "size == 'xl'",
                    '[class.lastPage]': 'navService.currentPageIsLast'
                }
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: WizardNavigationService }, { type: PageCollectionService }, { type: ButtonHubService }, { type: HeaderActionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.IterableDiffers }]; }, { size: [{
            type: core.Input,
            args: ['clrWizardSize']
        }], closable: [{
            type: core.Input,
            args: ['clrWizardClosable']
        }], _stopModalAnimations: [{
            type: core.Input,
            args: ['clrWizardPreventModalAnimation']
        }], _openChanged: [{
            type: core.Output,
            args: ['clrWizardOpenChange']
        }], onCancel: [{
            type: core.Output,
            args: ['clrWizardOnCancel']
        }], wizardFinished: [{
            type: core.Output,
            args: ['clrWizardOnFinish']
        }], onReset: [{
            type: core.Output,
            args: ['clrWizardOnReset']
        }], currentPageChanged: [{
            type: core.Output,
            args: ['clrWizardCurrentPageChanged']
        }], onMoveNext: [{
            type: core.Output,
            args: ['clrWizardOnNext']
        }], onMovePrevious: [{
            type: core.Output,
            args: ['clrWizardOnPrevious']
        }], forceForward: [{
            type: core.Input,
            args: ['clrWizardForceForwardNavigation']
        }], clrWizardOpen: [{
            type: core.Input,
            args: ['clrWizardOpen']
        }], stopNext: [{
            type: core.Input,
            args: ['clrWizardPreventDefaultNext']
        }], stopCancel: [{
            type: core.Input,
            args: ['clrWizardPreventDefaultCancel']
        }], stopNavigation: [{
            type: core.Input,
            args: ['clrWizardPreventNavigation']
        }], disableStepnav: [{
            type: core.Input,
            args: ['clrWizardDisableStepnav']
        }], pages: [{
            type: core.ContentChildren,
            args: [ClrWizardPage, { descendants: true }]
        }], headerActions: [{
            type: core.ContentChildren,
            args: [ClrWizardHeaderAction]
        }], wizardTitle: [{
            type: core.ViewChild,
            args: ['wizardTitle']
        }] }); })();
        return ClrWizard;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DEFAULT_BUTTON_TYPES = {
        cancel: 'cancel',
        previous: 'previous',
        next: 'next',
        finish: 'finish',
        danger: 'danger',
    };
    var CUSTOM_BUTTON_TYPES = {
        cancel: 'custom-cancel',
        previous: 'custom-previous',
        next: 'custom-next',
        finish: 'custom-finish',
        danger: 'custom-danger',
    };
    var ClrWizardButton = /** @class */ (function () {
        function ClrWizardButton(navService, buttonService) {
            this.navService = navService;
            this.buttonService = buttonService;
            this.type = '';
            this.disabled = false;
            this.hidden = false;
            // EventEmitter which is emitted when a button is clicked.
            this.wasClicked = new core.EventEmitter(false);
        }
        ClrWizardButton.prototype.checkDefaultAndCustomType = function (valueToCheck, typeToLookUp) {
            if (valueToCheck === void 0) { valueToCheck = ''; }
            if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
                return true;
            }
            if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
                return true;
            }
            return false;
        };
        Object.defineProperty(ClrWizardButton.prototype, "isCancel", {
            get: function () {
                return this.checkDefaultAndCustomType(this.type, 'cancel');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isNext", {
            get: function () {
                return this.checkDefaultAndCustomType(this.type, 'next');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isPrevious", {
            get: function () {
                return this.checkDefaultAndCustomType(this.type, 'previous');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isFinish", {
            get: function () {
                return this.checkDefaultAndCustomType(this.type, 'finish');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isDanger", {
            get: function () {
                return this.checkDefaultAndCustomType(this.type, 'danger');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isPrimaryAction", {
            get: function () {
                return this.isNext || this.isDanger || this.isFinish;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "_disabledAttribute", {
            get: function () {
                if (this.isDisabled) {
                    return '';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isDisabled", {
            get: function () {
                // dealing with negatives here. cognitively easier to think of it like this...
                var disabled = true;
                var nav = this.navService;
                var page = this.navService.currentPage;
                // Ensure we don't change the response until buttons are ready to avoid chocolate
                if (!this.buttonService.buttonsReady) {
                    return !disabled;
                }
                if (this.disabled || nav.wizardStopNavigation || !page) {
                    return true;
                }
                if (this.isCancel) {
                    return !disabled;
                }
                if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
                    return disabled;
                }
                if (this.isDanger && !page.readyToComplete) {
                    return disabled;
                }
                if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
                    return disabled;
                }
                if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
                    return disabled;
                }
                return !disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isHidden", {
            get: function () {
                // dealing with negatives here. cognitively easier to think of it like this...
                var hidden = true;
                var nav = this.navService;
                // Ensure we don't change the response until buttons are ready to avoid chocolate
                if (!this.buttonService.buttonsReady) {
                    return !hidden;
                }
                if (this.hidden) {
                    return true;
                }
                if (this.isCancel) {
                    return !hidden;
                }
                if (this.isPrevious && nav.currentPageIsFirst) {
                    return hidden;
                }
                if (this.isNext && nav.currentPageIsLast) {
                    return hidden;
                }
                if (this.isFinish && !nav.currentPageIsLast) {
                    return hidden;
                }
                return !hidden;
            },
            enumerable: true,
            configurable: true
        });
        ClrWizardButton.prototype.click = function () {
            if (this.isDisabled) {
                return;
            }
            this.wasClicked.emit(this.type);
            this.buttonService.buttonClicked(this.type);
        };
        ClrWizardButton.ctorParameters = function () { return [
            { type: WizardNavigationService },
            { type: ButtonHubService }
        ]; };
        __decorate([
            core.Input('type')
        ], ClrWizardButton.prototype, "type", void 0);
        __decorate([
            core.Input('clrWizardButtonDisabled')
        ], ClrWizardButton.prototype, "disabled", void 0);
        __decorate([
            core.Input('clrWizardButtonHidden')
        ], ClrWizardButton.prototype, "hidden", void 0);
        __decorate([
            core.Output('clrWizardButtonClicked')
        ], ClrWizardButton.prototype, "wasClicked", void 0);
ClrWizardButton.ɵfac = function ClrWizardButton_Factory(t) { return new (t || ClrWizardButton)(ɵngcc0.ɵɵdirectiveInject(WizardNavigationService), ɵngcc0.ɵɵdirectiveInject(ButtonHubService)); };
ClrWizardButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrWizardButton, selectors: [["clr-wizard-button"]], hostAttrs: [1, "clr-wizard-btn-wrapper"], hostVars: 1, hostBindings: function ClrWizardButton_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.isHidden);
    } }, inputs: { type: "type", disabled: ["clrWizardButtonDisabled", "disabled"], hidden: ["clrWizardButtonHidden", "hidden"] }, outputs: { wasClicked: "clrWizardButtonClicked" }, ngContentSelectors: _c1, decls: 2, vars: 19, consts: [["type", "button", 1, "btn", "clr-wizard-btn", 3, "click"]], template: function ClrWizardButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ClrWizardButton_Template_button_click_0_listener() { return ctx.click(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("btn-link", ctx.isCancel)("clr-wizard-btn--tertiary", ctx.isCancel)("btn-outline", ctx.isPrevious)("clr-wizard-btn--secondary", ctx.isPrevious)("btn-primary", ctx.isPrimaryAction)("clr-wizard-btn--primary", ctx.isPrimaryAction)("btn-success", ctx.isFinish)("btn-danger", ctx.isDanger)("disabled", ctx.isDisabled);
        ɵngcc0.ɵɵattribute("disabled", ctx._disabledAttribute);
    } }, styles: ["[aria-hidden=\"true\"][_ngcontent-%COMP%] { display: none; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardButton, [{
        type: core.Component,
        args: [{
                selector: 'clr-wizard-button',
                template: "\n        <button\n            type=\"button\"\n            class=\"btn clr-wizard-btn\"\n            [class.btn-link]=\"isCancel\"\n            [class.clr-wizard-btn--tertiary]=\"isCancel\"\n            [class.btn-outline]=\"isPrevious\"\n            [class.clr-wizard-btn--secondary]=\"isPrevious\"\n            [class.btn-primary]=\"isPrimaryAction\"\n            [class.clr-wizard-btn--primary]=\"isPrimaryAction\"\n            [class.btn-success]=\"isFinish\"\n            [class.btn-danger]=\"isDanger\"\n            [class.disabled]=\"isDisabled\"\n            [attr.disabled]=\"_disabledAttribute\"\n            (click)=\"click()\">\n            <ng-content></ng-content>\n        </button>\n    ",
                host: { class: 'clr-wizard-btn-wrapper', '[attr.aria-hidden]': 'isHidden' },
                styles: ['[aria-hidden="true"] { display: none; }']
            }]
    }], function () { return [{ type: WizardNavigationService }, { type: ButtonHubService }]; }, { type: [{
            type: core.Input,
            args: ['type']
        }], disabled: [{
            type: core.Input,
            args: ['clrWizardButtonDisabled']
        }], hidden: [{
            type: core.Input,
            args: ['clrWizardButtonHidden']
        }], wasClicked: [{
            type: core.Output,
            args: ['clrWizardButtonClicked']
        }] }); })();
        return ClrWizardButton;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardCustomTags = /** @class */ (function () {
        function ClrWizardCustomTags() {
        }
ClrWizardCustomTags.ɵfac = function ClrWizardCustomTags_Factory(t) { return new (t || ClrWizardCustomTags)(); };
ClrWizardCustomTags.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrWizardCustomTags, selectors: [["clr-wizard-title"], ["clr-wizard-pagetitle"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardCustomTags, [{
        type: core.Directive,
        args: [{ selector: 'clr-wizard-title, clr-wizard-pagetitle' }]
    }], function () { return []; }, null); })();
        return ClrWizardCustomTags;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardStepnav = /** @class */ (function () {
        function ClrWizardStepnav(pageService) {
            this.pageService = pageService;
        }
        ClrWizardStepnav.ctorParameters = function () { return [
            { type: PageCollectionService }
        ]; };
ClrWizardStepnav.ɵfac = function ClrWizardStepnav_Factory(t) { return new (t || ClrWizardStepnav)(ɵngcc0.ɵɵdirectiveInject(PageCollectionService)); };
ClrWizardStepnav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrWizardStepnav, selectors: [["clr-wizard-stepnav"]], hostAttrs: [1, "clr-wizard-stepnav"], decls: 2, vars: 1, consts: [[1, "clr-wizard-stepnav-list"], ["clr-wizard-stepnav-item", "", "class", "clr-wizard-stepnav-item", 3, "page", 4, "ngFor", "ngForOf"], ["clr-wizard-stepnav-item", "", 1, "clr-wizard-stepnav-item", 3, "page"]], template: function ClrWizardStepnav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ClrWizardStepnav_div_1_Template, 2, 2, "div", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pageService.pages);
    } }, directives: function () { return [ɵngcc1.NgForOf, ClrWizardStepnavItem]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardStepnav, [{
        type: core.Component,
        args: [{
                selector: 'clr-wizard-stepnav',
                template: "\n    <div class=\"clr-wizard-stepnav-list\">\n      <div *ngFor=\"let page of pageService.pages; let i = index\" clr-wizard-stepnav-item [page]=\"page\" class=\"clr-wizard-stepnav-item\">{{i + 1}}</div>\n    </div>\n  ",
                host: { class: 'clr-wizard-stepnav' }
            }]
    }], function () { return [{ type: PageCollectionService }]; }, null); })();
        return ClrWizardStepnav;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrWizardStepnavItem = /** @class */ (function () {
        function ClrWizardStepnavItem(navService, pageCollection) {
            this.navService = navService;
            this.pageCollection = pageCollection;
        }
        ClrWizardStepnavItem.prototype.pageGuard = function () {
            if (!this.page) {
                throw new Error('Wizard stepnav item is not associated with a wizard page.');
            }
        };
        Object.defineProperty(ClrWizardStepnavItem.prototype, "id", {
            get: function () {
                this.pageGuard();
                return this.pageCollection.getStepItemIdForPage(this.page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isDisabled", {
            get: function () {
                this.pageGuard();
                return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isCurrent", {
            get: function () {
                this.pageGuard();
                return this.page.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isComplete", {
            get: function () {
                this.pageGuard();
                return this.page.completed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "hasError", {
            get: function () {
                this.pageGuard();
                return this.page.hasError && this.isComplete;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "canNavigate", {
            get: function () {
                this.pageGuard();
                return this.pageCollection.previousPageIsCompleted(this.page);
            },
            enumerable: true,
            configurable: true
        });
        ClrWizardStepnavItem.prototype.click = function () {
            this.pageGuard();
            // if we click on our own stepnav or a disabled stepnav, we don't want to do anything
            if (this.isDisabled || this.isCurrent) {
                return;
            }
            this.navService.goTo(this.page);
        };
        ClrWizardStepnavItem.ctorParameters = function () { return [
            { type: WizardNavigationService },
            { type: PageCollectionService }
        ]; };
        __decorate([
            core.Input('page')
        ], ClrWizardStepnavItem.prototype, "page", void 0);
ClrWizardStepnavItem.ɵfac = function ClrWizardStepnavItem_Factory(t) { return new (t || ClrWizardStepnavItem)(ɵngcc0.ɵɵdirectiveInject(WizardNavigationService), ɵngcc0.ɵɵdirectiveInject(PageCollectionService)); };
ClrWizardStepnavItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrWizardStepnavItem, selectors: [["", "clr-wizard-stepnav-item", ""]], hostVars: 17, hostBindings: function ClrWizardStepnavItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
        ɵngcc0.ɵɵattribute("aria-selected", ctx.isCurrent)("aria-controls", ctx.id);
        ɵngcc0.ɵɵclassProp("clr-nav-link", true)("nav-item", true)("active", ctx.isCurrent)("disabled", ctx.isDisabled)("no-click", !ctx.canNavigate)("complete", ctx.isComplete)("error", ctx.hasError);
    } }, inputs: { page: "page" }, attrs: _c86, ngContentSelectors: _c1, decls: 6, vars: 4, consts: [["type", "button", 1, "btn", "btn-link", "clr-wizard-stepnav-link", 3, "click"], [1, "clr-wizard-stepnav-link-suffix"], ["shape", "error-standard", "class", "is-error clr-wizard-stepnav-item-error-icon", 4, "ngIf"], [4, "ngIf"], [1, "clr-wizard-stepnav-link-title"], [3, "ngTemplateOutlet"], ["shape", "error-standard", 1, "is-error", "clr-wizard-stepnav-item-error-icon"]], template: function ClrWizardStepnavItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ClrWizardStepnavItem_Template_button_click_0_listener() { return ctx.click(); });
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, ClrWizardStepnavItem_clr_icon_2_Template, 1, 0, "clr-icon", 2);
        ɵngcc0.ɵɵtemplate(3, ClrWizardStepnavItem_3_Template, 1, 0, undefined, 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵtemplate(5, ClrWizardStepnavItem_ng_template_5_Template, 0, 0, "ng-template", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("disabled", ctx.isDisabled ? "" : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasError);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasError);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.page.navTitle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ClrIconCustomTag], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardStepnavItem, [{
        type: core.Component,
        args: [{
                selector: '[clr-wizard-stepnav-item]',
                template: "\n        <button type=\"button\" class=\"btn btn-link clr-wizard-stepnav-link\" (click)=\"click()\" [attr.disabled]=\"isDisabled ? '' : null\">\n            <span class=\"clr-wizard-stepnav-link-suffix\">\n              <clr-icon shape=\"error-standard\" class=\"is-error clr-wizard-stepnav-item-error-icon\" *ngIf=\"hasError\"></clr-icon>\n              <ng-content *ngIf=\"!hasError\"></ng-content>              \n            </span>\n            <span class=\"clr-wizard-stepnav-link-title\">\n              <ng-template [ngTemplateOutlet]=\"page.navTitle\"></ng-template> \n            </span>\n        </button>\n    ",
                host: {
                    '[id]': 'id',
                    '[attr.aria-selected]': 'isCurrent',
                    '[attr.aria-controls]': 'id',
                    '[class.clr-nav-link]': 'true',
                    '[class.nav-item]': 'true',
                    '[class.active]': 'isCurrent',
                    '[class.disabled]': 'isDisabled',
                    '[class.no-click]': '!canNavigate',
                    '[class.complete]': 'isComplete',
                    '[class.error]': 'hasError'
                }
            }]
    }], function () { return [{ type: WizardNavigationService }, { type: PageCollectionService }]; }, { page: [{
            type: core.Input,
            args: ['page']
        }] }); })();
        return ClrWizardStepnavItem;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_WIZARD_DIRECTIVES = [
        ClrWizard,
        ClrWizardPage,
        ClrWizardStepnav,
        ClrWizardStepnavItem,
        ClrWizardButton,
        ClrWizardHeaderAction,
        ClrWizardCustomTags,
        ClrWizardPageTitle,
        ClrWizardPageNavTitle,
        ClrWizardPageButtons,
        ClrWizardPageHeaderActions,
    ];
    var ClrWizardModule = /** @class */ (function () {
        function ClrWizardModule() {
        }
ClrWizardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrWizardModule });
ClrWizardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrWizardModule_Factory(t) { return new (t || ClrWizardModule)(); }, imports: [[common.CommonModule, ClrModalModule, ClrAlertModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrWizardModule, { declarations: [ClrWizard,
        ClrWizardPage,
        ClrWizardStepnav,
        ClrWizardStepnavItem,
        ClrWizardButton,
        ClrWizardHeaderAction,
        ClrWizardCustomTags,
        ClrWizardPageTitle,
        ClrWizardPageNavTitle,
        ClrWizardPageButtons,
        ClrWizardPageHeaderActions], imports: [ɵngcc1.CommonModule, ClrModalModule,
        ClrAlertModule], exports: [ClrWizard,
        ClrWizardPage,
        ClrWizardStepnav,
        ClrWizardStepnavItem,
        ClrWizardButton,
        ClrWizardHeaderAction,
        ClrWizardCustomTags,
        ClrWizardPageTitle,
        ClrWizardPageNavTitle,
        ClrWizardPageButtons,
        ClrWizardPageHeaderActions] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrWizardModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrModalModule, ClrAlertModule],
                declarations: [CLR_WIZARD_DIRECTIVES],
                exports: [CLR_WIZARD_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrWizardModule;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var AccordionStrategy;
    (function (AccordionStrategy) {
        AccordionStrategy["Default"] = "default";
        AccordionStrategy["Multi"] = "multi";
    })(AccordionStrategy || (AccordionStrategy = {}));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var AccordionStatus;
    (function (AccordionStatus) {
        AccordionStatus["Inactive"] = "inactive";
        AccordionStatus["Error"] = "error";
        AccordionStatus["Complete"] = "complete";
    })(AccordionStatus || (AccordionStatus = {}));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var accordionCount = 0;
    var AccordionPanelModel = /** @class */ (function () {
        function AccordionPanelModel(id, accordionId) {
            this.id = id;
            this.accordionId = accordionId;
            this.status = AccordionStatus.Inactive;
            this.index = null;
            this.disabled = false;
            this.open = false;
            this.templateId = this.id + "-" + this.accordionId;
        }
        return AccordionPanelModel;
    }());
    var AccordionModel = /** @class */ (function () {
        function AccordionModel() {
            this.strategy = AccordionStrategy.Default;
            this.accordionCount = accordionCount++;
            this._panels = {};
        }
        Object.defineProperty(AccordionModel.prototype, "panels", {
            get: function () {
                var _this = this;
                return Object.keys(this._panels).map(function (id) { return _this._panels[id]; });
            },
            enumerable: true,
            configurable: true
        });
        AccordionModel.prototype.setStrategy = function (strategy) {
            this.strategy = strategy;
        };
        AccordionModel.prototype.updatePanelOrder = function (ids) {
            var _this = this;
            ids.forEach(function (id, index) { return (_this._panels[id].index = index); });
            this.removeOldPanels(ids);
        };
        AccordionModel.prototype.addPanel = function (id, open) {
            if (open === void 0) { open = false; }
            this._panels[id] = new AccordionPanelModel(id, this.accordionCount);
            this._panels[id].open = open;
        };
        AccordionModel.prototype.togglePanel = function (panelId, open) {
            var panelIsOpen = this._panels[panelId].open;
            if (this.strategy === AccordionStrategy.Default) {
                this.closeAllPanels();
            }
            this._panels[panelId].open = open !== undefined ? open : !panelIsOpen;
        };
        AccordionModel.prototype.disablePanel = function (panelId, disabled) {
            this._panels[panelId].disabled = disabled;
        };
        AccordionModel.prototype.closeAllPanels = function () {
            var _this = this;
            this.panels.forEach(function (panel) { return (_this._panels[panel.id].open = false); });
        };
        AccordionModel.prototype.removeOldPanels = function (ids) {
            var _this = this;
            this.panels
                .filter(function (panel) { return ids.find(function (id) { return id === panel.id; }) === undefined; })
                .forEach(function (panel) { return delete _this._panels[panel.id]; });
        };
        return AccordionModel;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var AccordionService = /** @class */ (function () {
        function AccordionService() {
            this.accordion = new AccordionModel();
            this._panelsChanges = new rxjs.BehaviorSubject(this.accordion.panels);
        }
        AccordionService.prototype.getPanelChanges = function (panelId) {
            return this._panelsChanges.pipe(operators.map(function (panels) { return panels.find(function (s) { return s.id === panelId; }); }));
        };
        AccordionService.prototype.setStrategy = function (strategy) {
            this.accordion.setStrategy(strategy);
        };
        AccordionService.prototype.addPanel = function (panelId, open) {
            if (open === void 0) { open = false; }
            this.accordion.addPanel(panelId, open);
            this.emitUpdatedPanels();
        };
        AccordionService.prototype.togglePanel = function (panelId, open) {
            this.accordion.togglePanel(panelId, open);
            this.emitUpdatedPanels();
        };
        AccordionService.prototype.disablePanel = function (panelId, disabled) {
            this.accordion.disablePanel(panelId, disabled);
            this.emitUpdatedPanels();
        };
        AccordionService.prototype.updatePanelOrder = function (ids) {
            this.accordion.updatePanelOrder(ids);
            this.emitUpdatedPanels();
        };
        AccordionService.prototype.emitUpdatedPanels = function () {
            this._panelsChanges.next(this.accordion.panels);
        };
AccordionService.ɵfac = function AccordionService_Factory(t) { return new (t || AccordionService)(); };
AccordionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AccordionService, factory: function (t) { return AccordionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AccordionService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return AccordionService;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var defaultAnimationTiming = '0.2s ease-in-out';

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var panelAnimation = [
        animations.trigger('skipInitialRender', [animations.transition(':enter', [])]),
        animations.trigger('toggle', [
            animations.transition('void => *', [
                animations.style({ display: 'block', height: 0 }),
                animations.animate(defaultAnimationTiming, animations.style({ height: '*' })),
            ]),
        ]),
    ];
    var stepAnimation = [
        animations.trigger('skipInitialRender', [animations.transition(':enter', [])]),
        animations.trigger('toggle', [
            animations.transition('void => *', [
                animations.style({ display: 'block', height: 0 }),
                animations.animate(defaultAnimationTiming, animations.style({ height: '*' })),
            ]),
            animations.transition('* => void', [
                animations.style({ display: 'block' }),
                animations.animate(defaultAnimationTiming, animations.style({ height: 0, display: 'none' })),
            ]),
        ]),
    ];

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAccordionDescription = /** @class */ (function () {
        function ClrAccordionDescription() {
        }
ClrAccordionDescription.ɵfac = function ClrAccordionDescription_Factory(t) { return new (t || ClrAccordionDescription)(); };
ClrAccordionDescription.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAccordionDescription, selectors: [["clr-accordion-description"], ["clr-step-description"]], hostVars: 2, hostBindings: function ClrAccordionDescription_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-accordion-description", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrAccordionDescription_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAccordionDescription, [{
        type: core.Component,
        args: [{
                selector: 'clr-accordion-description, clr-step-description',
                template: "<ng-content></ng-content>",
                host: { '[class.clr-accordion-description]': 'true' },
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, null); })();
        return ClrAccordionDescription;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAccordionPanel = /** @class */ (function () {
        function ClrAccordionPanel(commonStrings, accordionService, ifExpandService, id) {
            this.commonStrings = commonStrings;
            this.accordionService = accordionService;
            this.ifExpandService = ifExpandService;
            this.id = id;
            this.disabled = false;
            this.panelOpen = false;
            this.panelOpenChange = new core.EventEmitter();
            this.AccordionStatus = AccordionStatus;
            this.isAccordion = true;
        }
        ClrAccordionPanel.prototype.ngOnInit = function () {
            var _this = this;
            this.panel = this.accordionService.getPanelChanges(this.id).pipe(operators.tap(function (panel) { return _this.emitPanelChange(panel); }));
            this.accordionService.addPanel(this.id, this.panelOpen);
            this.accordionService.togglePanel(this.id, this.panelOpen);
            this.accordionService.disablePanel(this.id, this.disabled);
        };
        ClrAccordionPanel.prototype.ngOnChanges = function (changes) {
            if (this.panel && changes.panelOpen && changes.panelOpen.currentValue !== changes.panelOpen.previousValue) {
                this.accordionService.togglePanel(this.id, changes.panelOpen.currentValue);
            }
            if (this.panel && changes.disabled && changes.disabled.currentValue !== changes.disabled.previousValue) {
                this.accordionService.disablePanel(this.id, changes.disabled.currentValue);
            }
        };
        ClrAccordionPanel.prototype.togglePanel = function () {
            this.accordionService.togglePanel(this.id);
        };
        ClrAccordionPanel.prototype.collapsePanelOnAnimationDone = function (panel) {
            if (!panel.open) {
                this.ifExpandService.expanded = false;
            }
        };
        ClrAccordionPanel.prototype.getPanelStateClasses = function (panel) {
            return "clr-accordion-panel-" + panel.status + " " + (panel.open ? 'clr-accordion-panel-open' : '');
        };
        ClrAccordionPanel.prototype.getAccordionContentId = function (id) {
            return "clr-accordion-content-" + id + "'";
        };
        ClrAccordionPanel.prototype.getAccordionHeaderId = function (id) {
            return "clr-accordion-header-" + id;
        };
        ClrAccordionPanel.prototype.emitPanelChange = function (panel) {
            this.panelOpenChange.emit(panel.open);
            if (panel.open) {
                this.ifExpandService.expanded = true;
            }
        };
        ClrAccordionPanel.ctorParameters = function () { return [
            { type: ClrCommonStringsService },
            { type: AccordionService },
            { type: IfExpandService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        __decorate([
            core.Input('clrAccordionPanelDisabled')
        ], ClrAccordionPanel.prototype, "disabled", void 0);
        __decorate([
            core.Input('clrAccordionPanelOpen')
        ], ClrAccordionPanel.prototype, "panelOpen", void 0);
        __decorate([
            core.Output('clrAccordionPanelOpenChange')
        ], ClrAccordionPanel.prototype, "panelOpenChange", void 0);
        __decorate([
            core.ContentChildren(ClrAccordionDescription)
        ], ClrAccordionPanel.prototype, "accordionDescription", void 0);
        ClrAccordionPanel = __decorate([ __param(3, core.Inject(UNIQUE_ID))
        ], ClrAccordionPanel);
ClrAccordionPanel.ɵfac = function ClrAccordionPanel_Factory(t) { return new (t || ClrAccordionPanel)(ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(AccordionService), ɵngcc0.ɵɵdirectiveInject(IfExpandService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrAccordionPanel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAccordionPanel, selectors: [["clr-accordion-panel"]], contentQueries: function ClrAccordionPanel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrAccordionDescription, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.accordionDescription = _t);
    } }, hostVars: 2, hostBindings: function ClrAccordionPanel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-accordion-panel", true);
    } }, inputs: { disabled: ["clrAccordionPanelDisabled", "disabled"], panelOpen: ["clrAccordionPanelOpen", "panelOpen"] }, outputs: { panelOpenChange: "clrAccordionPanelOpenChange" }, features: [ɵngcc0.ɵɵProvidersFeature([IfExpandService, UNIQUE_ID_PROVIDER]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c88, decls: 2, vars: 3, consts: [[4, "ngIf"], ["aria-live", "assertive", "class", "clr-sr-only", 4, "ngIf"], ["role", "group", 3, "ngClass"], [1, "clr-accordion-header"], ["type", "button", 1, "clr-accordion-header-button", 3, "id", "disabled", "click"], ["headerButton", ""], [1, "clr-sr-only"], [1, "clr-accordion-status"], ["shape", "angle", "dir", "right", 1, "clr-accordion-angle"], [1, "clr-accordion-number"], ["shape", "exclamation-circle", 1, "clr-accordion-error-icon"], ["shape", "check-circle", 1, "clr-accordion-complete-icon"], ["role", "region", 3, "id"], ["class", "clr-accordion-content", 4, "ngIf"], ["aria-live", "assertive", 1, "clr-sr-only"], [1, "clr-accordion-content"], [1, "clr-accordion-inner-content"]], template: function ClrAccordionPanel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c87);
        ɵngcc0.ɵɵtemplate(0, ClrAccordionPanel_ng_container_0_Template, 19, 18, "ng-container", 0);
        ɵngcc0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.panel));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrIconCustomTag], pipes: [ɵngcc1.AsyncPipe], encapsulation: 2, data: { animation: panelAnimation }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAccordionPanel, [{
        type: core.Component,
        args: [{
                selector: 'clr-accordion-panel',
                template: "<ng-container *ngIf=\"panel | async; let panel\">\n  <div *ngIf=\"panel.status !== AccordionStatus.Inactive\" aria-live=\"assertive\" class=\"clr-sr-only\">\n    <ng-container *ngIf=\"panel.status === AccordionStatus.Error\">{{commonStrings.keys.danger}}</ng-container>\n  </div>\n\n  <div role=\"group\" [ngClass]=\"getPanelStateClasses(panel)\">\n    <div class=\"clr-accordion-header\">\n      <button\n        type=\"button\"\n        class=\"clr-accordion-header-button\"\n        (click)=\"togglePanel()\"\n        [id]=\"getAccordionHeaderId(panel.templateId)\"\n        [disabled]=\"isAccordion && panel.disabled\"\n        [attr.aria-disabled]=\"!isAccordion && panel.disabled\"\n        [attr.aria-controls]=\"getAccordionContentId(panel.templateId)\"\n        [attr.aria-expanded]=\"panel.open\"\n        [class.clr-accordion-header-has-description]=\"(accordionDescription.changes | async)?.length || accordionDescription.length\"\n        #headerButton\n      >\n        <span class=\"clr-sr-only\">\n          <ng-container *ngIf=\"panel.status === AccordionStatus.Error\">{{commonStrings.keys.danger}}</ng-container>\n          <ng-container *ngIf=\"panel.status === AccordionStatus.Complete\">{{commonStrings.keys.success}}</ng-container>\n        </span>\n        <span class=\"clr-accordion-status\">\n          <clr-icon shape=\"angle\" dir=\"right\" class=\"clr-accordion-angle\"></clr-icon>\n          <span class=\"clr-accordion-number\"></span>\n          <clr-icon shape=\"exclamation-circle\" class=\"clr-accordion-error-icon\"></clr-icon>\n          <clr-icon shape=\"check-circle\" class=\"clr-accordion-complete-icon\"></clr-icon>\n        </span>\n        <ng-content select=\"clr-accordion-title, clr-step-title\"></ng-content>\n        <ng-content select=\"clr-accordion-description, clr-step-description\"></ng-content>\n      </button>\n    </div>\n    <div\n      @skipInitialRender\n      role=\"region\"\n      [id]=\"getAccordionContentId(panel.templateId)\"\n      [attr.aria-hidden]=\"!panel.open\"\n      [attr.aria-labelledby]=\"getAccordionHeaderId(panel.templateId)\"\n    >\n      <div\n        *ngIf=\"panel.open\"\n        @toggle\n        (@toggle.done)=\"collapsePanelOnAnimationDone(panel)\"\n        class=\"clr-accordion-content\">\n        <div class=\"clr-accordion-inner-content\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n",
                host: { '[class.clr-accordion-panel]': 'true' },
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: panelAnimation,
                providers: [IfExpandService, UNIQUE_ID_PROVIDER]
            }]
    }], function () { return [{ type: ClrCommonStringsService }, { type: AccordionService }, { type: IfExpandService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, { disabled: [{
            type: core.Input,
            args: ['clrAccordionPanelDisabled']
        }], panelOpen: [{
            type: core.Input,
            args: ['clrAccordionPanelOpen']
        }], panelOpenChange: [{
            type: core.Output,
            args: ['clrAccordionPanelOpenChange']
        }], accordionDescription: [{
            type: core.ContentChildren,
            args: [ClrAccordionDescription]
        }] }); })();
        return ClrAccordionPanel;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAccordionTitle = /** @class */ (function () {
        function ClrAccordionTitle() {
        }
ClrAccordionTitle.ɵfac = function ClrAccordionTitle_Factory(t) { return new (t || ClrAccordionTitle)(); };
ClrAccordionTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAccordionTitle, selectors: [["clr-accordion-title"], ["clr-step-title"]], hostVars: 2, hostBindings: function ClrAccordionTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-accordion-title", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrAccordionTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAccordionTitle, [{
        type: core.Component,
        args: [{
                selector: 'clr-accordion-title, clr-step-title',
                template: "<ng-content></ng-content>",
                host: { '[class.clr-accordion-title]': 'true' },
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, null); })();
        return ClrAccordionTitle;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAccordion = /** @class */ (function () {
        function ClrAccordion(accordionService) {
            this.accordionService = accordionService;
            this.multiPanel = false;
            this.subscriptions = [];
        }
        ClrAccordion.prototype.ngOnInit = function () {
            this.setAccordionStrategy();
        };
        ClrAccordion.prototype.ngOnChanges = function (changes) {
            if (changes.multiPanel.currentValue !== changes.multiPanel.previousValue) {
                this.setAccordionStrategy();
            }
        };
        ClrAccordion.prototype.ngAfterViewInit = function () {
            this.subscriptions.push(this.listenForDOMChanges());
        };
        ClrAccordion.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ClrAccordion.prototype.setAccordionStrategy = function () {
            var strategy = this.multiPanel ? AccordionStrategy.Multi : AccordionStrategy.Default;
            this.accordionService.setStrategy(strategy);
        };
        ClrAccordion.prototype.listenForDOMChanges = function () {
            var _this = this;
            return this.panels.changes
                .pipe(operators.startWith(this.panels))
                .subscribe(function (panels) { return _this.accordionService.updatePanelOrder(panels.toArray().map(function (p) { return p.id; })); });
        };
        ClrAccordion.ctorParameters = function () { return [
            { type: AccordionService }
        ]; };
        __decorate([
            core.Input('clrAccordionMultiPanel')
        ], ClrAccordion.prototype, "multiPanel", void 0);
        __decorate([
            core.ContentChildren(ClrAccordionPanel, { descendants: true })
        ], ClrAccordion.prototype, "panels", void 0);
ClrAccordion.ɵfac = function ClrAccordion_Factory(t) { return new (t || ClrAccordion)(ɵngcc0.ɵɵdirectiveInject(AccordionService)); };
ClrAccordion.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAccordion, selectors: [["clr-accordion"]], contentQueries: function ClrAccordion_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrAccordionPanel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panels = _t);
    } }, hostVars: 2, hostBindings: function ClrAccordion_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-accordion", true);
    } }, inputs: { multiPanel: ["clrAccordionMultiPanel", "multiPanel"] }, features: [ɵngcc0.ɵɵProvidersFeature([AccordionService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrAccordion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAccordion, [{
        type: core.Component,
        args: [{
                selector: 'clr-accordion',
                template: "<ng-content></ng-content>",
                host: { '[class.clr-accordion]': 'true' },
                providers: [AccordionService],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: AccordionService }]; }, { multiPanel: [{
            type: core.Input,
            args: ['clrAccordionMultiPanel']
        }], panels: [{
            type: core.ContentChildren,
            args: [ClrAccordionPanel, { descendants: true }]
        }] }); })();
        return ClrAccordion;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrAccordionContent = /** @class */ (function () {
        function ClrAccordionContent() {
        }
ClrAccordionContent.ɵfac = function ClrAccordionContent_Factory(t) { return new (t || ClrAccordionContent)(); };
ClrAccordionContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrAccordionContent, selectors: [["clr-accordion-content"], ["clr-step-content"]], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrAccordionContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAccordionContent, [{
        type: core.Component,
        args: [{
                selector: 'clr-accordion-content, clr-step-content',
                template: "<ng-content></ng-content>",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, null); })();
        return ClrAccordionContent;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var AccordionWillyWonka = /** @class */ (function (_super) {
        __extends(AccordionWillyWonka, _super);
        function AccordionWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
AccordionWillyWonka.ɵfac = function AccordionWillyWonka_Factory(t) { return ɵAccordionWillyWonka_BaseFactory(t || AccordionWillyWonka); };
AccordionWillyWonka.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AccordionWillyWonka, selectors: [["clr-accordion"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
var ɵAccordionWillyWonka_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AccordionWillyWonka);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AccordionWillyWonka, [{
        type: core.Directive,
        args: [{ selector: 'clr-accordion' }]
    }], null, null); })();
        return AccordionWillyWonka;
    }(WillyWonka));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var AccordionOompaLoompa = /** @class */ (function (_super) {
        __extends(AccordionOompaLoompa, _super);
        function AccordionOompaLoompa(cdr, willyWonka, ifExpandService) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-accordion-panel should only be used inside of clr-accordion');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.expand = ifExpandService;
            return _this;
        }
        Object.defineProperty(AccordionOompaLoompa.prototype, "flavor", {
            get: function () {
                return this.expand.expanded;
            },
            enumerable: true,
            configurable: true
        });
        AccordionOompaLoompa.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: AccordionWillyWonka, decorators: [{ type: core.Optional }] },
            { type: IfExpandService }
        ]; };
        AccordionOompaLoompa = __decorate([ __param(1, core.Optional())
        ], AccordionOompaLoompa);
AccordionOompaLoompa.ɵfac = function AccordionOompaLoompa_Factory(t) { return new (t || AccordionOompaLoompa)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(AccordionWillyWonka, 8), ɵngcc0.ɵɵdirectiveInject(IfExpandService)); };
AccordionOompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AccordionOompaLoompa, selectors: [["clr-accordion-panel"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AccordionOompaLoompa, [{
        type: core.Directive,
        args: [{ selector: 'clr-accordion-panel' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: AccordionWillyWonka, decorators: [{
                type: core.Optional
            }] }, { type: IfExpandService }]; }, null); })();
        return AccordionOompaLoompa;
    }(OompaLoompa));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var declarations = [
        ClrAccordion,
        ClrAccordionPanel,
        ClrAccordionTitle,
        ClrAccordionDescription,
        ClrAccordionContent,
        AccordionOompaLoompa,
        AccordionWillyWonka,
    ];
    var ClrAccordionModule = /** @class */ (function () {
        function ClrAccordionModule() {
        }
ClrAccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrAccordionModule });
ClrAccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrAccordionModule_Factory(t) { return new (t || ClrAccordionModule)(); }, imports: [[common.CommonModule, ClrIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrAccordionModule, { declarations: [ClrAccordion,
        ClrAccordionPanel,
        ClrAccordionTitle,
        ClrAccordionDescription,
        ClrAccordionContent,
        AccordionOompaLoompa,
        AccordionWillyWonka], imports: [ɵngcc1.CommonModule, ClrIconModule], exports: [ClrAccordion,
        ClrAccordionPanel,
        ClrAccordionTitle,
        ClrAccordionDescription,
        ClrAccordionContent,
        AccordionOompaLoompa,
        AccordionWillyWonka] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrAccordionModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule],
                declarations: __spread(declarations),
                exports: __spread(declarations)
            }]
    }], function () { return []; }, null); })();
        return ClrAccordionModule;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var StepperModel = /** @class */ (function (_super) {
        __extends(StepperModel, _super);
        function StepperModel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.stepperModelInitialize = false;
            return _this;
        }
        Object.defineProperty(StepperModel.prototype, "allPanelsCompleted", {
            get: function () {
                return this.panels.length && this.getNumberOfIncompletePanels() === 0 && this.getNumberOfOpenPanels() === 0;
            },
            enumerable: true,
            configurable: true
        });
        StepperModel.prototype.addPanel = function (id, open) {
            if (open === void 0) { open = false; }
            _super.prototype.addPanel.call(this, id, open);
            this._panels[id].disabled = true;
        };
        StepperModel.prototype.updatePanelOrder = function (ids) {
            _super.prototype.updatePanelOrder.call(this, ids);
            if (this.stepperModelInitialize === false) {
                this.openFirstPanel();
            }
        };
        StepperModel.prototype.togglePanel = function (panelId) {
            if (this._panels[panelId].status === AccordionStatus.Complete) {
                this._panels[panelId].open = !this._panels[panelId].open;
            }
        };
        StepperModel.prototype.navigateToNextPanel = function (currentPanelId, currentPanelValid) {
            if (currentPanelValid === void 0) { currentPanelValid = true; }
            if (currentPanelValid) {
                this.completePanel(currentPanelId);
                this.openNextPanel(this._panels[currentPanelId].id);
            }
            else {
                this.setPanelError(currentPanelId);
            }
        };
        StepperModel.prototype.overrideInitialPanel = function (panelId) {
            var _this = this;
            this.panels.filter(function () { return _this._panels[panelId] !== undefined; }).forEach(function (panel) {
                if (panel.index < _this._panels[panelId].index) {
                    _this.completePanel(panel.id);
                }
                else if (panel.id === panelId) {
                    _this._panels[panel.id].open = true;
                }
                else {
                    _this._panels[panel.id].open = false;
                }
            });
        };
        StepperModel.prototype.setPanelsWithErrors = function (ids) {
            var _this = this;
            ids.forEach(function (id) { return _this.setPanelError(id); });
        };
        StepperModel.prototype.resetPanels = function () {
            var _this = this;
            /* return stepper to initialize state */
            this.stepperModelInitialize = false;
            this.panels.forEach(function (p) { return _this.resetPanel(p.id); });
            this.openFirstPanel();
        };
        StepperModel.prototype.getNextPanel = function (currentPanelId) {
            var _this = this;
            return this.panels.find(function (s) { return s.index === _this._panels[currentPanelId].index + 1; });
        };
        StepperModel.prototype.resetAllFuturePanels = function (panelId) {
            var _this = this;
            this.panels.filter(function (panel) { return panel.index >= _this._panels[panelId].index; }).forEach(function (panel) { return _this.resetPanel(panel.id); });
        };
        StepperModel.prototype.resetPanel = function (panelId) {
            this._panels[panelId].status = AccordionStatus.Inactive;
            this._panels[panelId].open = false;
            this._panels[panelId].disabled = true;
        };
        StepperModel.prototype.openFirstPanel = function () {
            var firstPanel = this.getFirstPanel();
            /**
             * You need to call updatePanelOrder first to get the correct order,
             * else the list of panels will not have `index` set and we won't know
             * how to find the first panel.
             */
            if (!firstPanel) {
                return;
            }
            this._panels[firstPanel.id].open = true;
            this._panels[firstPanel.id].disabled = true;
            this.stepperModelInitialize = true;
        };
        StepperModel.prototype.completePanel = function (panelId) {
            this._panels[panelId].status = AccordionStatus.Complete;
            this._panels[panelId].disabled = false;
            this._panels[panelId].open = false;
        };
        StepperModel.prototype.openNextPanel = function (currentPanelId) {
            var nextPanel = this.getNextPanel(currentPanelId);
            if (nextPanel) {
                this.resetAllFuturePanels(nextPanel.id);
                this._panels[nextPanel.id].open = true;
                this._panels[nextPanel.id].disabled = true;
            }
        };
        StepperModel.prototype.setPanelError = function (panelId) {
            this.resetAllFuturePanels(panelId);
            this._panels[panelId].open = true;
            this._panels[panelId].status = AccordionStatus.Error;
        };
        StepperModel.prototype.getFirstPanel = function () {
            return this.panels.find(function (panel) { return panel.index === 0; });
        };
        StepperModel.prototype.getNumberOfIncompletePanels = function () {
            return this.panels.reduce(function (prev, next) { return (next.status !== AccordionStatus.Complete ? prev + 1 : prev); }, 0);
        };
        StepperModel.prototype.getNumberOfOpenPanels = function () {
            return this.panels.reduce(function (prev, next) { return (next.open !== false ? prev + 1 : prev); }, 0);
        };
        return StepperModel;
    }(AccordionModel));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var StepperService = /** @class */ (function (_super) {
        __extends(StepperService, _super);
        function StepperService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.panelsCompleted = _this.getAllCompletedPanelChanges();
            _this.accordion = new StepperModel();
            _this._activeStepChanges = new rxjs.Subject();
            _this.activeStep = _this._activeStepChanges.asObservable();
            return _this;
        }
        StepperService.prototype.resetPanels = function () {
            this.accordion.resetPanels();
            this.emitUpdatedPanels();
        };
        StepperService.prototype.setPanelsWithErrors = function (ids) {
            this.accordion.setPanelsWithErrors(ids);
            this.emitUpdatedPanels();
        };
        StepperService.prototype.navigateToNextPanel = function (currentPanelId, currentPanelValid) {
            if (currentPanelValid === void 0) { currentPanelValid = true; }
            this.accordion.navigateToNextPanel(currentPanelId, currentPanelValid);
            this.updateNextStep(currentPanelId, currentPanelValid);
            this.emitUpdatedPanels();
        };
        StepperService.prototype.overrideInitialPanel = function (panelId) {
            this.accordion.overrideInitialPanel(panelId);
            this.emitUpdatedPanels();
        };
        StepperService.prototype.updateNextStep = function (currentPanelId, currentPanelValid) {
            var nextPanel = this.accordion.getNextPanel(currentPanelId);
            if (currentPanelValid && nextPanel) {
                this._activeStepChanges.next(nextPanel.id);
            }
            else if (currentPanelValid) {
                this._activeStepChanges.next(currentPanelId);
            }
        };
        StepperService.prototype.getAllCompletedPanelChanges = function () {
            var _this = this;
            return this._panelsChanges.pipe(operators.map(function () { return _this.accordion.allPanelsCompleted; }), operators.distinctUntilChanged());
        };
StepperService.ɵfac = function StepperService_Factory(t) { return ɵStepperService_BaseFactory(t || StepperService); };
StepperService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: StepperService, factory: function (t) { return StepperService.ɵfac(t); } });
var ɵStepperService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(StepperService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperService, [{
        type: core.Injectable
    }], null, null); })();
        return StepperService;
    }(AccordionService));

    /*
    * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
    * This software is released under MIT license.
    * The full license information can be found in LICENSE in the root directory of this project.
    */
    function triggerAllFormControlValidation(formGroup) {
        Object.keys(formGroup.controls).forEach(function (field) {
            var control = formGroup.get(field);
            if (control instanceof forms.FormControl) {
                control.markAsTouched();
                control.markAsDirty();
                control.updateValueAndValidity();
            }
            else if (control instanceof forms.FormGroup) {
                triggerAllFormControlValidation(control);
            }
        });
    }

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrStepperPanel = /** @class */ (function (_super) {
        __extends(ClrStepperPanel, _super);
        function ClrStepperPanel(platformId, commonStrings, formGroupName, ngModelGroup, stepperService, ifExpandService, id) {
            var _this = _super.call(this, commonStrings, stepperService, ifExpandService, id) || this;
            _this.platformId = platformId;
            _this.commonStrings = commonStrings;
            _this.formGroupName = formGroupName;
            _this.ngModelGroup = ngModelGroup;
            _this.stepperService = stepperService;
            _this.isAccordion = false;
            _this.subscriptions = [];
            return _this;
        }
        Object.defineProperty(ClrStepperPanel.prototype, "formGroup", {
            get: function () {
                return this.formGroupName ? this.formGroupName.control : this.ngModelGroup.control;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStepperPanel.prototype, "id", {
            get: function () {
                return this.formGroupName ? this.formGroupName.name.toString() : this.ngModelGroup.name;
            },
            set: function (_value) { } // overriding parent id required empty setter
            ,
            enumerable: true,
            configurable: true
        });
        ClrStepperPanel.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.panel = this.panel.pipe(operators.tap(function (panel) { return _this.triggerAllFormControlValidationIfError(panel); }));
            this.stepperService.disablePanel(this.id, true);
            this.listenToFocusChanges();
        };
        ClrStepperPanel.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ClrStepperPanel.prototype.listenToFocusChanges = function () {
            var _this = this;
            this.subscriptions.push(this.stepperService.activeStep
                .pipe(operators.filter(function (panelId) { return common.isPlatformBrowser(_this.platformId) && panelId === _this.id; }))
                .subscribe(function () { return _this.headerButton.nativeElement.focus(); }));
        };
        ClrStepperPanel.prototype.triggerAllFormControlValidationIfError = function (panel) {
            if (panel.status === AccordionStatus.Error) {
                triggerAllFormControlValidation(this.formGroup);
            }
        };
        ClrStepperPanel.ctorParameters = function () { return [
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: ClrCommonStringsService },
            { type: forms.FormGroupName, decorators: [{ type: core.Optional }] },
            { type: forms.NgModelGroup, decorators: [{ type: core.Optional }] },
            { type: StepperService },
            { type: IfExpandService },
            { type: String, decorators: [{ type: core.Inject, args: [UNIQUE_ID,] }] }
        ]; };
        __decorate([
            core.ViewChild('headerButton')
        ], ClrStepperPanel.prototype, "headerButton", void 0);
        ClrStepperPanel = __decorate([ __param(0, core.Inject(core.PLATFORM_ID)),
            __param(2, core.Optional()),
            __param(3, core.Optional()),
            __param(6, core.Inject(UNIQUE_ID))
        ], ClrStepperPanel);
ClrStepperPanel.ɵfac = function ClrStepperPanel_Factory(t) { return new (t || ClrStepperPanel)(ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ClrCommonStringsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupName, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgModelGroup, 8), ɵngcc0.ɵɵdirectiveInject(StepperService), ɵngcc0.ɵɵdirectiveInject(IfExpandService), ɵngcc0.ɵɵdirectiveInject(UNIQUE_ID)); };
ClrStepperPanel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStepperPanel, selectors: [["clr-stepper-panel"]], viewQuery: function ClrStepperPanel_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c89, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerButton = _t.first);
    } }, hostVars: 2, hostBindings: function ClrStepperPanel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-accordion-panel", true);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([IfExpandService, UNIQUE_ID_PROVIDER]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c88, decls: 2, vars: 3, consts: [[4, "ngIf"], ["aria-live", "assertive", "class", "clr-sr-only", 4, "ngIf"], ["role", "group", 3, "ngClass"], [1, "clr-accordion-header"], ["type", "button", 1, "clr-accordion-header-button", 3, "id", "disabled", "click"], ["headerButton", ""], [1, "clr-sr-only"], [1, "clr-accordion-status"], ["shape", "angle", "dir", "right", 1, "clr-accordion-angle"], [1, "clr-accordion-number"], ["shape", "exclamation-circle", 1, "clr-accordion-error-icon"], ["shape", "check-circle", 1, "clr-accordion-complete-icon"], ["role", "region", 3, "id"], ["class", "clr-accordion-content", 4, "ngIf"], ["aria-live", "assertive", 1, "clr-sr-only"], [1, "clr-accordion-content"], [1, "clr-accordion-inner-content"]], template: function ClrStepperPanel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c87);
        ɵngcc0.ɵɵtemplate(0, ClrStepperPanel_ng_container_0_Template, 19, 18, "ng-container", 0);
        ɵngcc0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.panel));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ClrIconCustomTag], pipes: [ɵngcc1.AsyncPipe], encapsulation: 2, data: { animation: stepAnimation }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStepperPanel, [{
        type: core.Component,
        args: [{
                selector: 'clr-stepper-panel',
                template: "<ng-container *ngIf=\"panel | async; let panel\">\n  <div *ngIf=\"panel.status !== AccordionStatus.Inactive\" aria-live=\"assertive\" class=\"clr-sr-only\">\n    <ng-container *ngIf=\"panel.status === AccordionStatus.Error\">{{commonStrings.keys.danger}}</ng-container>\n  </div>\n\n  <div role=\"group\" [ngClass]=\"getPanelStateClasses(panel)\">\n    <div class=\"clr-accordion-header\">\n      <button\n        type=\"button\"\n        class=\"clr-accordion-header-button\"\n        (click)=\"togglePanel()\"\n        [id]=\"getAccordionHeaderId(panel.templateId)\"\n        [disabled]=\"isAccordion && panel.disabled\"\n        [attr.aria-disabled]=\"!isAccordion && panel.disabled\"\n        [attr.aria-controls]=\"getAccordionContentId(panel.templateId)\"\n        [attr.aria-expanded]=\"panel.open\"\n        [class.clr-accordion-header-has-description]=\"(accordionDescription.changes | async)?.length || accordionDescription.length\"\n        #headerButton\n      >\n        <span class=\"clr-sr-only\">\n          <ng-container *ngIf=\"panel.status === AccordionStatus.Error\">{{commonStrings.keys.danger}}</ng-container>\n          <ng-container *ngIf=\"panel.status === AccordionStatus.Complete\">{{commonStrings.keys.success}}</ng-container>\n        </span>\n        <span class=\"clr-accordion-status\">\n          <clr-icon shape=\"angle\" dir=\"right\" class=\"clr-accordion-angle\"></clr-icon>\n          <span class=\"clr-accordion-number\"></span>\n          <clr-icon shape=\"exclamation-circle\" class=\"clr-accordion-error-icon\"></clr-icon>\n          <clr-icon shape=\"check-circle\" class=\"clr-accordion-complete-icon\"></clr-icon>\n        </span>\n        <ng-content select=\"clr-accordion-title, clr-step-title\"></ng-content>\n        <ng-content select=\"clr-accordion-description, clr-step-description\"></ng-content>\n      </button>\n    </div>\n    <div\n      @skipInitialRender\n      role=\"region\"\n      [id]=\"getAccordionContentId(panel.templateId)\"\n      [attr.aria-hidden]=\"!panel.open\"\n      [attr.aria-labelledby]=\"getAccordionHeaderId(panel.templateId)\"\n    >\n      <div\n        *ngIf=\"panel.open\"\n        @toggle\n        (@toggle.done)=\"collapsePanelOnAnimationDone(panel)\"\n        class=\"clr-accordion-content\">\n        <div class=\"clr-accordion-inner-content\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n",
                host: { '[class.clr-accordion-panel]': 'true' },
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: stepAnimation,
                providers: [IfExpandService, UNIQUE_ID_PROVIDER]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }, { type: ClrCommonStringsService }, { type: ɵngcc2.FormGroupName, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc2.NgModelGroup, decorators: [{
                type: core.Optional
            }] }, { type: StepperService }, { type: IfExpandService }, { type: String, decorators: [{
                type: core.Inject,
                args: [UNIQUE_ID]
            }] }]; }, { headerButton: [{
            type: core.ViewChild,
            args: ['headerButton']
        }] }); })();
        return ClrStepperPanel;
    }(ClrAccordionPanel));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    (function (ClrStepButtonType) {
        ClrStepButtonType["Next"] = "next";
        ClrStepButtonType["Submit"] = "submit";
    })(exports.ClrStepButtonType || (exports.ClrStepButtonType = {}));
    var ClrStepButton = /** @class */ (function () {
        function ClrStepButton(clrStep, stepperService) {
            this.clrStep = clrStep;
            this.stepperService = stepperService;
            this.type = exports.ClrStepButtonType.Next;
            this.submitButton = false;
        }
        ClrStepButton.prototype.ngOnInit = function () {
            this.submitButton = this.type === exports.ClrStepButtonType.Submit;
        };
        ClrStepButton.prototype.navigateToNextPanel = function () {
            this.stepperService.navigateToNextPanel(this.clrStep.id, this.clrStep.formGroup.valid);
        };
        ClrStepButton.ctorParameters = function () { return [
            { type: ClrStepperPanel },
            { type: StepperService }
        ]; };
        __decorate([
            core.Input('clrStepButton')
        ], ClrStepButton.prototype, "type", void 0);
        __decorate([
            core.HostBinding('class.btn-primary')
        ], ClrStepButton.prototype, "submitButton", void 0);
        __decorate([
            core.HostListener('click')
        ], ClrStepButton.prototype, "navigateToNextPanel", null);
ClrStepButton.ɵfac = function ClrStepButton_Factory(t) { return new (t || ClrStepButton)(ɵngcc0.ɵɵdirectiveInject(ClrStepperPanel), ɵngcc0.ɵɵdirectiveInject(StepperService)); };
ClrStepButton.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrStepButton, selectors: [["", "clrStepButton", ""]], hostVars: 7, hostBindings: function ClrStepButton_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClrStepButton_click_HostBindingHandler() { return ctx.navigateToNextPanel(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("type", "button");
        ɵngcc0.ɵɵclassProp("clr-step-button", true)("btn", true)("btn-primary", ctx.submitButton);
    } }, inputs: { type: ["clrStepButton", "type"] } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStepButton, [{
        type: core.Directive,
        args: [{
                selector: '[clrStepButton]',
                host: {
                    '[class.clr-step-button]': 'true',
                    '[class.btn]': 'true',
                    '[type]': "'button'"
                }
            }]
    }], function () { return [{ type: ClrStepperPanel }, { type: StepperService }]; }, { type: [{
            type: core.Input,
            args: ['clrStepButton']
        }], submitButton: [{
            type: core.HostBinding,
            args: ['class.btn-primary']
        }], navigateToNextPanel: [{
            type: core.HostListener,
            args: ['click']
        }] }); })();
        return ClrStepButton;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrStepper = /** @class */ (function () {
        function ClrStepper(formGroup, ngForm, stepperService) {
            this.formGroup = formGroup;
            this.ngForm = ngForm;
            this.stepperService = stepperService;
            this.subscriptions = [];
        }
        ClrStepper.prototype.ngOnInit = function () {
            if (!this.formGroup && !this.ngForm) {
                throw new Error('To use stepper a Reactive or Template Form is required.');
            }
            this.form = this.formGroup ? this.formGroup : this.ngForm;
            this.subscriptions.push(this.listenForPanelsCompleted());
            this.subscriptions.push(this.listenForFormResetChanges());
        };
        ClrStepper.prototype.ngOnChanges = function (changes) {
            if (changes.initialPanel.currentValue !== changes.initialPanel.previousValue) {
                this.stepperService.overrideInitialPanel(this.initialPanel);
            }
        };
        ClrStepper.prototype.ngAfterViewInit = function () {
            this.subscriptions.push(this.listenForDOMChanges());
        };
        ClrStepper.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ClrStepper.prototype.listenForFormResetChanges = function () {
            var _this = this;
            return this.form.statusChanges
                .pipe(operators.filter(function () { return _this.form.pristine; })) // https://github.com/angular/angular/issues/10887
                .subscribe(function () { return _this.stepperService.resetPanels(); });
        };
        ClrStepper.prototype.listenForPanelsCompleted = function () {
            var _this = this;
            return this.stepperService.panelsCompleted.subscribe(function (panelsCompleted) {
                if (panelsCompleted && _this.form.valid) {
                    _this.form.ngSubmit.emit();
                }
                else if (!_this.form.valid && _this.form.touched) {
                    _this.setPanelsWithFormErrors();
                }
            });
        };
        ClrStepper.prototype.setPanelsWithFormErrors = function () {
            var panelsWithErrors = this.panels.reduce(function (panels, p) { return (p.formGroup.invalid ? __spread(panels, [p.id]) : panels); }, []);
            this.stepperService.setPanelsWithErrors(panelsWithErrors);
        };
        ClrStepper.prototype.listenForDOMChanges = function () {
            var _this = this;
            return this.panels.changes.pipe(operators.startWith(this.panels)).subscribe(function (panels) {
                _this.stepperService.updatePanelOrder(panels.toArray().map(function (p) { return p.id; }));
                if (_this.initialPanel) {
                    _this.stepperService.overrideInitialPanel(_this.initialPanel);
                }
            });
        };
        ClrStepper.ctorParameters = function () { return [
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: StepperService }
        ]; };
        __decorate([
            core.Input('clrInitialStep')
        ], ClrStepper.prototype, "initialPanel", void 0);
        __decorate([
            core.ContentChildren(ClrStepperPanel, { descendants: true })
        ], ClrStepper.prototype, "panels", void 0);
        ClrStepper = __decorate([ __param(0, core.Optional()),
            __param(1, core.Optional())
        ], ClrStepper);
ClrStepper.ɵfac = function ClrStepper_Factory(t) { return new (t || ClrStepper)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(StepperService)); };
ClrStepper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStepper, selectors: [["form", "clrStepper", ""]], contentQueries: function ClrStepper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrStepperPanel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panels = _t);
    } }, hostVars: 4, hostBindings: function ClrStepper_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-accordion", true)("clr-stepper-forms", true);
    } }, inputs: { initialPanel: ["clrInitialStep", "initialPanel"] }, features: [ɵngcc0.ɵɵProvidersFeature([StepperService, { provide: AccordionService, useExisting: StepperService }]), ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c90, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrStepper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStepper, [{
        type: core.Component,
        args: [{
                selector: 'form[clrStepper]',
                template: "<ng-content></ng-content>",
                host: {
                    '[class.clr-accordion]': 'true',
                    '[class.clr-stepper-forms]': 'true'
                },
                providers: [StepperService, { provide: AccordionService, useExisting: StepperService }],
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc2.FormGroupDirective, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc2.NgForm, decorators: [{
                type: core.Optional
            }] }, { type: StepperService }]; }, { initialPanel: [{
            type: core.Input,
            args: ['clrInitialStep']
        }], panels: [{
            type: core.ContentChildren,
            args: [ClrStepperPanel, { descendants: true }]
        }] }); })();
        return ClrStepper;
    }());

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var StepperWillyWonka = /** @class */ (function (_super) {
        __extends(StepperWillyWonka, _super);
        function StepperWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
StepperWillyWonka.ɵfac = function StepperWillyWonka_Factory(t) { return ɵStepperWillyWonka_BaseFactory(t || StepperWillyWonka); };
StepperWillyWonka.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StepperWillyWonka, selectors: [["form", "clrStepper", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
var ɵStepperWillyWonka_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(StepperWillyWonka);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperWillyWonka, [{
        type: core.Directive,
        args: [{ selector: 'form[clrStepper]' }]
    }], null, null); })();
        return StepperWillyWonka;
    }(WillyWonka));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var StepperOompaLoompa = /** @class */ (function (_super) {
        __extends(StepperOompaLoompa, _super);
        function StepperOompaLoompa(cdr, willyWonka, ifExpandService) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-stepper-panel should only be used inside of clrStepper');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.expand = ifExpandService;
            return _this;
        }
        Object.defineProperty(StepperOompaLoompa.prototype, "flavor", {
            get: function () {
                return this.expand.expanded;
            },
            enumerable: true,
            configurable: true
        });
        StepperOompaLoompa.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: StepperWillyWonka, decorators: [{ type: core.Optional }] },
            { type: IfExpandService }
        ]; };
        StepperOompaLoompa = __decorate([ __param(1, core.Optional())
        ], StepperOompaLoompa);
StepperOompaLoompa.ɵfac = function StepperOompaLoompa_Factory(t) { return new (t || StepperOompaLoompa)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(StepperWillyWonka, 8), ɵngcc0.ɵɵdirectiveInject(IfExpandService)); };
StepperOompaLoompa.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StepperOompaLoompa, selectors: [["clr-stepper-panel"], ["", "clrStepButton", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperOompaLoompa, [{
        type: core.Directive,
        args: [{ selector: 'clr-stepper-panel, [clrStepButton]' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: StepperWillyWonka, decorators: [{
                type: core.Optional
            }] }, { type: IfExpandService }]; }, null); })();
        return StepperOompaLoompa;
    }(OompaLoompa));

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var declarations$1 = [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka];
    var ClrStepperModule = /** @class */ (function () {
        function ClrStepperModule() {
        }
ClrStepperModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrStepperModule });
ClrStepperModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrStepperModule_Factory(t) { return new (t || ClrStepperModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrAccordionModule],
        ClrAccordionModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrStepperModule, { declarations: [ClrStepper,
        ClrStepButton,
        ClrStepperPanel,
        StepperOompaLoompa,
        StepperWillyWonka], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrAccordionModule], exports: [ClrStepper,
        ClrStepButton,
        ClrStepperPanel,
        StepperOompaLoompa,
        StepperWillyWonka,
        ClrAccordionModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrStepperModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrAccordionModule],
                declarations: __spread(declarations$1),
                exports: __spread(declarations$1, [ClrAccordionModule])
            }]
    }], function () { return []; }, null); })();
        return ClrStepperModule;
    }());

    var ClrProgressBar = /** @class */ (function () {
        function ClrProgressBar(ariaLiveService) {
            this.ariaLiveService = ariaLiveService;
            this.externalId = '';
            // Progress
            this.max = 100;
            this._value = 0;
        }
        Object.defineProperty(ClrProgressBar.prototype, "id", {
            get: function () {
                return this._ID;
            },
            set: function (value) {
                this._ID = value;
                this.externalId = null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
                if (this.displayAriaLive()) {
                    this.ariaLiveService.announce(this.displayValue, this.ariaLive);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "progressClass", {
            // Styles
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "labeledClass", {
            get: function () {
                return this._labeled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrLabeled", {
            set: function (value) {
                this._labeled = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "fadeClass", {
            get: function () {
                return this._fade;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrFade", {
            set: function (value) {
                this._fade = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "loopClass", {
            get: function () {
                return this._loop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrLoop", {
            set: function (value) {
                this._loop = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "successClass", {
            get: function () {
                return this._success;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrSuccess", {
            /** @deprecated since 2.0, remove in 4.0 */
            set: function (value) {
                this._success = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "dangerClass", {
            get: function () {
                return this._danger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrDanger", {
            /** @deprecated since 2.0, remove in 4.0 */
            set: function (value) {
                this._danger = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "flashClass", {
            get: function () {
                return this._flash;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrFlash", {
            set: function (value) {
                this._flash = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "flashDangerClass", {
            get: function () {
                return this._flashDanger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "clrFlashDanger", {
            /** @deprecated since 2.0, remove in 4.0 */
            set: function (value) {
                this._flashDanger = isBooleanAttributeSet(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrProgressBar.prototype, "displayValue", {
            /**
             * Make sure that we always will have something that is readable
             * for the screen reader
             */
            get: function () {
                if (this.displayval) {
                    return this.displayval;
                }
                return this.value + "%";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Display aria-live only when there is value and it's not 0 or equal to the max value
         */
        ClrProgressBar.prototype.displayAriaLive = function () {
            return (this.value !== undefined || this.value !== 0) && this.value !== this.max;
        };
        Object.defineProperty(ClrProgressBar.prototype, "ariaLive", {
            get: function () {
                if (isBooleanAttributeSet(this.assertive)) {
                    return exports.ClrAriaLivePoliteness.assertive;
                }
                if (isBooleanAttributeSet(this.off)) {
                    return exports.ClrAriaLivePoliteness.off;
                }
                return exports.ClrAriaLivePoliteness.polite;
            },
            enumerable: true,
            configurable: true
        });
        ClrProgressBar.ctorParameters = function () { return [
            { type: ClrAriaLiveService }
        ]; };
        __decorate([
            core.HostBinding('attr.id')
        ], ClrProgressBar.prototype, "externalId", void 0);
        __decorate([
            core.Input()
        ], ClrProgressBar.prototype, "id", null);
        __decorate([
            core.Input('clrMax')
        ], ClrProgressBar.prototype, "max", void 0);
        __decorate([
            core.Input('clrDisplayval')
        ], ClrProgressBar.prototype, "displayval", void 0);
        __decorate([
            core.Input('clrValue')
        ], ClrProgressBar.prototype, "value", null);
        __decorate([
            core.HostBinding('class.progress')
        ], ClrProgressBar.prototype, "progressClass", null);
        __decorate([
            core.HostBinding('class.labeled')
        ], ClrProgressBar.prototype, "labeledClass", null);
        __decorate([
            core.Input('clrLabeled')
        ], ClrProgressBar.prototype, "clrLabeled", null);
        __decorate([
            core.HostBinding('class.progress-fade')
        ], ClrProgressBar.prototype, "fadeClass", null);
        __decorate([
            core.Input('clrFade')
        ], ClrProgressBar.prototype, "clrFade", null);
        __decorate([
            core.HostBinding('class.loop')
        ], ClrProgressBar.prototype, "loopClass", null);
        __decorate([
            core.Input('clrLoop')
        ], ClrProgressBar.prototype, "clrLoop", null);
        __decorate([
            core.HostBinding('class.success')
        ], ClrProgressBar.prototype, "successClass", null);
        __decorate([
            core.Input('clrSuccess')
        ], ClrProgressBar.prototype, "clrSuccess", null);
        __decorate([
            core.HostBinding('class.danger')
        ], ClrProgressBar.prototype, "dangerClass", null);
        __decorate([
            core.Input('clrDanger')
        ], ClrProgressBar.prototype, "clrDanger", null);
        __decorate([
            core.HostBinding('class.flash')
        ], ClrProgressBar.prototype, "flashClass", null);
        __decorate([
            core.Input('clrFlash')
        ], ClrProgressBar.prototype, "clrFlash", null);
        __decorate([
            core.HostBinding('class.flash-danger')
        ], ClrProgressBar.prototype, "flashDangerClass", null);
        __decorate([
            core.Input('clrFlashDanger')
        ], ClrProgressBar.prototype, "clrFlashDanger", null);
        __decorate([
            core.Input('clrAssertive')
        ], ClrProgressBar.prototype, "assertive", void 0);
        __decorate([
            core.Input('clrOff')
        ], ClrProgressBar.prototype, "off", void 0);
ClrProgressBar.ɵfac = function ClrProgressBar_Factory(t) { return new (t || ClrProgressBar)(ɵngcc0.ɵɵdirectiveInject(ClrAriaLiveService)); };
ClrProgressBar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrProgressBar, selectors: [["clr-progress-bar"]], hostVars: 17, hostBindings: function ClrProgressBar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.externalId);
        ɵngcc0.ɵɵclassProp("progress", ctx.progressClass)("labeled", ctx.labeledClass)("progress-fade", ctx.fadeClass)("loop", ctx.loopClass)("success", ctx.successClass)("danger", ctx.dangerClass)("flash", ctx.flashClass)("flash-danger", ctx.flashDangerClass);
    } }, inputs: { max: ["clrMax", "max"], id: "id", value: ["clrValue", "value"], clrLabeled: "clrLabeled", clrFade: "clrFade", clrLoop: "clrLoop", clrSuccess: "clrSuccess", clrDanger: "clrDanger", clrFlash: "clrFlash", clrFlashDanger: "clrFlashDanger", displayval: ["clrDisplayval", "displayval"], assertive: ["clrAssertive", "assertive"], off: ["clrOff", "off"] }, features: [ɵngcc0.ɵɵProvidersFeature([ClrAriaLiveService])], decls: 2, vars: 5, consts: [[3, "id"], [4, "ngIf"]], template: function ClrProgressBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "progress", 0);
        ɵngcc0.ɵɵtemplate(1, ClrProgressBar_span_1_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.id);
        ɵngcc0.ɵɵattribute("max", ctx.max)("value", ctx.value)("data-displayval", ctx.displayValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.displayAriaLive());
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrProgressBar, [{
        type: core.Component,
        args: [{
                providers: [ClrAriaLiveService],
                selector: 'clr-progress-bar',
                template: "\n    <progress [id]=\"id\" [attr.max]=\"max\" [attr.value]=\"value\" [attr.data-displayval]=\"displayValue\"></progress>\n    <span *ngIf=\"displayAriaLive()\">{{ displayValue }}</span>\n  "
            }]
    }], function () { return [{ type: ClrAriaLiveService }]; }, { externalId: [{
            type: core.HostBinding,
            args: ['attr.id']
        }], max: [{
            type: core.Input,
            args: ['clrMax']
        }], id: [{
            type: core.Input
        }], value: [{
            type: core.Input,
            args: ['clrValue']
        }], progressClass: [{
            type: core.HostBinding,
            args: ['class.progress']
        }], labeledClass: [{
            type: core.HostBinding,
            args: ['class.labeled']
        }], clrLabeled: [{
            type: core.Input,
            args: ['clrLabeled']
        }], fadeClass: [{
            type: core.HostBinding,
            args: ['class.progress-fade']
        }], clrFade: [{
            type: core.Input,
            args: ['clrFade']
        }], loopClass: [{
            type: core.HostBinding,
            args: ['class.loop']
        }], clrLoop: [{
            type: core.Input,
            args: ['clrLoop']
        }], successClass: [{
            type: core.HostBinding,
            args: ['class.success']
        }], clrSuccess: [{
            type: core.Input,
            args: ['clrSuccess']
        }], dangerClass: [{
            type: core.HostBinding,
            args: ['class.danger']
        }], clrDanger: [{
            type: core.Input,
            args: ['clrDanger']
        }], flashClass: [{
            type: core.HostBinding,
            args: ['class.flash']
        }], clrFlash: [{
            type: core.Input,
            args: ['clrFlash']
        }], flashDangerClass: [{
            type: core.HostBinding,
            args: ['class.flash-danger']
        }], clrFlashDanger: [{
            type: core.Input,
            args: ['clrFlashDanger']
        }], displayval: [{
            type: core.Input,
            args: ['clrDisplayval']
        }], assertive: [{
            type: core.Input,
            args: ['clrAssertive']
        }], off: [{
            type: core.Input,
            args: ['clrOff']
        }] }); })();
        return ClrProgressBar;
    }());

    var CLR_PROGRESS_BAR_DIRECTIVES = [ClrProgressBar];
    var ClrProgressBarModule = /** @class */ (function () {
        function ClrProgressBarModule() {
        }
ClrProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrProgressBarModule });
ClrProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrProgressBarModule_Factory(t) { return new (t || ClrProgressBarModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrProgressBarModule, { declarations: [ClrProgressBar], imports: [ɵngcc1.CommonModule], exports: [ClrProgressBar] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrProgressBarModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [CLR_PROGRESS_BAR_DIRECTIVES],
                exports: [CLR_PROGRESS_BAR_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrProgressBarModule;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    (function (ClrTimelineLayout) {
        ClrTimelineLayout["HORIZONTAL"] = "horizontal";
        ClrTimelineLayout["VERTICAL"] = "vertical";
    })(exports.ClrTimelineLayout || (exports.ClrTimelineLayout = {}));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    (function (ClrTimelineStepState) {
        ClrTimelineStepState["NOT_STARTED"] = "not-started";
        ClrTimelineStepState["CURRENT"] = "current";
        ClrTimelineStepState["PROCESSING"] = "processing";
        ClrTimelineStepState["SUCCESS"] = "success";
        ClrTimelineStepState["ERROR"] = "error";
    })(exports.ClrTimelineStepState || (exports.ClrTimelineStepState = {}));

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var TimelineIconAttributeService = /** @class */ (function () {
        function TimelineIconAttributeService(commonStrings) {
            this.attributeMap = new Map();
            this.attributeMap.set(exports.ClrTimelineStepState.NOT_STARTED, {
                iconShape: 'circle',
                ariaLabel: commonStrings.keys.timelineStepNotStarted,
            });
            this.attributeMap.set(exports.ClrTimelineStepState.CURRENT, {
                iconShape: 'dot-circle',
                ariaLabel: commonStrings.keys.timelineStepCurrent,
            });
            this.attributeMap.set(exports.ClrTimelineStepState.PROCESSING, {
                iconShape: undefined,
                ariaLabel: commonStrings.keys.timelineStepProcessing,
            });
            this.attributeMap.set(exports.ClrTimelineStepState.SUCCESS, {
                iconShape: 'success-standard',
                ariaLabel: commonStrings.keys.timelineStepSuccess,
            });
            this.attributeMap.set(exports.ClrTimelineStepState.ERROR, {
                iconShape: 'error-standard',
                ariaLabel: commonStrings.keys.timelineStepError,
            });
        }
        TimelineIconAttributeService.prototype.getAriaLabel = function (step) {
            return this.attributeMap.get(step).ariaLabel;
        };
        TimelineIconAttributeService.prototype.getIconShape = function (step) {
            return this.attributeMap.get(step).iconShape;
        };
        TimelineIconAttributeService.ctorParameters = function () { return [
            { type: ClrCommonStringsService }
        ]; };
TimelineIconAttributeService.ɵfac = function TimelineIconAttributeService_Factory(t) { return new (t || TimelineIconAttributeService)(ɵngcc0.ɵɵinject(ClrCommonStringsService)); };
TimelineIconAttributeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TimelineIconAttributeService, factory: function (t) { return TimelineIconAttributeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimelineIconAttributeService, [{
        type: core.Injectable
    }], function () { return [{ type: ClrCommonStringsService }]; }, null); })();
        return TimelineIconAttributeService;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTimeline = /** @class */ (function () {
        function ClrTimeline() {
            this.layout = exports.ClrTimelineLayout.HORIZONTAL;
        }
        Object.defineProperty(ClrTimeline.prototype, "isVertical", {
            get: function () {
                return this.layout === exports.ClrTimelineLayout.VERTICAL;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('clrLayout')
        ], ClrTimeline.prototype, "layout", void 0);
        __decorate([
            core.HostBinding('class.clr-timeline-vertical')
        ], ClrTimeline.prototype, "isVertical", null);
ClrTimeline.ɵfac = function ClrTimeline_Factory(t) { return new (t || ClrTimeline)(); };
ClrTimeline.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTimeline, selectors: [["clr-timeline"]], hostVars: 4, hostBindings: function ClrTimeline_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-timeline", true)("clr-timeline-vertical", ctx.isVertical);
    } }, inputs: { layout: ["clrLayout", "layout"] }, features: [ɵngcc0.ɵɵProvidersFeature([TimelineIconAttributeService])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTimeline_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTimeline, [{
        type: core.Component,
        args: [{
                selector: 'clr-timeline',
                template: "\n    <ng-content></ng-content>\n  ",
                host: { '[class.clr-timeline]': 'true' },
                providers: [TimelineIconAttributeService]
            }]
    }], function () { return []; }, { layout: [{
            type: core.Input,
            args: ['clrLayout']
        }], isVertical: [{
            type: core.HostBinding,
            args: ['class.clr-timeline-vertical']
        }] }); })();
        return ClrTimeline;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Note: Why does this component have aria-hidden attribute?
     *
     * tl;dr: we want screen readers to ignore this element when its reading out to blind users.
     *
     * In order to make a timeline step accessible to screen readers we need the title read out before the
     * icon. In order to do this, ClrTimeLine step has a ContentChild that queries for the ClrTimelineStepTitle and
     * then adds the projected text into a .clr-sr-only element that is a sibling element to the icon. See the
     * ClrTimlineStep template for the DOM structure.
     */
    var ClrTimelineStepTitle = /** @class */ (function () {
        function ClrTimelineStepTitle() {
        }
ClrTimelineStepTitle.ɵfac = function ClrTimelineStepTitle_Factory(t) { return new (t || ClrTimelineStepTitle)(); };
ClrTimelineStepTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTimelineStepTitle, selectors: [["clr-timeline-step-title"]], hostVars: 3, hostBindings: function ClrTimelineStepTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵclassProp("clr-timeline-step-title", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTimelineStepTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTimelineStepTitle, [{
        type: core.Component,
        args: [{
                selector: 'clr-timeline-step-title',
                template: "\n        <ng-content></ng-content>\n    ",
                host: { '[class.clr-timeline-step-title]': 'true', '[attr.aria-hidden]': 'true' }
            }]
    }], function () { return []; }, null); })();
        return ClrTimelineStepTitle;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTimelineStep = /** @class */ (function () {
        function ClrTimelineStep(iconAttributeService, platformId) {
            this.iconAttributeService = iconAttributeService;
            this.platformId = platformId;
            this.state = exports.ClrTimelineStepState.NOT_STARTED;
        }
        ClrTimelineStep.prototype.ngAfterContentInit = function () {
            if (this.stepTitle && common.isPlatformBrowser(this.platformId)) {
                this.stepTitleText = this.stepTitle.nativeElement.innerText;
            }
        };
        Object.defineProperty(ClrTimelineStep.prototype, "iconAriaCurrent", {
            get: function () {
                return this.state === exports.ClrTimelineStepState.CURRENT;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTimelineStep.prototype, "iconAriaLabel", {
            get: function () {
                return this.iconAttributeService.getAriaLabel(this.state);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTimelineStep.prototype, "iconShape", {
            get: function () {
                return this.iconAttributeService.getIconShape(this.state);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTimelineStep.prototype, "isProcessing", {
            get: function () {
                return this.state === exports.ClrTimelineStepState.PROCESSING;
            },
            enumerable: true,
            configurable: true
        });
        ClrTimelineStep.ctorParameters = function () { return [
            { type: TimelineIconAttributeService },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        __decorate([
            core.Input('clrState')
        ], ClrTimelineStep.prototype, "state", void 0);
        __decorate([
            core.ContentChild(ClrTimelineStepTitle, { read: core.ElementRef })
        ], ClrTimelineStep.prototype, "stepTitle", void 0);
        ClrTimelineStep = __decorate([ __param(1, core.Inject(core.PLATFORM_ID))
        ], ClrTimelineStep);
ClrTimelineStep.ɵfac = function ClrTimelineStep_Factory(t) { return new (t || ClrTimelineStep)(ɵngcc0.ɵɵdirectiveInject(TimelineIconAttributeService), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
ClrTimelineStep.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTimelineStep, selectors: [["clr-timeline-step"]], contentQueries: function ClrTimelineStep_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTimelineStepTitle, true, core.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepTitle = _t.first);
    } }, hostVars: 2, hostBindings: function ClrTimelineStep_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-timeline-step", true);
    } }, inputs: { state: ["clrState", "state"] }, ngContentSelectors: _c92, decls: 9, vars: 3, consts: [[1, "clr-sr-only"], [4, "ngIf", "ngIfElse"], [1, "clr-timeline-step-body"], ["processing", ""], ["clrMedium", ""]], template: function ClrTimelineStep_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c91);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "span", 0);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ClrTimelineStep_ng_container_3_Template, 2, 3, "ng-container", 1);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵprojection(6, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ClrTimelineStep_ng_template_7_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        var _r1 = ɵngcc0.ɵɵreference(8);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.stepTitleText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isProcessing)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ClrIconCustomTag,
        ClrSpinner], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTimelineStep, [{
        type: core.Component,
        args: [{
                selector: 'clr-timeline-step',
                template: "\n        <ng-content select=\"clr-timeline-step-header\"></ng-content>\n        <span class=\"clr-sr-only\">{{stepTitleText}}</span>\n        <ng-container *ngIf=\"!isProcessing; else processing\">\n            <clr-icon\n                    [attr.shape]=\"iconShape\"\n                    [attr.aria-label]=\"iconAriaLabel\"\n                    [attr.aria-current]=\"iconAriaCurrent\">\n            </clr-icon>\n        </ng-container>\n        <div class=\"clr-timeline-step-body\">\n            <ng-content select=\"clr-timeline-step-title\"></ng-content>\n            <ng-content select=\"clr-timeline-step-description\"></ng-content>\n        </div>\n\n        <ng-template #processing>\n            <clr-spinner clrMedium [attr.aria-label]=\"iconAriaLabel\"></clr-spinner>\n        </ng-template>\n    ",
                host: { '[class.clr-timeline-step]': 'true' }
            }]
    }], function () { return [{ type: TimelineIconAttributeService }, { type: Object, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { state: [{
            type: core.Input,
            args: ['clrState']
        }], stepTitle: [{
            type: core.ContentChild,
            args: [ClrTimelineStepTitle, { read: core.ElementRef }]
        }] }); })();
        return ClrTimelineStep;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTimelineStepDescription = /** @class */ (function () {
        function ClrTimelineStepDescription() {
        }
ClrTimelineStepDescription.ɵfac = function ClrTimelineStepDescription_Factory(t) { return new (t || ClrTimelineStepDescription)(); };
ClrTimelineStepDescription.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTimelineStepDescription, selectors: [["clr-timeline-step-description"]], hostVars: 2, hostBindings: function ClrTimelineStepDescription_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-timeline-step-description", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTimelineStepDescription_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTimelineStepDescription, [{
        type: core.Component,
        args: [{
                selector: 'clr-timeline-step-description',
                template: "\n    <ng-content></ng-content>\n  ",
                host: { '[class.clr-timeline-step-description]': 'true' }
            }]
    }], function () { return []; }, null); })();
        return ClrTimelineStepDescription;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ClrTimelineStepHeader = /** @class */ (function () {
        function ClrTimelineStepHeader() {
        }
ClrTimelineStepHeader.ɵfac = function ClrTimelineStepHeader_Factory(t) { return new (t || ClrTimelineStepHeader)(); };
ClrTimelineStepHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTimelineStepHeader, selectors: [["clr-timeline-step-header"]], hostVars: 2, hostBindings: function ClrTimelineStepHeader_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-timeline-step-header", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function ClrTimelineStepHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTimelineStepHeader, [{
        type: core.Component,
        args: [{
                selector: 'clr-timeline-step-header',
                template: "\n    <ng-content></ng-content>\n  ",
                host: { '[class.clr-timeline-step-header]': 'true' }
            }]
    }], function () { return []; }, null); })();
        return ClrTimelineStepHeader;
    }());

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_TIMELINE_DIRECTIVES = [
        ClrTimeline,
        ClrTimelineStep,
        ClrTimelineStepDescription,
        ClrTimelineStepHeader,
        ClrTimelineStepTitle,
    ];
    var ClrTimelineModule = /** @class */ (function () {
        function ClrTimelineModule() {
        }
ClrTimelineModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClrTimelineModule });
ClrTimelineModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClrTimelineModule_Factory(t) { return new (t || ClrTimelineModule)(); }, imports: [[common.CommonModule, ClrIconModule, ClrSpinnerModule],
        ClrIconModule,
        ClrSpinnerModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClrTimelineModule, { declarations: [ClrTimeline,
        ClrTimelineStep,
        ClrTimelineStepDescription,
        ClrTimelineStepHeader,
        ClrTimelineStepTitle], imports: [ɵngcc1.CommonModule, ClrIconModule,
        ClrSpinnerModule], exports: [ClrTimeline,
        ClrTimelineStep,
        ClrTimelineStepDescription,
        ClrTimelineStepHeader,
        ClrTimelineStepTitle,
        ClrIconModule,
        ClrSpinnerModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTimelineModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, ClrIconModule, ClrSpinnerModule],
                exports: __spread(CLR_TIMELINE_DIRECTIVES, [ClrIconModule, ClrSpinnerModule]),
                declarations: [CLR_TIMELINE_DIRECTIVES]
            }]
    }], function () { return []; }, null); })();
        return ClrTimelineModule;
    }());

    var ClarityModule = /** @class */ (function () {
        function ClarityModule() {
        }
ClarityModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClarityModule });
ClarityModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClarityModule_Factory(t) { return new (t || ClarityModule)(); }, imports: [ClrEmphasisModule,
        ClrDataModule,
        ClrIconModule,
        ClrModalModule,
        ClrLoadingModule,
        ClrConditionalModule,
        ClrFocusTrapModule,
        ClrFocusOnViewInitModule,
        ClrButtonModule,
        ClrFormsModule,
        ClrLayoutModule,
        ClrPopoverModule,
        ClrWizardModule,
        ClrDragAndDropModule,
        ClrStepperModule,
        ClrSpinnerModule,
        ClrProgressBarModule,
        ClrPopoverModuleNext,
        ClrTimelineModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClarityModule, { exports: [ClrEmphasisModule,
        ClrDataModule,
        ClrIconModule,
        ClrModalModule,
        ClrLoadingModule,
        ClrConditionalModule,
        ClrFocusTrapModule,
        ClrFocusOnViewInitModule,
        ClrButtonModule,
        ClrFormsModule,
        ClrLayoutModule,
        ClrPopoverModule,
        ClrWizardModule,
        ClrDragAndDropModule,
        ClrStepperModule,
        ClrSpinnerModule,
        ClrProgressBarModule,
        ClrPopoverModuleNext,
        ClrTimelineModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClarityModule, [{
        type: core.NgModule,
        args: [{
                exports: [
                    ClrEmphasisModule,
                    ClrDataModule,
                    ClrIconModule,
                    ClrModalModule,
                    ClrLoadingModule,
                    ClrConditionalModule,
                    ClrFocusTrapModule,
                    ClrFocusOnViewInitModule,
                    ClrButtonModule,
                    ClrFormsModule,
                    ClrLayoutModule,
                    ClrPopoverModule,
                    ClrWizardModule,
                    ClrDragAndDropModule,
                    ClrStepperModule,
                    ClrSpinnerModule,
                    ClrProgressBarModule,
                    ClrPopoverModuleNext,
                    ClrTimelineModule,
                ]
            }]
    }], function () { return []; }, null); })();
        return ClarityModule;
    }());

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var CLR_MENU_POSITIONS = [
        'bottom-left',
        'bottom-right',
        'top-left',
        'top-right',
        'left-bottom',
        'left-top',
        'right-bottom',
        'right-top',
    ];

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function collapse() {
        'use strict';
        return [
            animations.state('true', animations.style({ height: 0, 'overflow-y': 'hidden' })),
            animations.transition('true => false', [animations.animate(defaultAnimationTiming, animations.style({ height: '*', 'overflow-y': 'hidden' }))]),
            animations.transition('false => true', [animations.style({ height: '*', 'overflow-y': 'hidden' }), animations.animate(defaultAnimationTiming)]),
        ];
    }

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function fade(opacity) {
        if (opacity === void 0) { opacity = 1; }
        return [
            animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate(defaultAnimationTiming, animations.style({ opacity: opacity }))]),
            animations.transition('* => void', [animations.animate(defaultAnimationTiming, animations.style({ opacity: 0 }))]),
        ];
    }

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function fadeSlide(direction) {
        var transform = null;
        if (direction === 'up') {
            transform = 'translate(0, 25%)';
        }
        else if (direction === 'down') {
            transform = 'translate(0, -25%)';
        }
        else if (direction === 'left') {
            transform = 'translate(25%, 0)';
        }
        else if (direction === 'right') {
            transform = 'translate(-25%, 0)';
        }
        else {
            throw new Error('Unknown direction ' + direction + ' for slide animation.');
        }
        return [
            animations.transition('void => *', [animations.style({ opacity: 0, transform: transform }), animations.animate(defaultAnimationTiming)]),
            animations.transition('* => void', [animations.animate(defaultAnimationTiming, animations.style({ opacity: 0, transform: transform }))]),
        ];
    }

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */

    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    function slide(direction) {
        var transform = null;
        if (direction === 'up') {
            transform = 'translate(0, 25%)';
        }
        else if (direction === 'down') {
            transform = 'translate(0, -25%)';
        }
        else if (direction === 'left') {
            transform = 'translate(25%, 0)';
        }
        else if (direction === 'right') {
            transform = 'translate(-25%, 0)';
        }
        else {
            throw new Error('Unknown direction ' + direction + ' for slide animation.');
        }
        return [
            animations.transition('void => *', [animations.style({ transform: transform }), animations.animate(defaultAnimationTiming)]),
            animations.transition('* => void', [animations.animate(defaultAnimationTiming, animations.style({ transform: transform }))]),
        ];
    }

    exports.CLR_ALERT_DIRECTIVES = CLR_ALERT_DIRECTIVES;
    exports.CLR_BUTTON_GROUP_DIRECTIVES = CLR_BUTTON_GROUP_DIRECTIVES;
    exports.CLR_DATAGRID_DIRECTIVES = CLR_DATAGRID_DIRECTIVES;
    exports.CLR_DATEPICKER_DIRECTIVES = CLR_DATEPICKER_DIRECTIVES;
    exports.CLR_DRAG_AND_DROP_DIRECTIVES = CLR_DRAG_AND_DROP_DIRECTIVES;
    exports.CLR_DROPDOWN_DIRECTIVES = CLR_DROPDOWN_DIRECTIVES;
    exports.CLR_ICON_DIRECTIVES = CLR_ICON_DIRECTIVES;
    exports.CLR_LAYOUT_DIRECTIVES = CLR_LAYOUT_DIRECTIVES;
    exports.CLR_LOADING_BUTTON_DIRECTIVES = CLR_LOADING_BUTTON_DIRECTIVES;
    exports.CLR_LOADING_DIRECTIVES = CLR_LOADING_DIRECTIVES;
    exports.CLR_MENU_POSITIONS = CLR_MENU_POSITIONS;
    exports.CLR_MODAL_DIRECTIVES = CLR_MODAL_DIRECTIVES;
    exports.CLR_NAVIGATION_DIRECTIVES = CLR_NAVIGATION_DIRECTIVES;
    exports.CLR_PROGRESS_BAR_DIRECTIVES = CLR_PROGRESS_BAR_DIRECTIVES;
    exports.CLR_SIGNPOST_DIRECTIVES = CLR_SIGNPOST_DIRECTIVES;
    exports.CLR_SPINNER_DIRECTIVES = CLR_SPINNER_DIRECTIVES;
    exports.CLR_STACK_VIEW_DIRECTIVES = CLR_STACK_VIEW_DIRECTIVES;
    exports.CLR_TABS_DIRECTIVES = CLR_TABS_DIRECTIVES;
    exports.CLR_TOOLTIP_DIRECTIVES = CLR_TOOLTIP_DIRECTIVES;
    exports.CLR_TREE_VIEW_DIRECTIVES = CLR_TREE_VIEW_DIRECTIVES;
    exports.CLR_VERTICAL_NAV_DIRECTIVES = CLR_VERTICAL_NAV_DIRECTIVES;
    exports.CLR_WIZARD_DIRECTIVES = CLR_WIZARD_DIRECTIVES;
    exports.CONDITIONAL_DIRECTIVES = CONDITIONAL_DIRECTIVES;
    exports.CUSTOM_BUTTON_TYPES = CUSTOM_BUTTON_TYPES;
    exports.ClarityModule = ClarityModule;
    exports.ClrAbstractContainer = ClrAbstractContainer;
    exports.ClrAccordion = ClrAccordion;
    exports.ClrAccordionContent = ClrAccordionContent;
    exports.ClrAccordionDescription = ClrAccordionDescription;
    exports.ClrAccordionModule = ClrAccordionModule;
    exports.ClrAccordionPanel = ClrAccordionPanel;
    exports.ClrAccordionTitle = ClrAccordionTitle;
    exports.ClrAlert = ClrAlert;
    exports.ClrAlertItem = ClrAlertItem;
    exports.ClrAlertModule = ClrAlertModule;
    exports.ClrAlertText = ClrAlertText;
    exports.ClrAlerts = ClrAlerts;
    exports.ClrAlertsPager = ClrAlertsPager;
    exports.ClrAriaLiveService = ClrAriaLiveService;
    exports.ClrButton = ClrButton;
    exports.ClrButtonGroup = ClrButtonGroup;
    exports.ClrButtonGroupModule = ClrButtonGroupModule;
    exports.ClrButtonModule = ClrButtonModule;
    exports.ClrCalendar = ClrCalendar;
    exports.ClrCheckbox = ClrCheckbox;
    exports.ClrCheckboxContainer = ClrCheckboxContainer;
    exports.ClrCheckboxModule = ClrCheckboxModule;
    exports.ClrCheckboxWrapper = ClrCheckboxWrapper;
    exports.ClrCommonFormsModule = ClrCommonFormsModule;
    exports.ClrCommonStringsService = ClrCommonStringsService;
    exports.ClrConditionalModule = ClrConditionalModule;
    exports.ClrControl = ClrControl;
    exports.ClrControlContainer = ClrControlContainer;
    exports.ClrControlError = ClrControlError;
    exports.ClrControlHelper = ClrControlHelper;
    exports.ClrDataModule = ClrDataModule;
    exports.ClrDatagrid = ClrDatagrid;
    exports.ClrDatagridActionBar = ClrDatagridActionBar;
    exports.ClrDatagridActionOverflow = ClrDatagridActionOverflow;
    exports.ClrDatagridCell = ClrDatagridCell;
    exports.ClrDatagridColumn = ClrDatagridColumn;
    exports.ClrDatagridColumnSeparator = ClrDatagridColumnSeparator;
    exports.ClrDatagridColumnToggle = ClrDatagridColumnToggle;
    exports.ClrDatagridColumnToggleButton = ClrDatagridColumnToggleButton;
    exports.ClrDatagridColumnToggleTitle = ClrDatagridColumnToggleTitle;
    exports.ClrDatagridDetail = ClrDatagridDetail;
    exports.ClrDatagridDetailBody = ClrDatagridDetailBody;
    exports.ClrDatagridDetailHeader = ClrDatagridDetailHeader;
    exports.ClrDatagridFilter = ClrDatagridFilter;
    exports.ClrDatagridFooter = ClrDatagridFooter;
    exports.ClrDatagridHideableColumn = ClrDatagridHideableColumn;
    exports.ClrDatagridItems = ClrDatagridItems;
    exports.ClrDatagridItemsTrackBy = ClrDatagridItemsTrackBy;
    exports.ClrDatagridModule = ClrDatagridModule;
    exports.ClrDatagridPageSize = ClrDatagridPageSize;
    exports.ClrDatagridPagination = ClrDatagridPagination;
    exports.ClrDatagridPlaceholder = ClrDatagridPlaceholder;
    exports.ClrDatagridRow = ClrDatagridRow;
    exports.ClrDatagridRowDetail = ClrDatagridRowDetail;
    exports.ClrDatalist = ClrDatalist;
    exports.ClrDatalistContainer = ClrDatalistContainer;
    exports.ClrDatalistInput = ClrDatalistInput;
    exports.ClrDatalistModule = ClrDatalistModule;
    exports.ClrDateContainer = ClrDateContainer;
    exports.ClrDateInput = ClrDateInput;
    exports.ClrDatepickerModule = ClrDatepickerModule;
    exports.ClrDatepickerViewManager = ClrDatepickerViewManager;
    exports.ClrDay = ClrDay;
    exports.ClrDaypicker = ClrDaypicker;
    exports.ClrDragAndDropModule = ClrDragAndDropModule;
    exports.ClrDragEvent = ClrDragEvent;
    exports.ClrDragHandle = ClrDragHandle;
    exports.ClrDraggable = ClrDraggable;
    exports.ClrDraggableGhost = ClrDraggableGhost;
    exports.ClrDropdown = ClrDropdown;
    exports.ClrDropdownItem = ClrDropdownItem;
    exports.ClrDropdownMenu = ClrDropdownMenu;
    exports.ClrDropdownModule = ClrDropdownModule;
    exports.ClrDropdownTrigger = ClrDropdownTrigger;
    exports.ClrDroppable = ClrDroppable;
    exports.ClrEmphasisModule = ClrEmphasisModule;
    exports.ClrExpandableAnimation = ClrExpandableAnimation;
    exports.ClrFocusOnViewInit = ClrFocusOnViewInit;
    exports.ClrFocusOnViewInitModule = ClrFocusOnViewInitModule;
    exports.ClrForm = ClrForm;
    exports.ClrFormsModule = ClrFormsModule;
    exports.ClrHeader = ClrHeader;
    exports.ClrIconCustomTag = ClrIconCustomTag;
    exports.ClrIconModule = ClrIconModule;
    exports.ClrIfActive = ClrIfActive;
    exports.ClrIfDetail = ClrIfDetail;
    exports.ClrIfDragged = ClrIfDragged;
    exports.ClrIfError = ClrIfError;
    exports.ClrIfExpanded = ClrIfExpanded;
    exports.ClrIfOpen = ClrIfOpen;
    exports.ClrInput = ClrInput;
    exports.ClrInputContainer = ClrInputContainer;
    exports.ClrInputModule = ClrInputModule;
    exports.ClrLabel = ClrLabel;
    exports.ClrLayout = ClrLayout;
    exports.ClrLayoutModule = ClrLayoutModule;
    exports.ClrLoading = ClrLoading;
    exports.ClrLoadingButton = ClrLoadingButton;
    exports.ClrLoadingButtonModule = ClrLoadingButtonModule;
    exports.ClrLoadingModule = ClrLoadingModule;
    exports.ClrMainContainer = ClrMainContainer;
    exports.ClrMainContainerModule = ClrMainContainerModule;
    exports.ClrModal = ClrModal;
    exports.ClrModalBody = ClrModalBody;
    exports.ClrModalModule = ClrModalModule;
    exports.ClrMonthpicker = ClrMonthpicker;
    exports.ClrNavLevel = ClrNavLevel;
    exports.ClrNavigationModule = ClrNavigationModule;
    exports.ClrPassword = ClrPassword;
    exports.ClrPasswordContainer = ClrPasswordContainer;
    exports.ClrPasswordModule = ClrPasswordModule;
    exports.ClrPopoverAnchor = ClrPopoverAnchor;
    exports.ClrPopoverContent = ClrPopoverContent;
    exports.ClrPopoverEventsService = ClrPopoverEventsService;
    exports.ClrPopoverModule = ClrPopoverModule;
    exports.ClrPopoverPositionService = ClrPopoverPositionService;
    exports.ClrPopoverToggleService = ClrPopoverToggleService;
    exports.ClrProgressBar = ClrProgressBar;
    exports.ClrProgressBarModule = ClrProgressBarModule;
    exports.ClrRadio = ClrRadio;
    exports.ClrRadioContainer = ClrRadioContainer;
    exports.ClrRadioModule = ClrRadioModule;
    exports.ClrRadioWrapper = ClrRadioWrapper;
    exports.ClrRange = ClrRange;
    exports.ClrRangeContainer = ClrRangeContainer;
    exports.ClrRangeModule = ClrRangeModule;
    exports.ClrRecursiveForOf = ClrRecursiveForOf;
    exports.ClrSelect = ClrSelect;
    exports.ClrSelectContainer = ClrSelectContainer;
    exports.ClrSelectModule = ClrSelectModule;
    exports.ClrSignpost = ClrSignpost;
    exports.ClrSignpostContent = ClrSignpostContent;
    exports.ClrSignpostModule = ClrSignpostModule;
    exports.ClrSignpostTrigger = ClrSignpostTrigger;
    exports.ClrSpinner = ClrSpinner;
    exports.ClrSpinnerModule = ClrSpinnerModule;
    exports.ClrStackBlock = ClrStackBlock;
    exports.ClrStackContentInput = ClrStackContentInput;
    exports.ClrStackHeader = ClrStackHeader;
    exports.ClrStackInput = ClrStackInput;
    exports.ClrStackSelect = ClrStackSelect;
    exports.ClrStackView = ClrStackView;
    exports.ClrStackViewCustomTags = ClrStackViewCustomTags;
    exports.ClrStackViewModule = ClrStackViewModule;
    exports.ClrStepButton = ClrStepButton;
    exports.ClrStepper = ClrStepper;
    exports.ClrStepperModule = ClrStepperModule;
    exports.ClrStepperPanel = ClrStepperPanel;
    exports.ClrTab = ClrTab;
    exports.ClrTabContent = ClrTabContent;
    exports.ClrTabLink = ClrTabLink;
    exports.ClrTabOverflowContent = ClrTabOverflowContent;
    exports.ClrTabs = ClrTabs;
    exports.ClrTabsModule = ClrTabsModule;
    exports.ClrTextarea = ClrTextarea;
    exports.ClrTextareaContainer = ClrTextareaContainer;
    exports.ClrTextareaModule = ClrTextareaModule;
    exports.ClrTimeline = ClrTimeline;
    exports.ClrTimelineModule = ClrTimelineModule;
    exports.ClrTimelineStep = ClrTimelineStep;
    exports.ClrTimelineStepDescription = ClrTimelineStepDescription;
    exports.ClrTimelineStepHeader = ClrTimelineStepHeader;
    exports.ClrTimelineStepTitle = ClrTimelineStepTitle;
    exports.ClrTooltip = ClrTooltip;
    exports.ClrTooltipContent = ClrTooltipContent;
    exports.ClrTooltipModule = ClrTooltipModule;
    exports.ClrTooltipTrigger = ClrTooltipTrigger;
    exports.ClrTree = ClrTree;
    exports.ClrTreeNode = ClrTreeNode;
    exports.ClrTreeNodeLink = ClrTreeNodeLink;
    exports.ClrTreeViewModule = ClrTreeViewModule;
    exports.ClrVerticalNav = ClrVerticalNav;
    exports.ClrVerticalNavGroup = ClrVerticalNavGroup;
    exports.ClrVerticalNavGroupChildren = ClrVerticalNavGroupChildren;
    exports.ClrVerticalNavIcon = ClrVerticalNavIcon;
    exports.ClrVerticalNavLink = ClrVerticalNavLink;
    exports.ClrVerticalNavModule = ClrVerticalNavModule;
    exports.ClrWizard = ClrWizard;
    exports.ClrWizardButton = ClrWizardButton;
    exports.ClrWizardCustomTags = ClrWizardCustomTags;
    exports.ClrWizardHeaderAction = ClrWizardHeaderAction;
    exports.ClrWizardModule = ClrWizardModule;
    exports.ClrWizardPage = ClrWizardPage;
    exports.ClrWizardPageButtons = ClrWizardPageButtons;
    exports.ClrWizardPageHeaderActions = ClrWizardPageHeaderActions;
    exports.ClrWizardPageNavTitle = ClrWizardPageNavTitle;
    exports.ClrWizardPageTitle = ClrWizardPageTitle;
    exports.ClrWizardStepnav = ClrWizardStepnav;
    exports.ClrWizardStepnavItem = ClrWizardStepnavItem;
    exports.ClrYearpicker = ClrYearpicker;
    exports.DEFAULT_BUTTON_TYPES = DEFAULT_BUTTON_TYPES;
    exports.DatagridNumericFilter = DatagridNumericFilter;
    exports.DatagridPropertyComparator = DatagridPropertyComparator;
    exports.DatagridPropertyNumericFilter = DatagridPropertyNumericFilter;
    exports.DatagridPropertyStringFilter = DatagridPropertyStringFilter;
    exports.DatagridStringFilter = DatagridStringFilter;
    exports.EXPANDABLE_ANIMATION_DIRECTIVES = EXPANDABLE_ANIMATION_DIRECTIVES;
    exports.FOCUS_ON_VIEW_INIT = FOCUS_ON_VIEW_INIT;
    exports.FOCUS_ON_VIEW_INIT_DIRECTIVES = FOCUS_ON_VIEW_INIT_DIRECTIVES;
    exports.IS_TOGGLE = IS_TOGGLE;
    exports.IS_TOGGLE_PROVIDER = IS_TOGGLE_PROVIDER;
    exports.LoadingListener = LoadingListener;
    exports.MainContainerWillyWonka = MainContainerWillyWonka;
    exports.NavDetectionOompaLoompa = NavDetectionOompaLoompa;
    exports.TOGGLE_SERVICE = TOGGLE_SERVICE;
    exports.TOGGLE_SERVICE_PROVIDER = TOGGLE_SERVICE_PROVIDER;
    exports.ToggleServiceFactory = ToggleServiceFactory;
    exports.WrappedFormControl = WrappedFormControl;
    exports.collapse = collapse;
    exports.commonStringsDefault = commonStringsDefault;
    exports.fade = fade;
    exports.fadeSlide = fadeSlide;
    exports.isToggleFactory = isToggleFactory;
    exports.slide = slide;
    exports.ÇlrFocusTrapTracker = FocusTrapTracker;
    exports.ɵa = FOCUS_ON_VIEW_INIT_PROVIDER;
    exports.ɵb = RootDropdownService;
    exports.ɵba = LayoutService;
    exports.ɵbb = NgControlService;
    exports.ɵbc = ControlClassService;
    exports.ɵbd = IfErrorService;
    exports.ɵbe = MarkControlService;
    exports.ɵbf = ClrHostWrappingModule;
    exports.ɵbg = EmptyAnchor;
    exports.ɵbh = ClrPopoverModuleNext;
    exports.ɵbi = ClrPopoverCloseButton;
    exports.ɵbj = ClrPopoverOpenCloseButton;
    exports.ɵbk = FOCUS_TRAP_DIRECTIVES;
    exports.ɵbl = ClrFocusTrapModule;
    exports.ɵbm = FocusTrapDirective;
    exports.ɵbn = DateNavigationService;
    exports.ɵbo = DateFormControlService;
    exports.ɵbp = LocaleHelperService;
    exports.ɵbq = FocusService;
    exports.ɵbr = DateIOService;
    exports.ɵbs = DatepickerEnabledService;
    exports.ɵbt = ViewManagerService;
    exports.ɵbu = DatepickerFocusService;
    exports.ɵbv = DatalistIdService;
    exports.ɵbw = ClrOutsideClickModule;
    exports.ɵbx = OUSTIDE_CLICK_DIRECTIVES;
    exports.ɵby = OutsideClick;
    exports.ɵbz = ClrExpandableAnimationModule;
    exports.ɵc = clrRootDropdownFactory;
    exports.ɵca = DomAdapter;
    exports.ɵcb = DragEventListenerService;
    exports.ɵcc = DragAndDropEventBusService;
    exports.ɵcd = DragHandleRegistrarService;
    exports.ɵce = DraggableSnapshotService;
    exports.ɵcf = GlobalDragModeService;
    exports.ɵcg = Selection;
    exports.ɵch = Items;
    exports.ɵci = FiltersProvider;
    exports.ɵcj = Page;
    exports.ɵck = StateDebouncer;
    exports.ɵcl = Sort;
    exports.ɵcm = DatagridRenderOrganizer;
    exports.ɵcn = RowActionService;
    exports.ɵco = ExpandableRowsCount;
    exports.ɵcp = DetailService;
    exports.ɵcq = StateProvider;
    exports.ɵcr = TableSizeService;
    exports.ɵcs = ColumnsService;
    exports.ɵct = DisplayModeService;
    exports.ɵcu = DatagridFilterRegistrar;
    exports.ɵcv = CustomFilter;
    exports.ɵcw = DatagridIfExpandService;
    exports.ɵcx = SignpostFocusManager;
    exports.ɵcy = SignpostIdService;
    exports.ɵcz = ColumnResizerService;
    exports.ɵd = ROOT_DROPDOWN_PROVIDER;
    exports.ɵda = COLUMN_STATE;
    exports.ɵdb = columnStateFactory;
    exports.ɵdc = COLUMN_STATE_PROVIDER;
    exports.ɵde = DatagridDetailRegisterer;
    exports.ɵdf = WrappedCell;
    exports.ɵdg = WrappedColumn;
    exports.ɵdh = WrappedRow;
    exports.ɵdi = domAdapterFactory;
    exports.ɵdj = DatagridMainRenderer;
    exports.ɵdk = DatagridHeaderRenderer;
    exports.ɵdl = DatagridRowRenderer;
    exports.ɵdm = DatagridCellRenderer;
    exports.ɵdn = DatagridWillyWonka;
    exports.ɵdo = WillyWonka;
    exports.ɵdp = ActionableOompaLoompa;
    exports.ɵdq = OompaLoompa;
    exports.ɵdr = ExpandableOompaLoompa;
    exports.ɵds = StackControl;
    exports.ɵdt = TreeFeaturesService;
    exports.ɵdu = treeFeaturesFactory;
    exports.ɵdv = TREE_FEATURES_PROVIDER;
    exports.ɵdw = TreeFocusManagerService;
    exports.ɵdx = RecursiveChildren;
    exports.ɵdy = ScrollingService;
    exports.ɵdz = ButtonInGroupService;
    exports.ɵe = POPOVER_HOST_ANCHOR;
    exports.ɵea = ResponsiveNavigationService;
    exports.ɵeb = ClrTemplateRefModule;
    exports.ɵec = TEMPLATE_REF_DIRECTIVES;
    exports.ɵed = TemplateRefContainer;
    exports.ɵee = ClrKeyFocusModule;
    exports.ɵef = ClrKeyFocus;
    exports.ɵeg = ClrKeyFocusItem;
    exports.ɵeh = AriaService;
    exports.ɵei = TabsService;
    exports.ɵej = TABS_ID;
    exports.ɵek = tokenFactory$1;
    exports.ɵel = TABS_ID_PROVIDER;
    exports.ɵem = TabsWillyWonka;
    exports.ɵen = ActiveOompaLoompa;
    exports.ɵeo = VerticalNavService;
    exports.ɵep = VerticalNavIconService;
    exports.ɵeq = VerticalNavGroupRegistrationService;
    exports.ɵer = VerticalNavGroupService;
    exports.ɵes = TooltipIdService;
    exports.ɵet = WizardNavigationService;
    exports.ɵeu = PageCollectionService;
    exports.ɵev = ButtonHubService;
    exports.ɵew = HeaderActionService;
    exports.ɵex = AccordionService;
    exports.ɵey = panelAnimation;
    exports.ɵez = stepAnimation;
    exports.ɵf = FocusService$1;
    exports.ɵfa = defaultAnimationTiming;
    exports.ɵfb = AccordionOompaLoompa;
    exports.ɵfc = AccordionWillyWonka;
    exports.ɵfd = StepperService;
    exports.ɵfe = StepperOompaLoompa;
    exports.ɵff = StepperWillyWonka;
    exports.ɵfg = TimelineIconAttributeService;
    exports.ɵg = clrFocusServiceFactory;
    exports.ɵh = FOCUS_SERVICE_PROVIDER;
    exports.ɵi = DropdownFocusHandler;
    exports.ɵj = DROPDOWN_FOCUS_HANDLER_PROVIDER;
    exports.ɵk = customFocusableItemProvider;
    exports.ɵl = UNIQUE_ID;
    exports.ɵm = uniqueIdFactory;
    exports.ɵn = UNIQUE_ID_PROVIDER;
    exports.ɵo = FocusableItem;
    exports.ɵp = AbstractPopover;
    exports.ɵq = BasicFocusableItem;
    exports.ɵr = BASIC_FOCUSABLE_ITEM_PROVIDER;
    exports.ɵs = IF_ACTIVE_ID;
    exports.ɵt = tokenFactory;
    exports.ɵu = IF_ACTIVE_ID_PROVIDER;
    exports.ɵv = IfActiveService;
    exports.ɵw = IfExpandService;
    exports.ɵx = AlertIconAndTypesService;
    exports.ɵy = MultiAlertService;
    exports.ɵz = ControlIdService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=clr-angular.umd.js.map