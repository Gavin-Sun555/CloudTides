import { __decorate, __param } from "tslib";
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { isPlatformBrowser } from '@angular/common';
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
/**
 * @description
 * Internal datagrid service that holds a reference to the clr-dg-table element and exposes a method to get height.
 */
import * as ɵngcc0 from '@angular/core';
let TableSizeService = class TableSizeService {
    constructor(platformId) {
        this.platformId = platformId;
    }
    get tableRef() {
        return this._tableRef;
    }
    set tableRef(element) {
        this._tableRef = element;
    }
    set table(table) {
        if (isPlatformBrowser(this.platformId) && table.nativeElement) {
            this.tableRef = table.nativeElement.querySelector('.datagrid-table');
        }
    }
    // Used when resizing columns to show the column border being dragged.
    getColumnDragHeight() {
        if (!this.tableRef) {
            return;
        }
        return `${this.tableRef.clientHeight}px`;
    }
};
TableSizeService.ɵfac = function TableSizeService_Factory(t) { return new (t || TableSizeService)(ɵngcc0.ɵɵinject(PLATFORM_ID)); };
TableSizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TableSizeService, factory: TableSizeService.ɵfac });
TableSizeService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
TableSizeService = __decorate([ __param(0, Inject(PLATFORM_ID))
], TableSizeService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TableSizeService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, null); })();
export { TableSizeService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtc2l6ZS5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFjLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTVFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsSUFBYSxnQkFBZ0IsR0FBN0IsTUFBYSxnQkFBZ0I7QUFDN0IsSUFVRSxZQUF5QyxVQUFrQjtBQUFJLFFBQXRCLGVBQVUsR0FBVixVQUFVLENBQVE7QUFBQyxJQUFFLENBQUM7QUFDakUsSUFURSxJQUFXLFFBQVE7QUFBSyxRQUN0QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDMUIsSUFBRSxDQUFDO0FBQ0gsSUFDRSxJQUFXLFFBQVEsQ0FBQyxPQUFvQjtBQUMxQyxRQUFJLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO0FBQzdCLElBQUUsQ0FBQztBQUNILElBRUUsSUFBVyxLQUFLLENBQUMsS0FBaUI7QUFDcEMsUUFBSSxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLENBQUMsYUFBYSxFQUFFO0FBQ25FLFlBQU0sSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzNFLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNFLHNFQUFzRTtBQUN4RSxJQUFFLG1CQUFtQjtBQUFLLFFBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ3hCLFlBQU0sT0FBTztBQUNiLFNBQUs7QUFDTCxRQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksSUFBSSxDQUFDO0FBQzdDLElBQUUsQ0FBQztBQUNILENBQUM7O2dIQUFBO0FBQ0Q7QUFBMEMsWUFmYSxNQUFNLHVCQUE5QyxNQUFNLFNBQUMsV0FBVztBQUFRO0FBWDVCLGdCQUFnQixvQkFENUIsVUFBVSxFQUFFLGpCQUNULENBV1csV0FBQSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7QUFBQyxHQVh0QixnQkFBZ0IsQ0F5QjVCOzs7Ozs7a0NBQ0Q7QUFBQyxTQTFCWSxnQkFBZ0I7QUFDNUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJbnRlcm5hbCBkYXRhZ3JpZCBzZXJ2aWNlIHRoYXQgaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIGNsci1kZy10YWJsZSBlbGVtZW50IGFuZCBleHBvc2VzIGEgbWV0aG9kIHRvIGdldCBoZWlnaHQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJsZVNpemVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfdGFibGVSZWY6IEhUTUxFbGVtZW50O1xuXG4gIHB1YmxpYyBnZXQgdGFibGVSZWYoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl90YWJsZVJlZjtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgdGFibGVSZWYoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLl90YWJsZVJlZiA9IGVsZW1lbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCkge31cbiAgcHVibGljIHNldCB0YWJsZSh0YWJsZTogRWxlbWVudFJlZikge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIHRhYmxlLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMudGFibGVSZWYgPSB0YWJsZS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kYXRhZ3JpZC10YWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiByZXNpemluZyBjb2x1bW5zIHRvIHNob3cgdGhlIGNvbHVtbiBib3JkZXIgYmVpbmcgZHJhZ2dlZC5cbiAgZ2V0Q29sdW1uRHJhZ0hlaWdodCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy50YWJsZVJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy50YWJsZVJlZi5jbGllbnRIZWlnaHR9cHhgO1xuICB9XG59XG4iXX0=