/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { ChangeDetectorRef, Directive, Input, OnChanges, OnDestroy, TemplateRef } from '@angular/core';
import { TreeFeaturesService } from './tree-features.service';
import { RecursiveTreeNodeModel } from './models/recursive-tree-node.model';
import { debounceTime } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
let ClrRecursiveForOf = class ClrRecursiveForOf {
    constructor(template, featuresService, cdr) {
        this.template = template;
        this.featuresService = featuresService;
        this.cdr = cdr;
    }
    // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
    ngOnChanges() {
        let wrapped;
        if (Array.isArray(this.nodes)) {
            wrapped = this.nodes.map(node => new RecursiveTreeNodeModel(node, null, this.getChildren, this.featuresService));
        }
        else {
            wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren, this.featuresService)];
        }
        if (!this.childrenFetchSubscription) {
            this.childrenFetchSubscription = this.featuresService.childrenFetched.pipe(debounceTime(0)).subscribe(() => {
                this.cdr.detectChanges();
            });
        }
        this.featuresService.recursion = {
            template: this.template,
            root: wrapped,
        };
    }
    ngOnDestroy() {
        if (this.childrenFetchSubscription) {
            this.childrenFetchSubscription.unsubscribe();
        }
    }
};
ClrRecursiveForOf.ɵfac = function ClrRecursiveForOf_Factory(t) { return new (t || ClrRecursiveForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ClrRecursiveForOf.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrRecursiveForOf, selectors: [["", "clrRecursiveFor", "", "clrRecursiveForOf", ""]], inputs: { nodes: ["clrRecursiveForOf", "nodes"], getChildren: ["clrRecursiveForGetChildren", "getChildren"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
ClrRecursiveForOf.ctorParameters = () => [
    { type: TemplateRef },
    { type: TreeFeaturesService },
    { type: ChangeDetectorRef }
];
__decorate([
    Input('clrRecursiveForOf')
], ClrRecursiveForOf.prototype, "nodes", void 0);
__decorate([
    Input('clrRecursiveForGetChildren')
], ClrRecursiveForOf.prototype, "getChildren", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRecursiveForOf, [{
        type: Directive,
        args: [{ selector: '[clrRecursiveFor][clrRecursiveForOf]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: TreeFeaturesService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { nodes: [{
            type: Input,
            args: ['clrRecursiveForOf']
        }], getChildren: [{
            type: Input,
            args: ['clrRecursiveForGetChildren']
        }] }); })();
export { ClrRecursiveForOf };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlLWZvci1vZi5qcyIsInNvdXJjZXMiOlsibmc6L0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9yZWN1cnNpdmUtZm9yLW9mLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkcsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFJNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQVE5QyxJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFpQjtBQUFHLElBQy9CLFlBQ1UsUUFBa0QsRUFDbEQsZUFBdUMsRUFDdkMsR0FBc0I7QUFDL0IsUUFIUyxhQUFRLEdBQVIsUUFBUSxDQUEwQztBQUFDLFFBQ25ELG9CQUFlLEdBQWYsZUFBZSxDQUF3QjtBQUFDLFFBQ3hDLFFBQUcsR0FBSCxHQUFHLENBQW1CO0FBQ2xDLElBQUssQ0FBQztBQUNOLElBU0UsK0dBQStHO0FBQ2pILElBQUUsV0FBVztBQUNiLFFBQUksSUFBSSxPQUFvQyxDQUFDO0FBQzdDLFFBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUNuQyxZQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksc0JBQXNCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO0FBQ3ZILFNBQUs7QUFBQyxhQUFLO0FBQ1gsWUFBTSxPQUFPLEdBQUcsQ0FBQyxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7QUFDdkcsU0FBSztBQUNMLFFBQUksSUFBSSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtBQUN6QyxZQUFNLElBQUksQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtBQUNqSCxnQkFBUSxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQ2pDLFlBQU0sQ0FBQyxDQUFDLENBQUM7QUFDVCxTQUFLO0FBQ0wsUUFDSSxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsR0FBRztBQUNyQyxZQUFNLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtBQUM3QixZQUFNLElBQUksRUFBRSxPQUFPO0FBQ25CLFNBQUssQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILElBQ0UsV0FBVztBQUNiLFFBQUksSUFBSSxJQUFJLENBQUMseUJBQXlCLEVBQUU7QUFDeEMsWUFBTSxJQUFJLENBQUMseUJBQXlCLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDbkQsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILENBQUM7OzBTQUFBO0FBQ0Q7QUFBMkMsWUF2Q3JCLFdBQVc7QUFBSSxZQUNSLG1CQUFtQjtBQUFJLFlBQ25DLGlCQUFpQjtBQUNoQztBQUc0QjtBQUFhLElBQXhDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQztBQUFDLGdEQUFlO0FBR047QUFBYSxJQUFqRCxLQUFLLENBQUMsNEJBQTRCLENBQUM7QUFBQyxzREFBd0M7QUFYbEUsaUJBQWlCLG9CQUQ3QixTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUU7cUJBQXNDLEVBQUUsQ0FBQztHQUNuRCxpQkFBaUIsQ0F3QzdCOzs7Ozs7O29CQUNEO0FBQUMsU0F6Q1ksaUJBQWlCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjAgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyZWVGZWF0dXJlc1NlcnZpY2UgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5pbXBvcnQgeyBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvcmVjdXJzaXZlLXRyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IEFzeW5jQXJyYXkgfSBmcm9tICcuL21vZGVscy9hc3luYy1hcnJheSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQ8VD4ge1xuICAkaW1wbGljaXQ6IFQ7XG4gIGNsck1vZGVsOiBUcmVlTm9kZU1vZGVsPFQ+O1xufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUmVjdXJzaXZlRm9yXVtjbHJSZWN1cnNpdmVGb3JPZl0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyUmVjdXJzaXZlRm9yT2Y8VD4gaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPj4sXG4gICAgcHJpdmF0ZSBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICkge31cblxuICAvLyBUT0RPOiBhY2NlcHQgTmdJdGVyYWJsZTxUPlxuICBASW5wdXQoJ2NsclJlY3Vyc2l2ZUZvck9mJykgbm9kZXM6IFQgfCBUW107XG5cbiAgLy8gVE9ETzogYWNjZXB0IE5nSXRlcmFibGU8VD4gcmV0dXJuIHR5cGVcbiAgQElucHV0KCdjbHJSZWN1cnNpdmVGb3JHZXRDaGlsZHJlbicpIGdldENoaWxkcmVuOiAobm9kZTogVCkgPT4gQXN5bmNBcnJheTxUPjtcblxuICBwcml2YXRlIGNoaWxkcmVuRmV0Y2hTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvLyBJJ20gdXNpbmcgT25DaGFuZ2VzIGluc3RlYWQgb2YgT25Jbml0IHRvIGVhc2lseSBrZWVwIHVwIHRvIGRhdGUgd2l0aCBkeW5hbWljIHRyZWVzLiBNYXliZSBvcHRpbWl6YWJsZSBsYXRlci5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgbGV0IHdyYXBwZWQ6IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD5bXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSkge1xuICAgICAgd3JhcHBlZCA9IHRoaXMubm9kZXMubWFwKG5vZGUgPT4gbmV3IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwobm9kZSwgbnVsbCwgdGhpcy5nZXRDaGlsZHJlbiwgdGhpcy5mZWF0dXJlc1NlcnZpY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JhcHBlZCA9IFtuZXcgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCh0aGlzLm5vZGVzLCBudWxsLCB0aGlzLmdldENoaWxkcmVuLCB0aGlzLmZlYXR1cmVzU2VydmljZSldO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2hpbGRyZW5GZXRjaFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jaGlsZHJlbkZldGNoU3Vic2NyaXB0aW9uID0gdGhpcy5mZWF0dXJlc1NlcnZpY2UuY2hpbGRyZW5GZXRjaGVkLnBpcGUoZGVib3VuY2VUaW1lKDApKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24gPSB7XG4gICAgICB0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgICAgIHJvb3Q6IHdyYXBwZWQsXG4gICAgfTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuRmV0Y2hTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5GZXRjaFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19