/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { Component, Input, Optional } from '@angular/core';
import { IfExpandService } from '../../utils/conditional/if-expanded.service';
import { TreeFeaturesService } from './tree-features.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function RecursiveChildren_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const child_r2 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.featuresService.recursion.template)("ngTemplateOutletContext", ctx_r1.getContext(child_r2));
} }
function RecursiveChildren_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_Template, 2, 2, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", (ctx_r0.parent == null ? null : ctx_r0.parent.children) || ctx_r0.children);
} }
let RecursiveChildren = 
/**
 * Internal component, do not export!
 * This is part of the hack to get around https://github.com/angular/angular/issues/15998
 */
class RecursiveChildren {
    constructor(featuresService, expandService) {
        this.featuresService = featuresService;
        this.expandService = expandService;
        if (expandService) {
            this.subscription = this.expandService.expandChange.subscribe(value => {
                if (!value && this.parent && !this.featuresService.eager && this.featuresService.recursion) {
                    // In the case of lazy-loading recursive trees, we clear the children on collapse.
                    // This is better in case they change between two user interaction, and that way
                    // the app itself can decide whether to cache them or not.
                    this.parent.clearChildren();
                }
            });
        }
    }
    shouldRender() {
        return (this.featuresService.recursion &&
            // In the smart case, we eagerly render all the recursive children
            // to make sure two-way bindings for selection are available.
            // They will be hidden with CSS by the parent.
            (this.featuresService.eager || !this.expandService || this.expandService.expanded));
    }
    getContext(node) {
        return {
            $implicit: node.model,
            clrModel: node,
        };
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
};
RecursiveChildren.ɵfac = function RecursiveChildren_Factory(t) { return new (t || RecursiveChildren)(ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(IfExpandService, 8)); };
RecursiveChildren.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RecursiveChildren, selectors: [["clr-recursive-children"]], hostVars: 1, hostBindings: function RecursiveChildren_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "group");
    } }, inputs: { parent: "parent", children: "children" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function RecursiveChildren_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, RecursiveChildren_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldRender());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
RecursiveChildren.ctorParameters = () => [
    { type: TreeFeaturesService },
    { type: IfExpandService, decorators: [{ type: Optional }] }
];
__decorate([
    Input('parent')
], RecursiveChildren.prototype, "parent", void 0);
__decorate([
    Input('children')
], RecursiveChildren.prototype, "children", void 0);
RecursiveChildren = __decorate([ __param(1, Optional())
], RecursiveChildren);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RecursiveChildren, [{
        type: Component,
        args: [{
                selector: 'clr-recursive-children',
                template: `
    <ng-container *ngIf="shouldRender()">
      <ng-container *ngFor="let child of parent?.children || children">
        <ng-container *ngTemplateOutlet="featuresService.recursion.template; context: getContext(child)"></ng-container>
      </ng-container>
    </ng-container>
  `,
                host: {
                    '[attr.role]': '"group"'
                }
            }]
    }], function () { return [{ type: TreeFeaturesService }, { type: IfExpandService, decorators: [{
                type: Optional
            }] }]; }, { parent: [{
            type: Input,
            args: ['parent']
        }], children: [{
            type: Input,
            args: ['children']
        }] }); })();
export { RecursiveChildren };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlLWNoaWxkcmVuLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L3JlY3Vyc2l2ZS1jaGlsZHJlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDOUUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0I5RCxJQUFhLGlCQUFpQjtBQUo5QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsTUFBYSxpQkFBaUI7QUFBRyxJQUMvQixZQUFtQixlQUF1QyxFQUFzQixhQUE4QjtBQUNoSCxRQURxQixvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7QUFBQyxRQUFxQixrQkFBYSxHQUFiLGFBQWEsQ0FBaUI7QUFBQyxRQUM3RyxJQUFJLGFBQWEsRUFBRTtBQUN2QixZQUFNLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzVFLGdCQUFRLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFO0FBQ3BHLG9CQUFVLGtGQUFrRjtBQUM1RixvQkFBVSxnRkFBZ0Y7QUFDMUYsb0JBQVUsMERBQTBEO0FBQ3BFLG9CQUFzQyxJQUFJLENBQUMsTUFBTyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQ25FLGlCQUFTO0FBQ1QsWUFBTSxDQUFDLENBQUMsQ0FBQztBQUNULFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNFLFlBQVk7QUFDZCxRQUFJLE9BQU8sQ0FDTCxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVM7QUFDcEMsWUFBTSxrRUFBa0U7QUFDeEUsWUFBTSw2REFBNkQ7QUFDbkUsWUFBTSw4Q0FBOEM7QUFDcEQsWUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUNuRixDQUFDO0FBQ04sSUFBRSxDQUFDO0FBQ0gsSUFNRSxVQUFVLENBQUMsSUFBc0I7QUFBSSxRQUNuQyxPQUFPO0FBQ1gsWUFBTSxTQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUs7QUFDM0IsWUFBTSxRQUFRLEVBQUUsSUFBSTtBQUNwQixTQUFLLENBQUM7QUFDTixJQUFFLENBQUM7QUFDSCxJQUdFLFdBQVc7QUFDYixRQUFJLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtBQUMzQixZQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDdEMsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILENBQUM7Ozs7Ozs7O2lHQUFBO0FBQ0Q7QUFBMkMsWUEzQ0wsbUJBQW1CO0FBQUksWUFBb0MsZUFBZSx1QkFBakQsUUFBUTtBQUFNO0FBeUIxRDtBQUFhLElBQTdCLEtBQUssQ0FBQyxRQUFRLENBQUM7QUFBQyxpREFBeUI7QUFDdkI7QUFBYSxJQUEvQixLQUFLLENBQUMsVUFBVSxDQUFDO0FBQUMsbURBQTZCO0FBM0JyQyxpQkFBaUIsb0JBakI3QixTQUFTLENBQUMsZkFpQkYsQ0FDc0QsV0FBQSxRQUFRLEVBQUUsQ0FBQTtDQWpCdkUsUUFBUSxFQUFFLFhBaUI4RCxHQUQ3RCxpQkFBaUIsQ0EyQzdCO1lBM0RtQyxVQUNsQyxRQUFRLEVBQUU7Ozs7Ozs7RUFNVCxVQUNELElBQUksRUFBRSxjQUNKLGFBQWEsRUFBRSxTQUFTLFdBQ3pCLE1BQ0YsQ0FBQyxLQUNGOzs7OztrQ0FHRzs7Ozs7Ozs7Ozs7b0JBNkNIO0FBQUMsU0E1Q1ksaUJBQWlCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFeHBhbmRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtZXhwYW5kZWQuc2VydmljZSc7XG5pbXBvcnQgeyBUcmVlRmVhdHVyZXNTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQgfSBmcm9tICcuL3JlY3Vyc2l2ZS1mb3Itb2YnO1xuaW1wb3J0IHsgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmVjdXJzaXZlLWNoaWxkcmVuJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2hvdWxkUmVuZGVyKClcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNoaWxkIG9mIHBhcmVudD8uY2hpbGRyZW4gfHwgY2hpbGRyZW5cIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24udGVtcGxhdGU7IGNvbnRleHQ6IGdldENvbnRleHQoY2hpbGQpXCI+PC9uZy1jb250YWluZXI+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYCxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5yb2xlXSc6ICdcImdyb3VwXCInLCAvLyBTYWZhcmkgKyBWTyBuZWVkcyBkaXJlY3QgcmVsYXRpb25zaGlwIGJldHdlZW4gdHJlZWl0ZW0gYW5kIGdyb3VwOyBubyBlbGVtZW50IHNob3VsZCBleGlzdCBiZXR3ZWVuIHRoZW1cbiAgfSxcbn0pXG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCwgZG8gbm90IGV4cG9ydCFcbiAqIFRoaXMgaXMgcGFydCBvZiB0aGUgaGFjayB0byBnZXQgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1OTk4XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWN1cnNpdmVDaGlsZHJlbjxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sIEBPcHRpb25hbCgpIHByaXZhdGUgZXhwYW5kU2VydmljZTogSWZFeHBhbmRTZXJ2aWNlKSB7XG4gICAgaWYgKGV4cGFuZFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZENoYW5nZS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlICYmIHRoaXMucGFyZW50ICYmICF0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciAmJiB0aGlzLmZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24pIHtcbiAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBsYXp5LWxvYWRpbmcgcmVjdXJzaXZlIHRyZWVzLCB3ZSBjbGVhciB0aGUgY2hpbGRyZW4gb24gY29sbGFwc2UuXG4gICAgICAgICAgLy8gVGhpcyBpcyBiZXR0ZXIgaW4gY2FzZSB0aGV5IGNoYW5nZSBiZXR3ZWVuIHR3byB1c2VyIGludGVyYWN0aW9uLCBhbmQgdGhhdCB3YXlcbiAgICAgICAgICAvLyB0aGUgYXBwIGl0c2VsZiBjYW4gZGVjaWRlIHdoZXRoZXIgdG8gY2FjaGUgdGhlbSBvciBub3QuXG4gICAgICAgICAgKDxSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+PnRoaXMucGFyZW50KS5jbGVhckNoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNob3VsZFJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uICYmXG4gICAgICAvLyBJbiB0aGUgc21hcnQgY2FzZSwgd2UgZWFnZXJseSByZW5kZXIgYWxsIHRoZSByZWN1cnNpdmUgY2hpbGRyZW5cbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0d28td2F5IGJpbmRpbmdzIGZvciBzZWxlY3Rpb24gYXJlIGF2YWlsYWJsZS5cbiAgICAgIC8vIFRoZXkgd2lsbCBiZSBoaWRkZW4gd2l0aCBDU1MgYnkgdGhlIHBhcmVudC5cbiAgICAgICh0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciB8fCAhdGhpcy5leHBhbmRTZXJ2aWNlIHx8IHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZClcbiAgICApO1xuICB9XG5cbiAgLy8gT2ZmZXJpbmcgdGhlIG9wdGlvbiB0byBlaXRoZXIgZ2l2ZSB0aGUgcGFyZW50IG5vZGUgdG8gcmVjdXJzZSBwb3RlbnRpYWxseSBsYXppbHksXG4gIC8vIG9yIGRpcmVjdGx5IHRoZSBsaXN0IG9mIGNoaWxkcmVuIHRvIGRpc3BsYXkuXG4gIEBJbnB1dCgncGFyZW50JykgcGFyZW50OiBUcmVlTm9kZU1vZGVsPFQ+O1xuICBASW5wdXQoJ2NoaWxkcmVuJykgY2hpbGRyZW46IFRyZWVOb2RlTW9kZWw8VD5bXTtcblxuICBnZXRDb250ZXh0KG5vZGU6IFRyZWVOb2RlTW9kZWw8VD4pOiBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQ8VD4ge1xuICAgIHJldHVybiB7XG4gICAgICAkaW1wbGljaXQ6IG5vZGUubW9kZWwsXG4gICAgICBjbHJNb2RlbDogbm9kZSxcbiAgICB9O1xuICB9XG5cbiAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19