/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { AfterContentInit, Component, ContentChildren, ElementRef, HostListener, Input, OnDestroy, QueryList, } from '@angular/core';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNode } from './tree-node';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './recursive-children';

function ClrTree_clr_recursive_children_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-recursive-children", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("children", ctx_r0.featuresService.recursion.root);
} }
const _c0 = ["*"];
let ClrTree = class ClrTree {
    constructor(featuresService, focusManagerService, el) {
        this.featuresService = featuresService;
        this.focusManagerService = focusManagerService;
        this.el = el;
        this.subscriptions = [];
        this.tabindex = 0;
    }
    set lazy(value) {
        this.featuresService.eager = !value;
    }
    get isMultiSelectable() {
        return this.featuresService.selectable && this.rootNodes.length > 0;
    }
    onFocusIn(event) {
        if (event.target === this.el.nativeElement) {
            // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
            // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
            this.focusManagerService.focusFirstVisibleNode();
            // when the first child gets focus,
            // tree should no longer have tabindex of 0;
            delete this.tabindex;
        }
    }
    ngAfterContentInit() {
        this.setRootNodes();
        this.subscriptions.push(this.rootNodes.changes.subscribe(() => {
            this.setRootNodes();
        }));
    }
    setRootNodes() {
        // if node has no parent, it's a root node
        // for recursive tree, this.rootNodes registers also nested children
        // so we have to use filter to extract the ones that are truly root nodes
        this.focusManagerService.rootNodeModels = this.rootNodes.map(node => node._model).filter(node => !node.parent);
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
};
ClrTree.ɵfac = function ClrTree_Factory(t) { return new (t || ClrTree)(ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(TreeFocusManagerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrTree.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTree, selectors: [["clr-tree"]], contentQueries: function ClrTree_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTreeNode, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rootNodes = _t);
    } }, hostVars: 3, hostBindings: function ClrTree_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function ClrTree_focusin_HostBindingHandler($event) { return ctx.onFocusIn($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("role", "tree")("aria-multiselectable", ctx.isMultiSelectable);
    } }, inputs: { lazy: ["clrLazy", "lazy"] }, features: [ɵngcc0.ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, TreeFocusManagerService])], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [[3, "children", 4, "ngIf"], [3, "children"]], template: function ClrTree_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrTree_clr_recursive_children_1_Template, 1, 1, "clr-recursive-children", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.featuresService.recursion);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.RecursiveChildren], encapsulation: 2 });
ClrTree.ctorParameters = () => [
    { type: TreeFeaturesService },
    { type: TreeFocusManagerService },
    { type: ElementRef }
];
__decorate([
    Input('clrLazy')
], ClrTree.prototype, "lazy", null);
__decorate([
    HostListener('focusin', ['$event'])
], ClrTree.prototype, "onFocusIn", null);
__decorate([
    ContentChildren(ClrTreeNode)
], ClrTree.prototype, "rootNodes", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTree, [{
        type: Component,
        args: [{
                selector: 'clr-tree',
                template: `
    <ng-content></ng-content>
    <clr-recursive-children *ngIf="featuresService.recursion"
                            [children]="featuresService.recursion.root"></clr-recursive-children>
  `,
                providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
                host: {
                    '[attr.tabindex]': 'tabindex',
                    '[attr.role]': '"tree"',
                    '[attr.aria-multiselectable]': 'isMultiSelectable'
                }
            }]
    }], function () { return [{ type: TreeFeaturesService }, { type: TreeFocusManagerService }, { type: ɵngcc0.ElementRef }]; }, { lazy: [{
            type: Input,
            args: ['clrLazy']
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin', ['$event']]
        }], rootNodes: [{
            type: ContentChildren,
            args: [ClrTreeNode]
        }] }); })();
export { ClrTree };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZXMiOlsibmc6L0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLFNBQVMsRUFDVCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDdkUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdEYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGFBQWEsQ0FBQzs7Ozs7Ozs7Ozs7O0FBZ0IxQyxJQUFhLE9BQU8sR0FBcEIsTUFBYSxPQUFPO0FBQUcsSUFDckIsWUFDUyxlQUF1QyxFQUN0QyxtQkFBK0MsRUFDL0MsRUFBYztBQUN2QixRQUhRLG9CQUFlLEdBQWYsZUFBZSxDQUF3QjtBQUFDLFFBQ3ZDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBNEI7QUFBQyxRQUNoRCxPQUFFLEdBQUYsRUFBRSxDQUFZO0FBQzFCLFFBRVUsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO0FBQzdDLFFBTUUsYUFBUSxHQUFHLENBQUMsQ0FBQztBQUNmLElBVkssQ0FBQztBQUNOLElBSUUsSUFBSSxJQUFJLENBQUMsS0FBYztBQUN6QixRQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ3hDLElBQUUsQ0FBQztBQUNILElBR0UsSUFBSSxpQkFBaUI7QUFDdkIsUUFBSSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN4RSxJQUFFLENBQUM7QUFDSCxJQUVFLFNBQVMsQ0FBQyxLQUFpQjtBQUM3QixRQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRTtBQUNoRCxZQUFNLDZIQUE2SDtBQUNuSSxZQUFNLHFIQUFxSDtBQUMzSCxZQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0FBQ3ZELFlBQ00sbUNBQW1DO0FBQ3pDLFlBQU0sNENBQTRDO0FBQ2xELFlBQU0sT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQzNCLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUdFLGtCQUFrQjtBQUNwQixRQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUN4QixRQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO0FBQzVDLFlBQVEsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQzVCLFFBQU0sQ0FBQyxDQUFDLENBQ0gsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILElBQ1UsWUFBWTtBQUFLLFFBQ3ZCLDBDQUEwQztBQUM5QyxRQUFJLG9FQUFvRTtBQUN4RSxRQUFJLHlFQUF5RTtBQUM3RSxRQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbkgsSUFBRSxDQUFDO0FBQ0gsSUFDRSxXQUFXO0FBQ2IsUUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQ3pELElBQUUsQ0FBQztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztrRkFBQTtBQUNEO0FBQWlDLFlBckRMLG1CQUFtQjtBQUFJLFlBQ2xCLHVCQUF1QjtBQUFJLFlBQzVDLFVBQVU7QUFDeEI7QUFLQTtBQUFhLElBRFosS0FBSyxDQUFDLFNBQVMsQ0FBQztBQUNuQixtQ0FFRztBQVNEO0FBQWEsSUFEWixZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdEMsd0NBVUc7QUFFNkI7QUFBYSxJQUExQyxlQUFlLENBQUMsV0FBVyxDQUFDO0FBQUMsMENBQTZDO0FBakNoRSxPQUFPLG9CQWRuQixTQUFTLENBQUMsVUFDVCxRQUFRLEVBQUU7Q0FBVSxVQUNwQixRQUFRLEVBQUU7Ozs7OztnQkFJVCxVQUNELFNBQVMsRUFBRSxDQUFDLHNCQUFzQixFQUFFLHVCQUF1QixDQUFDLFVBQzVEO0VBQUksRUFBRTthQUNKLGlCQUFpQixFQUFFLFVBQVUsY0FDN0IsYUFBYSxFQUFFO0NBQVEsY0FDdkI7b0JBQTZCLEVBQUUsbUJBQW1CO0NBQ25ELE1BQ0YsQ0FBQyxJQUNXLE9BQU8sQ0FzRG5COzs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsU0F2RFksT0FBTztBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vdHJlZS1mb2N1cy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSwgVFJFRV9GRUFUVVJFU19QUk9WSURFUiB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRyZWVOb2RlIH0gZnJvbSAnLi90cmVlLW5vZGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdHJlZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxjbHItcmVjdXJzaXZlLWNoaWxkcmVuICpuZ0lmPVwiZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NoaWxkcmVuXT1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24ucm9vdFwiPjwvY2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbj5cbiAgYCxcbiAgcHJvdmlkZXJzOiBbVFJFRV9GRUFUVVJFU19QUk9WSURFUiwgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJpbmRleCcsXG4gICAgJ1thdHRyLnJvbGVdJzogJ1widHJlZVwiJyxcbiAgICAnW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdJzogJ2lzTXVsdGlTZWxlY3RhYmxlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBmb2N1c01hbmFnZXJTZXJ2aWNlOiBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmXG4gICkge31cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJMYXp5JylcbiAgc2V0IGxhenkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciA9ICF2YWx1ZTtcbiAgfVxuXG4gIHRhYmluZGV4ID0gMDtcblxuICBnZXQgaXNNdWx0aVNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgJiYgdGhpcy5yb290Tm9kZXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IEZvY3VzRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgIC8vIEFmdGVyIGRpc2N1c3Npbmcgd2l0aCB0aGUgdGVhbSwgSSd2ZSBtYWRlIGl0IHNvIHRoYXQgd2hlbiB0aGUgdHJlZSByZWNlaXZlcyBmb2N1cywgdGhlIGZpcnN0IHZpc2libGUgbm9kZSB3aWxsIGJlIGZvY3VzZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmcm9tIHRoZSBwYWdlIHNjcm9sbGluZyBhYnJ1cHRseSB0byB0aGUgZmlyc3Qgc2VsZWN0ZWQgbm9kZSBpZiBpdCBleGlzdCBpbiBhIGRlZXBseSBuZXN0ZWQgdHJlZS5cbiAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcblxuICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgY2hpbGQgZ2V0cyBmb2N1cyxcbiAgICAgIC8vIHRyZWUgc2hvdWxkIG5vIGxvbmdlciBoYXZlIHRhYmluZGV4IG9mIDA7XG4gICAgICBkZWxldGUgdGhpcy50YWJpbmRleDtcbiAgICB9XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKENsclRyZWVOb2RlKSBwcml2YXRlIHJvb3ROb2RlczogUXVlcnlMaXN0PENsclRyZWVOb2RlPFQ+PjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucm9vdE5vZGVzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Um9vdE5vZGVzKCk6IHZvaWQge1xuICAgIC8vIGlmIG5vZGUgaGFzIG5vIHBhcmVudCwgaXQncyBhIHJvb3Qgbm9kZVxuICAgIC8vIGZvciByZWN1cnNpdmUgdHJlZSwgdGhpcy5yb290Tm9kZXMgcmVnaXN0ZXJzIGFsc28gbmVzdGVkIGNoaWxkcmVuXG4gICAgLy8gc28gd2UgaGF2ZSB0byB1c2UgZmlsdGVyIHRvIGV4dHJhY3QgdGhlIG9uZXMgdGhhdCBhcmUgdHJ1bHkgcm9vdCBub2Rlc1xuICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5yb290Tm9kZU1vZGVscyA9IHRoaXMucm9vdE5vZGVzLm1hcChub2RlID0+IG5vZGUuX21vZGVsKS5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIl19