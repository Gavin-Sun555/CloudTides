/**
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { Component, Input, Optional, Renderer2 } from '@angular/core';
import { IfErrorService } from '../common/if-error/if-error.service';
import { NgControlService } from '../common/providers/ng-control.service';
import { LayoutService } from '../common/providers/layout.service';
import { ControlIdService } from '../common/providers/control-id.service';
import { ControlClassService } from '../common/providers/control-class.service';
import { ClrAbstractContainer } from '../common/abstract-container';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/label';
import * as ɵngcc3 from '../../icon/icon';

function ClrRangeContainer_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
function ClrRangeContainer_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r1.getRangeProgressFillWidth());
} }
function ClrRangeContainer_clr_icon_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-icon", 6);
} }
function ClrRangeContainer_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!invalid"]);
} }
function ClrRangeContainer_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "invalid"]);
} }
const _c0 = [[["label"]], [["", "clrRange", ""]], [["clr-control-helper"]], [["clr-control-error"]]];
const _c1 = ["label", "[clrRange]", "clr-control-helper", "clr-control-error"];
let ClrRangeContainer = class ClrRangeContainer extends ClrAbstractContainer {
    constructor(ifErrorService, layoutService, controlClassService, ngControlService, renderer, idService) {
        super(ifErrorService, layoutService, controlClassService, ngControlService);
        this.renderer = renderer;
        this.idService = idService;
        this._hasProgress = false;
    }
    set hasProgress(val) {
        const valBool = !!val;
        if (valBool !== this._hasProgress) {
            this._hasProgress = valBool;
        }
    }
    get hasProgress() {
        return this._hasProgress;
    }
    getRangeProgressFillWidth() {
        const input = this.renderer.selectRootElement('[clrRange]#' + this.idService.id);
        const inputWidth = input.offsetWidth;
        const inputMinValue = +input.min;
        let inputMaxValue = +input.max;
        if (inputMinValue === 0 && inputMaxValue === 0) {
            inputMaxValue = 100;
        }
        const inputMiddle = (inputMinValue + inputMaxValue) / 2;
        const inputValue = !!this.control && this.control.value !== undefined ? this.control.value : inputMiddle;
        const valueAsPercent = (inputValue - inputMinValue) * 100 / (inputMaxValue - inputMinValue);
        return valueAsPercent * inputWidth / 100 + 'px';
    }
};
ClrRangeContainer.ɵfac = function ClrRangeContainer_Factory(t) { return new (t || ClrRangeContainer)(ɵngcc0.ɵɵdirectiveInject(IfErrorService), ɵngcc0.ɵɵdirectiveInject(LayoutService, 8), ɵngcc0.ɵɵdirectiveInject(ControlClassService), ɵngcc0.ɵɵdirectiveInject(NgControlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ControlIdService)); };
ClrRangeContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrRangeContainer, selectors: [["clr-range-container"]], hostVars: 6, hostBindings: function ClrRangeContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    } }, inputs: { hasProgress: ["clrRangeHasProgress", "hasProgress"] }, features: [ɵngcc0.ɵɵProvidersFeature([IfErrorService, NgControlService, ControlIdService, ControlClassService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 9, vars: 8, consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-range-wrapper"], ["class", "fill-input", 3, "width", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "aria-hidden", "true", 4, "ngIf"], [1, "fill-input"], ["shape", "exclamation-circle", "aria-hidden", "true", 1, "clr-validate-icon"]], template: function ClrRangeContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrRangeContainer_label_1_Template, 1, 0, "label", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, ClrRangeContainer_span_5_Template, 1, 2, "span", 3);
        ɵngcc0.ɵɵtemplate(6, ClrRangeContainer_clr_icon_6_Template, 1, 0, "clr-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ClrRangeContainer_7_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(8, ClrRangeContainer_8_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.controlClass());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("progress-fill", ctx.hasProgress);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasProgress);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc2.ClrLabel, ɵngcc3.ClrIconCustomTag], encapsulation: 2 });
ClrRangeContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService },
    { type: Renderer2 },
    { type: ControlIdService }
];
__decorate([
    Input('clrRangeHasProgress')
], ClrRangeContainer.prototype, "hasProgress", null);
ClrRangeContainer = __decorate([ __param(1, Optional())
], ClrRangeContainer);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRangeContainer, [{
        type: Component,
        args: [{
                selector: 'clr-range-container',
                template: `
        <ng-content select="label"></ng-content>
        <label *ngIf="!label && addGrid()"></label>
        <div class="clr-control-container" [ngClass]="controlClass()">
            <div class="clr-range-wrapper" [class.progress-fill]="hasProgress">
                <ng-content select="[clrRange]"></ng-content>
                <span
                  *ngIf="hasProgress"
                  class="fill-input"
                  [style.width]="getRangeProgressFillWidth()"
                ></span>
                <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
            </div>
            <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
            <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
        </div>
    `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()'
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }]
    }], function () { return [{ type: IfErrorService }, { type: LayoutService, decorators: [{
                type: Optional
            }] }, { type: ControlClassService }, { type: NgControlService }, { type: ɵngcc0.Renderer2 }, { type: ControlIdService }]; }, { hasProgress: [{
            type: Input,
            args: ['clrRangeHasProgress']
        }] }); })();
export { ClrRangeContainer };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UtY29udGFpbmVyLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2Zvcm1zL3JhbmdlL3JhbmdlLWNvbnRhaW5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUNuRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUMxRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUNoRixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QnBFLElBQWEsaUJBQWlCLEdBQTlCLE1BQWEsaUJBQWtCLFNBQVEsb0JBQW9CO0FBQzNELElBY0UsWUFDRSxjQUE4QixFQUNsQixhQUE0QixFQUN4QyxtQkFBd0MsRUFDeEMsZ0JBQWtDLEVBQzFCLFFBQW1CLEVBQ25CLFNBQTJCO0FBQ3BDLFFBQ0MsS0FBSyxDQUFDLGNBQWMsRUFBRSxhQUFhLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztBQUNoRixRQUpZLGFBQVEsR0FBUixRQUFRLENBQVc7QUFBQyxRQUNwQixjQUFTLEdBQVQsU0FBUyxDQUFrQjtBQUN2QyxRQXJCVSxpQkFBWSxHQUFZLEtBQUssQ0FBQztBQUN4QyxJQXNCRSxDQUFDO0FBQ0gsSUFyQkUsSUFBSSxXQUFXLENBQUMsR0FBWTtBQUM5QixRQUFJLE1BQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDMUIsUUFBSSxJQUFJLE9BQU8sS0FBSyxJQUFJLENBQUMsWUFBWSxFQUFFO0FBQ3ZDLFlBQU0sSUFBSSxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUM7QUFDbEMsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ0UsSUFBSSxXQUFXO0FBQ2pCLFFBQUksT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQzdCLElBQUUsQ0FBQztBQUNILElBWUUseUJBQXlCO0FBQUssUUFDNUIsTUFBTSxLQUFLLEdBQXFCLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdkcsUUFDSSxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO0FBQ3pDLFFBQUksTUFBTSxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO0FBQ3JDLFFBQUksSUFBSSxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO0FBQ25DLFFBQ0ksSUFBSSxhQUFhLEtBQUssQ0FBQyxJQUFJLGFBQWEsS0FBSyxDQUFDLEVBQUU7QUFDcEQsWUFBTSxhQUFhLEdBQUcsR0FBRyxDQUFDO0FBQzFCLFNBQUs7QUFDTCxRQUNJLE1BQU0sV0FBVyxHQUFHLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1RCxRQUFJLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztBQUM3RyxRQUFJLE1BQU0sY0FBYyxHQUFHLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUMsQ0FBQztBQUNoRyxRQUNJLE9BQU8sY0FBYyxHQUFHLFVBQVUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ3BELElBQUUsQ0FBQztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tIQUFBO0FBQ0Q7QUFBMkMsWUE1QnZCLGNBQWM7QUFDaEMsWUFBNkIsYUFBYSx1QkFBdkMsUUFBUTtBQUFPLFlBQ0ssbUJBQW1CO0FBQzFDLFlBQW9CLGdCQUFnQjtBQUNwQyxZQUFvQixTQUFTO0FBQzdCLFlBQXFCLGdCQUFnQjtBQUNyQztBQWxCQTtBQUFhLElBRFosS0FBSyxDQUFDLHFCQUFxQixDQUFDO0FBQy9CLG9EQUtHO0FBVFUsaUJBQWlCLG9CQTFCN0IsU0FBUyxDQUFDLGZBMEJQLENBaUJDLFdBQUEsUUFBUSxFQUFFLENBQUE7Q0ExQ2IsUUFBUSxFQUFFLFhBMENJLEdBakJILGlCQUFpQixDQTJDN0I7U0FwRWdDLFVBQy9CLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBZ0JQLFVBQ0gsSUFBSSxFQUFFLGNBQ0osMEJBQTBCLEVBQUU7Q0FBTSxjQUNsQyxtQ0FBbUMsRUFBRSxtQkFBbUI7SUFDeEQ7TUFBaUI7Q0FBRSxXQUFXLFdBQy9CO1NBQ0QsU0FBUyxFQUFFLENBQUMsY0FBYyxFQUFFLGdCQUFnQixFQUFFO2VBQWdCLEVBQUUsbUJBQW1CLENBQUMsTUFDckYsQ0FBQzs7Ozs7Ozs7OztvQkE2Q0Y7QUFBQyxTQTVDWSxpQkFBaUI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjAgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9wdGlvbmFsLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBDbHJBYnN0cmFjdENvbnRhaW5lciB9IGZyb20gJy4uL2NvbW1vbi9hYnN0cmFjdC1jb250YWluZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFuZ2UtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItcmFuZ2Utd3JhcHBlclwiIFtjbGFzcy5wcm9ncmVzcy1maWxsXT1cImhhc1Byb2dyZXNzXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclJhbmdlXVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNQcm9ncmVzc1wiXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImZpbGwtaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoXT1cImdldFJhbmdlUHJvZ3Jlc3NGaWxsV2lkdGgoKVwiXG4gICAgICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmRXJyb3JTZXJ2aWNlLCBOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sSWRTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUmFuZ2VDb250YWluZXIgZXh0ZW5kcyBDbHJBYnN0cmFjdENvbnRhaW5lciB7XG4gIHByaXZhdGUgX2hhc1Byb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQElucHV0KCdjbHJSYW5nZUhhc1Byb2dyZXNzJylcbiAgc2V0IGhhc1Byb2dyZXNzKHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5faGFzUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuX2hhc1Byb2dyZXNzID0gdmFsQm9vbDtcbiAgICB9XG4gIH1cblxuICBnZXQgaGFzUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1Byb2dyZXNzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGlkU2VydmljZTogQ29udHJvbElkU2VydmljZVxuICApIHtcbiAgICBzdXBlcihpZkVycm9yU2VydmljZSwgbGF5b3V0U2VydmljZSwgY29udHJvbENsYXNzU2VydmljZSwgbmdDb250cm9sU2VydmljZSk7XG4gIH1cblxuICBnZXRSYW5nZVByb2dyZXNzRmlsbFdpZHRoKCk6IHN0cmluZyB7XG4gICAgY29uc3QgaW5wdXQgPSA8SFRNTElucHV0RWxlbWVudD50aGlzLnJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KCdbY2xyUmFuZ2VdIycgKyB0aGlzLmlkU2VydmljZS5pZCk7XG5cbiAgICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGg7XG4gICAgY29uc3QgaW5wdXRNaW5WYWx1ZSA9ICtpbnB1dC5taW47XG4gICAgbGV0IGlucHV0TWF4VmFsdWUgPSAraW5wdXQubWF4O1xuXG4gICAgaWYgKGlucHV0TWluVmFsdWUgPT09IDAgJiYgaW5wdXRNYXhWYWx1ZSA9PT0gMCkge1xuICAgICAgaW5wdXRNYXhWYWx1ZSA9IDEwMDtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dE1pZGRsZSA9IChpbnB1dE1pblZhbHVlICsgaW5wdXRNYXhWYWx1ZSkgLyAyO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSAhIXRoaXMuY29udHJvbCAmJiB0aGlzLmNvbnRyb2wudmFsdWUgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29udHJvbC52YWx1ZSA6IGlucHV0TWlkZGxlO1xuICAgIGNvbnN0IHZhbHVlQXNQZXJjZW50ID0gKGlucHV0VmFsdWUgLSBpbnB1dE1pblZhbHVlKSAqIDEwMCAvIChpbnB1dE1heFZhbHVlIC0gaW5wdXRNaW5WYWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWVBc1BlcmNlbnQgKiBpbnB1dFdpZHRoIC8gMTAwICsgJ3B4JztcbiAgfVxufVxuIl19