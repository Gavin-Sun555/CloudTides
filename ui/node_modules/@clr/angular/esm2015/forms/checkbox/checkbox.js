/**
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { Directive, Renderer2, ElementRef, Injector, Self, Optional, ViewContainerRef, Attribute } from '@angular/core';
import { NgControl } from '@angular/forms';
import { ClrCheckboxWrapper, IS_TOGGLE } from './checkbox-wrapper';
import { WrappedFormControl } from '../common/wrapped-control';
/**
 * This implements both the clrCheckbox and clrToggle functionality, since they are both just checkboxes with different
 * visual styling. The challenge is that the container needs to know which selector was used, which the @Attribute
 * decorator gets for us to determine if the toggle is used, and emits a value to the wrapper container to tell it
 * there is a toggle switch instead.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
let ClrCheckbox = class ClrCheckbox extends WrappedFormControl {
    constructor(vcr, injector, control, renderer, el, toggle) {
        super(vcr, ClrCheckboxWrapper, injector, control, renderer, el);
        this.toggle = toggle;
    }
    ngOnInit() {
        super.ngOnInit();
        const toggleService = this.getProviderFromContainer(IS_TOGGLE, null);
        if (toggleService && this.toggle !== null) {
            toggleService.next(true);
        }
    }
};
ClrCheckbox.ɵfac = function ClrCheckbox_Factory(t) { return new (t || ClrCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('clrToggle')); };
ClrCheckbox.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrCheckbox, selectors: [["", "clrCheckbox", ""], ["", "clrToggle", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
ClrCheckbox.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: String, decorators: [{ type: Attribute, args: ['clrToggle',] }] }
];
ClrCheckbox = __decorate([ __param(2, Self()),
    __param(2, Optional()),
    __param(5, Attribute('clrToggle'))
], ClrCheckbox);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCheckbox, [{
        type: Directive,
        args: [{ selector: '[clrCheckbox],[clrToggle]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc1.NgControl, decorators: [{
                type: Self
            }, {
                type: Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Attribute,
                args: ['clrToggle']
            }] }]; }, null); })();
export { ClrCheckbox };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3guanMiLCJzb3VyY2VzIjpbIm5nOi9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hILE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUczQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbkUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUVILElBQWEsV0FBVyxHQUF4QixNQUFhLFdBQVksU0FBUSxrQkFBc0M7QUFDdkUsSUFBRSxZQUNFLEdBQXFCLEVBQ3JCLFFBQWtCLEVBR2xCLE9BQWtCLEVBQ2xCLFFBQW1CLEVBQ25CLEVBQWMsRUFDa0IsTUFBYztBQUMvQyxRQUNDLEtBQUssQ0FBQyxHQUFHLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDcEUsUUFIb0MsV0FBTSxHQUFOLE1BQU0sQ0FBUTtBQUNsRCxJQUVFLENBQUM7QUFDSCxJQUNFLFFBQVE7QUFDVixRQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNyQixRQUNJLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBMkIsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25HLFFBQ0ksSUFBSSxhQUFhLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7QUFDL0MsWUFBTSxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9CLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxDQUFDOzsrS0FBQTtBQUNEO0FBQXFDLFlBdEI1QixnQkFBZ0I7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCLFlBRVcsU0FBUyx1QkFGakIsSUFBSSxZQUNKLFFBQVE7QUFDVCxZQUNVLFNBQVM7QUFDckIsWUFBTSxVQUFVO0FBQ2hCLHlDQUFHLFNBQVMsU0FBQyxXQUFXO0FBQVE7QUFUckIsV0FBVyxvQkFEdkIsU0FBUyxDQUFDLEVBQUUsakJBQ1QsQ0FJQyxXQUFBLElBQUksRUFBRSxDQUFBO0lBTFUsRUFBRSxOQU10QixJQUFJLFdBQUEsUUFBUSxFQUFFLENBQUE7S0FObUMsRUFBRSxDQUFDLFJBT3BELElBR0ksV0FBQSxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUE7QUFBQyxHQVRmLFdBQVcsQ0F1QnZCOzs7Ozs7Ozs7OztrQ0FDRDtBQUFDLFNBeEJZLFdBQVc7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgUmVuZGVyZXIyLCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2VsZiwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYsIEF0dHJpYnV0ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckNoZWNrYm94V3JhcHBlciwgSVNfVE9HR0xFIH0gZnJvbSAnLi9jaGVja2JveC13cmFwcGVyJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuXG4vKipcbiAqIFRoaXMgaW1wbGVtZW50cyBib3RoIHRoZSBjbHJDaGVja2JveCBhbmQgY2xyVG9nZ2xlIGZ1bmN0aW9uYWxpdHksIHNpbmNlIHRoZXkgYXJlIGJvdGgganVzdCBjaGVja2JveGVzIHdpdGggZGlmZmVyZW50XG4gKiB2aXN1YWwgc3R5bGluZy4gVGhlIGNoYWxsZW5nZSBpcyB0aGF0IHRoZSBjb250YWluZXIgbmVlZHMgdG8ga25vdyB3aGljaCBzZWxlY3RvciB3YXMgdXNlZCwgd2hpY2ggdGhlIEBBdHRyaWJ1dGVcbiAqIGRlY29yYXRvciBnZXRzIGZvciB1cyB0byBkZXRlcm1pbmUgaWYgdGhlIHRvZ2dsZSBpcyB1c2VkLCBhbmQgZW1pdHMgYSB2YWx1ZSB0byB0aGUgd3JhcHBlciBjb250YWluZXIgdG8gdGVsbCBpdFxuICogdGhlcmUgaXMgYSB0b2dnbGUgc3dpdGNoIGluc3RlYWQuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJDaGVja2JveF0sW2NsclRvZ2dsZV0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3ggZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyQ2hlY2tib3hXcmFwcGVyPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgY29udHJvbDogTmdDb250cm9sLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgZWw6IEVsZW1lbnRSZWYsXG4gICAgQEF0dHJpYnV0ZSgnY2xyVG9nZ2xlJykgcHJpdmF0ZSB0b2dnbGU6IHN0cmluZ1xuICApIHtcbiAgICBzdXBlcih2Y3IsIENsckNoZWNrYm94V3JhcHBlciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgY29uc3QgdG9nZ2xlU2VydmljZSA9IHRoaXMuZ2V0UHJvdmlkZXJGcm9tQ29udGFpbmVyPEJlaGF2aW9yU3ViamVjdDxib29sZWFuPj4oSVNfVE9HR0xFLCBudWxsKTtcblxuICAgIGlmICh0b2dnbGVTZXJ2aWNlICYmIHRoaXMudG9nZ2xlICE9PSBudWxsKSB7XG4gICAgICB0b2dnbGVTZXJ2aWNlLm5leHQodHJ1ZSk7XG4gICAgfVxuICB9XG59XG4iXX0=