/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { ChangeDetectorRef, Directive, Input, OnChanges, OnDestroy, TemplateRef } from '@angular/core';
import { TreeFeaturesService } from './tree-features.service';
import { RecursiveTreeNodeModel } from './models/recursive-tree-node.model';
import { debounceTime } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
var ClrRecursiveForOf = /** @class */ (function () {
    function ClrRecursiveForOf(template, featuresService, cdr) {
        this.template = template;
        this.featuresService = featuresService;
        this.cdr = cdr;
    }
    // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
    ClrRecursiveForOf.prototype.ngOnChanges = function () {
        var _this = this;
        var wrapped;
        if (Array.isArray(this.nodes)) {
            wrapped = this.nodes.map(function (node) { return new RecursiveTreeNodeModel(node, null, _this.getChildren, _this.featuresService); });
        }
        else {
            wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren, this.featuresService)];
        }
        if (!this.childrenFetchSubscription) {
            this.childrenFetchSubscription = this.featuresService.childrenFetched.pipe(debounceTime(0)).subscribe(function () {
                _this.cdr.detectChanges();
            });
        }
        this.featuresService.recursion = {
            template: this.template,
            root: wrapped,
        };
    };
    ClrRecursiveForOf.prototype.ngOnDestroy = function () {
        if (this.childrenFetchSubscription) {
            this.childrenFetchSubscription.unsubscribe();
        }
    };
    ClrRecursiveForOf.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: TreeFeaturesService },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        Input('clrRecursiveForOf')
    ], ClrRecursiveForOf.prototype, "nodes", void 0);
    __decorate([
        Input('clrRecursiveForGetChildren')
    ], ClrRecursiveForOf.prototype, "getChildren", void 0);
ClrRecursiveForOf.ɵfac = function ClrRecursiveForOf_Factory(t) { return new (t || ClrRecursiveForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ClrRecursiveForOf.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrRecursiveForOf, selectors: [["", "clrRecursiveFor", "", "clrRecursiveForOf", ""]], inputs: { nodes: ["clrRecursiveForOf", "nodes"], getChildren: ["clrRecursiveForGetChildren", "getChildren"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrRecursiveForOf, [{
        type: Directive,
        args: [{ selector: '[clrRecursiveFor][clrRecursiveForOf]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: TreeFeaturesService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { nodes: [{
            type: Input,
            args: ['clrRecursiveForOf']
        }], getChildren: [{
            type: Input,
            args: ['clrRecursiveForGetChildren']
        }] }); })();
    return ClrRecursiveForOf;
}());
export { ClrRecursiveForOf };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlLWZvci1vZi5qcyIsInNvdXJjZXMiOlsibmc6L0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9yZWN1cnNpdmUtZm9yLW9mLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkcsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFJNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQVE5QztBQUFxRCxJQUNuRCwyQkFDVSxRQUFrRCxFQUNsRCxlQUF1QyxFQUN2QyxHQUFzQjtBQUMvQixRQUhTLGFBQVEsR0FBUixRQUFRLENBQTBDO0FBQUMsUUFDbkQsb0JBQWUsR0FBZixlQUFlLENBQXdCO0FBQUMsUUFDeEMsUUFBRyxHQUFILEdBQUcsQ0FBbUI7QUFDbEMsSUFBSyxDQUFDO0FBQ04sSUFTRSwrR0FBK0c7QUFDakgsSUFBRSx1Q0FBVyxHQUFYO0FBQWMsUUFBZCxpQkFpQkM7QUFDSCxRQWpCSSxJQUFJLE9BQW9DLENBQUM7QUFDN0MsUUFBSSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ25DLFlBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsSUFBSSxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSSxDQUFDLGVBQWUsQ0FBQyxFQUE5RSxDQUE4RSxDQUFDLENBQUM7QUFDdkgsU0FBSztBQUFDLGFBQUs7QUFDWCxZQUFNLE9BQU8sR0FBRyxDQUFDLElBQUksc0JBQXNCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztBQUN2RyxTQUFLO0FBQ0wsUUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUF5QixFQUFFO0FBQ3pDLFlBQU0sSUFBSSxDQUFDLHlCQUF5QixHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDdEcsZ0JBQUUsS0FBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUNqQyxZQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ1QsU0FBSztBQUNMLFFBQ0ksSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEdBQUc7QUFDckMsWUFBTSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7QUFDN0IsWUFBTSxJQUFJLEVBQUUsT0FBTztBQUNuQixTQUFLLENBQUM7QUFDTixJQUFFLENBQUM7QUFFSCxJQUFFLHVDQUFXLEdBQVg7QUFBYyxRQUNaLElBQUksSUFBSSxDQUFDLHlCQUF5QixFQUFFO0FBQ3hDLFlBQU0sSUFBSSxDQUFDLHlCQUF5QixDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ25ELFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDRjtBQUM0RCxnQkF2Q3ZDLFdBQVc7QUFBSSxnQkFDUixtQkFBbUI7QUFBSSxnQkFDbkMsaUJBQWlCO0FBQ2hDO0FBRUUsSUFDMEI7QUFBYSxRQUF4QyxLQUFLLENBQUMsbUJBQW1CLENBQUM7QUFBQyxvREFBZTtBQUU3QyxJQUN1QztBQUFhLFFBQWpELEtBQUssQ0FBQyw0QkFBNEIsQ0FBQztBQUFDLDBEQUF3QztJQVhsRSxpQkFBaUIsd0JBRDdCLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxzQ0FBc0MsRUFBRSxDQUFDLFFBQ25ELGlCQUFpQixDQXdDN0I7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCx3QkFBQztBQUNBLENBREEsQUF4Q0QsSUF3Q0M7QUFDRCxTQXpDYSxpQkFBaUI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy9yZWN1cnNpdmUtdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IFRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy90cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQXN5bmNBcnJheSB9IGZyb20gJy4vbW9kZWxzL2FzeW5jLWFycmF5JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPiB7XG4gICRpbXBsaWNpdDogVDtcbiAgY2xyTW9kZWw6IFRyZWVOb2RlTW9kZWw8VD47XG59XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJSZWN1cnNpdmVGb3JdW2NsclJlY3Vyc2l2ZUZvck9mXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJSZWN1cnNpdmVGb3JPZjxUPiBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8Q2xyUmVjdXJzaXZlRm9yT2ZDb250ZXh0PFQ+PixcbiAgICBwcml2YXRlIGZlYXR1cmVzU2VydmljZTogVHJlZUZlYXR1cmVzU2VydmljZTxUPixcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7fVxuXG4gIC8vIFRPRE86IGFjY2VwdCBOZ0l0ZXJhYmxlPFQ+XG4gIEBJbnB1dCgnY2xyUmVjdXJzaXZlRm9yT2YnKSBub2RlczogVCB8IFRbXTtcblxuICAvLyBUT0RPOiBhY2NlcHQgTmdJdGVyYWJsZTxUPiByZXR1cm4gdHlwZVxuICBASW5wdXQoJ2NsclJlY3Vyc2l2ZUZvckdldENoaWxkcmVuJykgZ2V0Q2hpbGRyZW46IChub2RlOiBUKSA9PiBBc3luY0FycmF5PFQ+O1xuXG4gIHByaXZhdGUgY2hpbGRyZW5GZXRjaFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8vIEknbSB1c2luZyBPbkNoYW5nZXMgaW5zdGVhZCBvZiBPbkluaXQgdG8gZWFzaWx5IGtlZXAgdXAgdG8gZGF0ZSB3aXRoIGR5bmFtaWMgdHJlZXMuIE1heWJlIG9wdGltaXphYmxlIGxhdGVyLlxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBsZXQgd3JhcHBlZDogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubm9kZXMpKSB7XG4gICAgICB3cmFwcGVkID0gdGhpcy5ub2Rlcy5tYXAobm9kZSA9PiBuZXcgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbChub2RlLCBudWxsLCB0aGlzLmdldENoaWxkcmVuLCB0aGlzLmZlYXR1cmVzU2VydmljZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVkID0gW25ldyBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsKHRoaXMubm9kZXMsIG51bGwsIHRoaXMuZ2V0Q2hpbGRyZW4sIHRoaXMuZmVhdHVyZXNTZXJ2aWNlKV07XG4gICAgfVxuICAgIGlmICghdGhpcy5jaGlsZHJlbkZldGNoU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuRmV0Y2hTdWJzY3JpcHRpb24gPSB0aGlzLmZlYXR1cmVzU2VydmljZS5jaGlsZHJlbkZldGNoZWQucGlwZShkZWJvdW5jZVRpbWUoMCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbiA9IHtcbiAgICAgIHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICAgICAgcm9vdDogd3JhcHBlZCxcbiAgICB9O1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5GZXRjaFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jaGlsZHJlbkZldGNoU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iXX0=