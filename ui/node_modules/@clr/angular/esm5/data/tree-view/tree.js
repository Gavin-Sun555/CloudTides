/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { AfterContentInit, Component, ContentChildren, ElementRef, HostListener, Input, OnDestroy, QueryList, } from '@angular/core';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNode } from './tree-node';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './recursive-children';

function ClrTree_clr_recursive_children_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-recursive-children", 1);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("children", ctx_r0.featuresService.recursion.root);
} }
var _c0 = ["*"];
var ClrTree = /** @class */ (function () {
    function ClrTree(featuresService, focusManagerService, el) {
        this.featuresService = featuresService;
        this.focusManagerService = focusManagerService;
        this.el = el;
        this.subscriptions = [];
        this.tabindex = 0;
    }
    Object.defineProperty(ClrTree.prototype, "lazy", {
        set: function (value) {
            this.featuresService.eager = !value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTree.prototype, "isMultiSelectable", {
        get: function () {
            return this.featuresService.selectable && this.rootNodes.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    ClrTree.prototype.onFocusIn = function (event) {
        if (event.target === this.el.nativeElement) {
            // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
            // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
            this.focusManagerService.focusFirstVisibleNode();
            // when the first child gets focus,
            // tree should no longer have tabindex of 0;
            delete this.tabindex;
        }
    };
    ClrTree.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.setRootNodes();
        this.subscriptions.push(this.rootNodes.changes.subscribe(function () {
            _this.setRootNodes();
        }));
    };
    ClrTree.prototype.setRootNodes = function () {
        // if node has no parent, it's a root node
        // for recursive tree, this.rootNodes registers also nested children
        // so we have to use filter to extract the ones that are truly root nodes
        this.focusManagerService.rootNodeModels = this.rootNodes.map(function (node) { return node._model; }).filter(function (node) { return !node.parent; });
    };
    ClrTree.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrTree.ctorParameters = function () { return [
        { type: TreeFeaturesService },
        { type: TreeFocusManagerService },
        { type: ElementRef }
    ]; };
    __decorate([
        Input('clrLazy')
    ], ClrTree.prototype, "lazy", null);
    __decorate([
        HostListener('focusin', ['$event'])
    ], ClrTree.prototype, "onFocusIn", null);
    __decorate([
        ContentChildren(ClrTreeNode)
    ], ClrTree.prototype, "rootNodes", void 0);
ClrTree.ɵfac = function ClrTree_Factory(t) { return new (t || ClrTree)(ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(TreeFocusManagerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ClrTree.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTree, selectors: [["clr-tree"]], contentQueries: function ClrTree_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTreeNode, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rootNodes = _t);
    } }, hostVars: 3, hostBindings: function ClrTree_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function ClrTree_focusin_HostBindingHandler($event) { return ctx.onFocusIn($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("role", "tree")("aria-multiselectable", ctx.isMultiSelectable);
    } }, inputs: { lazy: ["clrLazy", "lazy"] }, features: [ɵngcc0.ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, TreeFocusManagerService])], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [[3, "children", 4, "ngIf"], [3, "children"]], template: function ClrTree_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ClrTree_clr_recursive_children_1_Template, 1, 1, "clr-recursive-children", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.featuresService.recursion);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.RecursiveChildren], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrTree, [{
        type: Component,
        args: [{
                selector: 'clr-tree',
                template: "\n    <ng-content></ng-content>\n    <clr-recursive-children *ngIf=\"featuresService.recursion\"\n                            [children]=\"featuresService.recursion.root\"></clr-recursive-children>\n  ",
                providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
                host: {
                    '[attr.tabindex]': 'tabindex',
                    '[attr.role]': '"tree"',
                    '[attr.aria-multiselectable]': 'isMultiSelectable'
                }
            }]
    }], function () { return [{ type: TreeFeaturesService }, { type: TreeFocusManagerService }, { type: ɵngcc0.ElementRef }]; }, { lazy: [{
            type: Input,
            args: ['clrLazy']
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin', ['$event']]
        }], rootNodes: [{
            type: ContentChildren,
            args: [ClrTreeNode]
        }] }); })();
    return ClrTree;
}());
export { ClrTree };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZXMiOlsibmc6L0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLFNBQVMsRUFDVCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDdkUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdEYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGFBQWEsQ0FBQzs7Ozs7Ozs7Ozs7O0FBZ0IxQztBQUEyQyxJQUN6QyxpQkFDUyxlQUF1QyxFQUN0QyxtQkFBK0MsRUFDL0MsRUFBYztBQUN2QixRQUhRLG9CQUFlLEdBQWYsZUFBZSxDQUF3QjtBQUFDLFFBQ3ZDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBNEI7QUFBQyxRQUNoRCxPQUFFLEdBQUYsRUFBRSxDQUFZO0FBQzFCLFFBRVUsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO0FBQzdDLFFBTUUsYUFBUSxHQUFHLENBQUMsQ0FBQztBQUNmLElBVkssQ0FBQztBQUNOLElBSUUsc0JBQUkseUJBQUk7QUFBSSxhQUFaLFVBQVMsS0FBYztBQUN6QixZQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ3hDLFFBQUUsQ0FBQztBQUVIO0FBRVM7QUFDRCxPQUxMO0FBQ0gsSUFHRSxzQkFBSSxzQ0FBaUI7QUFBSSxhQUF6QjtBQUFjLFlBQ1osT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDeEUsUUFBRSxDQUFDO0FBRUg7QUFBMEI7QUFDWixPQUhYO0FBQ0gsSUFFRSwyQkFBUyxHQUFULFVBQVUsS0FBaUI7QUFDN0IsUUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUU7QUFDaEQsWUFBTSw2SEFBNkg7QUFDbkksWUFBTSxxSEFBcUg7QUFDM0gsWUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMscUJBQXFCLEVBQUUsQ0FBQztBQUN2RCxZQUNNLG1DQUFtQztBQUN6QyxZQUFNLDRDQUE0QztBQUNsRCxZQUFNLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUMzQixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBRUgsSUFFRSxvQ0FBa0IsR0FBbEI7QUFBYyxRQUFkLGlCQU9DO0FBQ0gsUUFQSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDeEIsUUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDO0FBQ2pDLFlBQUUsS0FBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQzVCLFFBQU0sQ0FBQyxDQUFDLENBQ0gsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUVILElBQVUsOEJBQVksR0FBcEI7QUFBYyxRQUNaLDBDQUEwQztBQUM5QyxRQUFJLG9FQUFvRTtBQUN4RSxRQUFJLHlFQUF5RTtBQUM3RSxRQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxJQUFJLENBQUMsTUFBTSxFQUFYLENBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBWixDQUFZLENBQUMsQ0FBQztBQUNuSCxJQUFFLENBQUM7QUFFSCxJQUFFLDZCQUFXLEdBQVg7QUFBYyxRQUNaLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLFdBQVcsRUFBRSxFQUFqQixDQUFpQixDQUFDLENBQUM7QUFDekQsSUFBRSxDQUFDO0FBQ0Y7QUFDa0QsZ0JBckR2QixtQkFBbUI7QUFBSSxnQkFDbEIsdUJBQXVCO0FBQUksZ0JBQzVDLFVBQVU7QUFDeEI7QUFFRSxJQUdGO0FBQWEsUUFEWixLQUFLLENBQUMsU0FBUyxDQUFDO0FBQ25CLHVDQUVHO0FBRUgsSUFPRTtBQUFhLFFBRFosWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLDRDQVVHO0FBRUgsSUFBZ0M7QUFBYSxRQUExQyxlQUFlLENBQUMsV0FBVyxDQUFDO0FBQUMsOENBQTZDO0lBakNoRSxPQUFPLHdCQWRuQixTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUUsVUFBVSxjQUNwQixRQUFRLEVBQUU7d0ZBSVQsY0FDRCxTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSx1QkFBdUIsQ0FBQztTQUM1RCxJQUFJLEVBQUUsa0JBQ0osaUJBQWlCLEVBQUU7Q0FBVSxrQkFDN0I7WUFBYSxFQUFFO01BQVEsa0JBQ3ZCLDZCQUE2QixFQUFFLG1CQUFtQjtPQUNuRCxVQUNGLENBQUMsUUFDVyxPQUFPLENBc0RuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCxjQUFDO0FBQ0EsQ0FEQSxBQXRERCxJQXNEQztBQUNELFNBdkRhLE9BQU87QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUXVlcnlMaXN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZm9jdXMtbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7IFRyZWVGZWF0dXJlc1NlcnZpY2UsIFRSRUVfRkVBVFVSRVNfUFJPVklERVIgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUcmVlTm9kZSB9IGZyb20gJy4vdHJlZS1ub2RlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRyZWUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8Y2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbiAqbmdJZj1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjaGlsZHJlbl09XCJmZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uLnJvb3RcIj48L2Nsci1yZWN1cnNpdmUtY2hpbGRyZW4+XG4gIGAsXG4gIHByb3ZpZGVyczogW1RSRUVfRkVBVFVSRVNfUFJPVklERVIsIFRyZWVGb2N1c01hbmFnZXJTZXJ2aWNlXSxcbiAgaG9zdDoge1xuICAgICdbYXR0ci50YWJpbmRleF0nOiAndGFiaW5kZXgnLFxuICAgICdbYXR0ci5yb2xlXSc6ICdcInRyZWVcIicsXG4gICAgJ1thdHRyLmFyaWEtbXVsdGlzZWxlY3RhYmxlXSc6ICdpc011bHRpU2VsZWN0YWJsZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRyZWU8VD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgZmVhdHVyZXNTZXJ2aWNlOiBUcmVlRmVhdHVyZXNTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgZm9jdXNNYW5hZ2VyU2VydmljZTogVHJlZUZvY3VzTWFuYWdlclNlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZlxuICApIHt9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIEBJbnB1dCgnY2xyTGF6eScpXG4gIHNldCBsYXp5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIgPSAhdmFsdWU7XG4gIH1cblxuICB0YWJpbmRleCA9IDA7XG5cbiAgZ2V0IGlzTXVsdGlTZWxlY3RhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzU2VydmljZS5zZWxlY3RhYmxlICYmIHRoaXMucm9vdE5vZGVzLmxlbmd0aCA+IDA7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdmb2N1c2luJywgWyckZXZlbnQnXSlcbiAgb25Gb2N1c0luKGV2ZW50OiBGb2N1c0V2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5lbC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAvLyBBZnRlciBkaXNjdXNzaW5nIHdpdGggdGhlIHRlYW0sIEkndmUgbWFkZSBpdCBzbyB0aGF0IHdoZW4gdGhlIHRyZWUgcmVjZWl2ZXMgZm9jdXMsIHRoZSBmaXJzdCB2aXNpYmxlIG5vZGUgd2lsbCBiZSBmb2N1c2VkLlxuICAgICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgZnJvbSB0aGUgcGFnZSBzY3JvbGxpbmcgYWJydXB0bHkgdG8gdGhlIGZpcnN0IHNlbGVjdGVkIG5vZGUgaWYgaXQgZXhpc3QgaW4gYSBkZWVwbHkgbmVzdGVkIHRyZWUuXG4gICAgICB0aGlzLmZvY3VzTWFuYWdlclNlcnZpY2UuZm9jdXNGaXJzdFZpc2libGVOb2RlKCk7XG5cbiAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IGNoaWxkIGdldHMgZm9jdXMsXG4gICAgICAvLyB0cmVlIHNob3VsZCBubyBsb25nZXIgaGF2ZSB0YWJpbmRleCBvZiAwO1xuICAgICAgZGVsZXRlIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJUcmVlTm9kZSkgcHJpdmF0ZSByb290Tm9kZXM6IFF1ZXJ5TGlzdDxDbHJUcmVlTm9kZTxUPj47XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuc2V0Um9vdE5vZGVzKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnJvb3ROb2Rlcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0Um9vdE5vZGVzKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNldFJvb3ROb2RlcygpOiB2b2lkIHtcbiAgICAvLyBpZiBub2RlIGhhcyBubyBwYXJlbnQsIGl0J3MgYSByb290IG5vZGVcbiAgICAvLyBmb3IgcmVjdXJzaXZlIHRyZWUsIHRoaXMucm9vdE5vZGVzIHJlZ2lzdGVycyBhbHNvIG5lc3RlZCBjaGlsZHJlblxuICAgIC8vIHNvIHdlIGhhdmUgdG8gdXNlIGZpbHRlciB0byBleHRyYWN0IHRoZSBvbmVzIHRoYXQgYXJlIHRydWx5IHJvb3Qgbm9kZXNcbiAgICB0aGlzLmZvY3VzTWFuYWdlclNlcnZpY2Uucm9vdE5vZGVNb2RlbHMgPSB0aGlzLnJvb3ROb2Rlcy5tYXAobm9kZSA9PiBub2RlLl9tb2RlbCkuZmlsdGVyKG5vZGUgPT4gIW5vZGUucGFyZW50KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiJdfQ==