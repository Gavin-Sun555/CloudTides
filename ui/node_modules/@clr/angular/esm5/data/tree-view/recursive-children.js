/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { Component, Input, Optional } from '@angular/core';
import { IfExpandService } from '../../utils/conditional/if-expanded.service';
import { TreeFeaturesService } from './tree-features.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function RecursiveChildren_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var child_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.featuresService.recursion.template)("ngTemplateOutletContext", ctx_r1.getContext(child_r2));
} }
function RecursiveChildren_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_Template, 2, 2, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", (ctx_r0.parent == null ? null : ctx_r0.parent.children) || ctx_r0.children);
} }
var RecursiveChildren = /** @class */ (function () {
    function RecursiveChildren(featuresService, expandService) {
        var _this = this;
        this.featuresService = featuresService;
        this.expandService = expandService;
        if (expandService) {
            this.subscription = this.expandService.expandChange.subscribe(function (value) {
                if (!value && _this.parent && !_this.featuresService.eager && _this.featuresService.recursion) {
                    // In the case of lazy-loading recursive trees, we clear the children on collapse.
                    // This is better in case they change between two user interaction, and that way
                    // the app itself can decide whether to cache them or not.
                    _this.parent.clearChildren();
                }
            });
        }
    }
    RecursiveChildren.prototype.shouldRender = function () {
        return (this.featuresService.recursion &&
            // In the smart case, we eagerly render all the recursive children
            // to make sure two-way bindings for selection are available.
            // They will be hidden with CSS by the parent.
            (this.featuresService.eager || !this.expandService || this.expandService.expanded));
    };
    RecursiveChildren.prototype.getContext = function (node) {
        return {
            $implicit: node.model,
            clrModel: node,
        };
    };
    RecursiveChildren.prototype.ngOnDestroy = function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    RecursiveChildren.ctorParameters = function () { return [
        { type: TreeFeaturesService },
        { type: IfExpandService, decorators: [{ type: Optional }] }
    ]; };
    __decorate([
        Input('parent')
    ], RecursiveChildren.prototype, "parent", void 0);
    __decorate([
        Input('children')
    ], RecursiveChildren.prototype, "children", void 0);
    RecursiveChildren = __decorate([ __param(1, Optional())
    ], RecursiveChildren);
RecursiveChildren.ɵfac = function RecursiveChildren_Factory(t) { return new (t || RecursiveChildren)(ɵngcc0.ɵɵdirectiveInject(TreeFeaturesService), ɵngcc0.ɵɵdirectiveInject(IfExpandService, 8)); };
RecursiveChildren.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RecursiveChildren, selectors: [["clr-recursive-children"]], hostVars: 1, hostBindings: function RecursiveChildren_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", "group");
    } }, inputs: { parent: "parent", children: "children" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function RecursiveChildren_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, RecursiveChildren_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldRender());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RecursiveChildren, [{
        type: Component,
        args: [{
                selector: 'clr-recursive-children',
                template: "\n    <ng-container *ngIf=\"shouldRender()\">\n      <ng-container *ngFor=\"let child of parent?.children || children\">\n        <ng-container *ngTemplateOutlet=\"featuresService.recursion.template; context: getContext(child)\"></ng-container>\n      </ng-container>\n    </ng-container>\n  ",
                host: {
                    '[attr.role]': '"group"'
                }
            }]
    }], function () { return [{ type: TreeFeaturesService }, { type: IfExpandService, decorators: [{
                type: Optional
            }] }]; }, { parent: [{
            type: Input,
            args: ['parent']
        }], children: [{
            type: Input,
            args: ['children']
        }] }); })();
    return RecursiveChildren;
}());
export { RecursiveChildren };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlLWNoaWxkcmVuLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L3JlY3Vyc2l2ZS1jaGlsZHJlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDOUUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0I5RDtBQUNpQixJQUFmLDJCQUFtQixlQUF1QyxFQUFzQixhQUE4QjtBQUNoSCxRQURFLGlCQVdDO0FBQ0gsUUFacUIsb0JBQWUsR0FBZixlQUFlLENBQXdCO0FBQUMsUUFBcUIsa0JBQWEsR0FBYixhQUFhLENBQWlCO0FBQUMsUUFDN0csSUFBSSxhQUFhLEVBQUU7QUFDdkIsWUFBTSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxVQUFBLEtBQUs7QUFBSSxnQkFDckUsSUFBSSxDQUFDLEtBQUssSUFBSSxLQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLElBQUksS0FBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUU7QUFDcEcsb0JBQVUsa0ZBQWtGO0FBQzVGLG9CQUFVLGdGQUFnRjtBQUMxRixvQkFBVSwwREFBMEQ7QUFDcEUsb0JBQXNDLEtBQUksQ0FBQyxNQUFPLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDbkUsaUJBQVM7QUFDVCxZQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ1QsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ0Usd0NBQVksR0FBWjtBQUFjLFFBQ1osT0FBTyxDQUNMLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUztBQUNwQyxZQUFNLGtFQUFrRTtBQUN4RSxZQUFNLDZEQUE2RDtBQUNuRSxZQUFNLDhDQUE4QztBQUNwRCxZQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQ25GLENBQUM7QUFDTixJQUFFLENBQUM7QUFFSCxJQUtFLHNDQUFVLEdBQVYsVUFBVyxJQUFzQjtBQUFJLFFBQ25DLE9BQU87QUFDWCxZQUFNLFNBQVMsRUFBRSxJQUFJLENBQUMsS0FBSztBQUMzQixZQUFNLFFBQVEsRUFBRSxJQUFJO0FBQ3BCLFNBQUssQ0FBQztBQUNOLElBQUUsQ0FBQztBQUVILElBRUUsdUNBQVcsR0FBWDtBQUFjLFFBQ1osSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO0FBQzNCLFlBQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUN0QyxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0Y7QUFDNEQsZ0JBM0N2QixtQkFBbUI7QUFBSSxnQkFBb0MsZUFBZSx1QkFBakQsUUFBUTtBQUFNO0FBQVUsSUF5QnBFO0FBQWEsUUFBN0IsS0FBSyxDQUFDLFFBQVEsQ0FBQztBQUFDLHFEQUF5QjtBQUMzQyxJQUFvQjtBQUFhLFFBQS9CLEtBQUssQ0FBQyxVQUFVLENBQUM7QUFBQyx1REFBNkI7QUFFbEQsSUE3QmEsaUJBQWlCLHdCQWpCN0IsU0FBUyxDQUFDLG5CQWlCTSxDQUM4QyxXQUFBLFFBQVEsRUFBRSxDQUFBO1NBakJ2RSxRQUFRLEVBQUUsbkJBaUI4RCxPQUQ3RCxpQkFBaUIsQ0EyQzdCO2dCQTNEbUMsY0FDbEMsUUFBUSxFQUFFO3dJQU1ULGNBQ0QsSUFBSSxFQUFFLGtCQUNKLGFBQWEsRUFBRSxTQUFTO0dBQ3pCLFVBQ0YsQ0FBQyxTQUNGO3lJQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTZDSDtBQUFDLElBREQsd0JBQUM7QUFDQSxDQURBLEFBM0NELElBMkNDO0FBQ0QsU0E1Q2EsaUJBQWlCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFeHBhbmRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtZXhwYW5kZWQuc2VydmljZSc7XG5pbXBvcnQgeyBUcmVlRmVhdHVyZXNTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQgfSBmcm9tICcuL3JlY3Vyc2l2ZS1mb3Itb2YnO1xuaW1wb3J0IHsgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmVjdXJzaXZlLWNoaWxkcmVuJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2hvdWxkUmVuZGVyKClcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNoaWxkIG9mIHBhcmVudD8uY2hpbGRyZW4gfHwgY2hpbGRyZW5cIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24udGVtcGxhdGU7IGNvbnRleHQ6IGdldENvbnRleHQoY2hpbGQpXCI+PC9uZy1jb250YWluZXI+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYCxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5yb2xlXSc6ICdcImdyb3VwXCInLCAvLyBTYWZhcmkgKyBWTyBuZWVkcyBkaXJlY3QgcmVsYXRpb25zaGlwIGJldHdlZW4gdHJlZWl0ZW0gYW5kIGdyb3VwOyBubyBlbGVtZW50IHNob3VsZCBleGlzdCBiZXR3ZWVuIHRoZW1cbiAgfSxcbn0pXG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCwgZG8gbm90IGV4cG9ydCFcbiAqIFRoaXMgaXMgcGFydCBvZiB0aGUgaGFjayB0byBnZXQgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1OTk4XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWN1cnNpdmVDaGlsZHJlbjxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sIEBPcHRpb25hbCgpIHByaXZhdGUgZXhwYW5kU2VydmljZTogSWZFeHBhbmRTZXJ2aWNlKSB7XG4gICAgaWYgKGV4cGFuZFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZENoYW5nZS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlICYmIHRoaXMucGFyZW50ICYmICF0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciAmJiB0aGlzLmZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24pIHtcbiAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBsYXp5LWxvYWRpbmcgcmVjdXJzaXZlIHRyZWVzLCB3ZSBjbGVhciB0aGUgY2hpbGRyZW4gb24gY29sbGFwc2UuXG4gICAgICAgICAgLy8gVGhpcyBpcyBiZXR0ZXIgaW4gY2FzZSB0aGV5IGNoYW5nZSBiZXR3ZWVuIHR3byB1c2VyIGludGVyYWN0aW9uLCBhbmQgdGhhdCB3YXlcbiAgICAgICAgICAvLyB0aGUgYXBwIGl0c2VsZiBjYW4gZGVjaWRlIHdoZXRoZXIgdG8gY2FjaGUgdGhlbSBvciBub3QuXG4gICAgICAgICAgKDxSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+PnRoaXMucGFyZW50KS5jbGVhckNoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNob3VsZFJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uICYmXG4gICAgICAvLyBJbiB0aGUgc21hcnQgY2FzZSwgd2UgZWFnZXJseSByZW5kZXIgYWxsIHRoZSByZWN1cnNpdmUgY2hpbGRyZW5cbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0d28td2F5IGJpbmRpbmdzIGZvciBzZWxlY3Rpb24gYXJlIGF2YWlsYWJsZS5cbiAgICAgIC8vIFRoZXkgd2lsbCBiZSBoaWRkZW4gd2l0aCBDU1MgYnkgdGhlIHBhcmVudC5cbiAgICAgICh0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciB8fCAhdGhpcy5leHBhbmRTZXJ2aWNlIHx8IHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZClcbiAgICApO1xuICB9XG5cbiAgLy8gT2ZmZXJpbmcgdGhlIG9wdGlvbiB0byBlaXRoZXIgZ2l2ZSB0aGUgcGFyZW50IG5vZGUgdG8gcmVjdXJzZSBwb3RlbnRpYWxseSBsYXppbHksXG4gIC8vIG9yIGRpcmVjdGx5IHRoZSBsaXN0IG9mIGNoaWxkcmVuIHRvIGRpc3BsYXkuXG4gIEBJbnB1dCgncGFyZW50JykgcGFyZW50OiBUcmVlTm9kZU1vZGVsPFQ+O1xuICBASW5wdXQoJ2NoaWxkcmVuJykgY2hpbGRyZW46IFRyZWVOb2RlTW9kZWw8VD5bXTtcblxuICBnZXRDb250ZXh0KG5vZGU6IFRyZWVOb2RlTW9kZWw8VD4pOiBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQ8VD4ge1xuICAgIHJldHVybiB7XG4gICAgICAkaW1wbGljaXQ6IG5vZGUubW9kZWwsXG4gICAgICBjbHJNb2RlbDogbm9kZSxcbiAgICB9O1xuICB9XG5cbiAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19