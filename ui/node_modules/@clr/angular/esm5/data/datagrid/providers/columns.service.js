import { __assign, __decorate } from "tslib";
/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from '@angular/core';
import { ALL_COLUMN_CHANGES } from '../enums/column-changes.enum';
import * as ɵngcc0 from '@angular/core';
var ColumnsService = /** @class */ (function () {
    function ColumnsService() {
        this.columns = [];
        this._cache = [];
    }
    ColumnsService.prototype.cache = function () {
        this._cache = this.columns.map(function (subject) {
            var value = __assign({}, subject.value);
            delete value.changes;
            return value;
        });
    };
    ColumnsService.prototype.hasCache = function () {
        return !!this._cache.length;
    };
    ColumnsService.prototype.resetToLastCache = function () {
        var _this = this;
        this._cache.forEach(function (state, index) {
            // Just emit the exact value from the cache
            _this.columns[index].next(__assign(__assign({}, state), { changes: ALL_COLUMN_CHANGES }));
        });
        this._cache = [];
    };
    Object.defineProperty(ColumnsService.prototype, "columnStates", {
        get: function () {
            return this.columns.map(function (column) { return column.value; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnsService.prototype, "hasHideableColumns", {
        get: function () {
            return this.columnStates.filter(function (state) { return state.hideable; }).length > 0;
        },
        enumerable: true,
        configurable: true
    });
    // Helper method to emit a change to a column only when there is an actual diff to process for that column
    ColumnsService.prototype.emitStateChangeAt = function (columnIndex, diff) {
        if (!this.columns[columnIndex]) {
            return;
        }
        this.emitStateChange(this.columns[columnIndex], diff);
    };
    ColumnsService.prototype.emitStateChange = function (column, diff) {
        column.next(__assign(__assign({}, column.value), diff));
    };
ColumnsService.ɵfac = function ColumnsService_Factory(t) { return new (t || ColumnsService)(); };
ColumnsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnsService, factory: function (t) { return ColumnsService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnsService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return ColumnsService;
}());
export { ColumnsService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1ucy5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2NvbHVtbnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7QUFHbEU7QUFDb0IsSUFEcEI7QUFBNEIsUUFDMUIsWUFBTyxHQUFtQyxFQUFFLENBQUM7QUFDL0MsUUFBVSxXQUFNLEdBQWtCLEVBQUUsQ0FBQztBQUNyQyxJQXdDQSxDQUFDO0FBQ0QsSUF4Q0UsOEJBQUssR0FBTDtBQUNFLFFBQUEsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFBLE9BQU87QUFBSSxZQUN4QyxJQUFNLEtBQUssZ0JBQVEsT0FBTyxDQUFDLEtBQUssQ0FBRSxDQUFDO0FBQ3pDLFlBQU0sT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDO0FBQzNCLFlBQU0sT0FBTyxLQUFLLENBQUM7QUFDbkIsUUFBSSxDQUFDLENBQUMsQ0FBQztBQUNQLElBQUUsQ0FBQztBQUVILElBQUUsaUNBQVEsR0FBUjtBQUNELFFBQUcsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEMsSUFBRSxDQUFDO0FBRUgsSUFBRSx5Q0FBZ0IsR0FBaEI7QUFBYyxRQUFkLGlCQU1DO0FBQ0gsUUFOSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQUssRUFBRSxLQUFLO0FBQUksWUFDbkMsMkNBQTJDO0FBQ2pELFlBQU0sS0FBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLHVCQUFNLEtBQUssS0FBRSxPQUFPLEVBQUUsa0JBQWtCLElBQUcsQ0FBQztBQUMxRSxRQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ1AsUUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNyQixJQUFFLENBQUM7QUFFSCxJQUFFLHNCQUFJLHdDQUFZO0FBQUksYUFBcEI7QUFBYyxZQUNaLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBQSxNQUFNLElBQUksT0FBQSxNQUFNLENBQUMsS0FBSyxFQUFaLENBQVksQ0FBQyxDQUFDO0FBQ3BELFFBQUUsQ0FBQztBQUVIO0FBQTBCO0FBQ1gsT0FIWjtBQUNILElBQ0Usc0JBQUksOENBQWtCO0FBQUksYUFBMUI7QUFBYyxZQUNaLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsVUFBQSxLQUFLLElBQUksT0FBQSxLQUFLLENBQUMsUUFBUSxFQUFkLENBQWMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDeEUsUUFBRSxDQUFDO0FBRUg7QUFBMEI7QUFBMkIsT0FGbEQ7QUFDSCxJQUNFLDBHQUEwRztBQUM1RyxJQUFFLDBDQUFpQixHQUFqQixVQUFrQixXQUFtQixFQUFFLElBQXFCO0FBQzlELFFBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDcEMsWUFBTSxPQUFPO0FBQ2IsU0FBSztBQUNMLFFBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzFELElBQUUsQ0FBQztBQUVILElBQUUsd0NBQWUsR0FBZixVQUFnQixNQUFvQyxFQUFFLElBQXFCO0FBQzdFLFFBQUksTUFBTSxDQUFDLElBQUksdUJBQU0sTUFBTSxDQUFDLEtBQUssR0FBSyxJQUFJLEVBQUcsQ0FBQztBQUM5QyxJQUFFLENBQUM7SUExQ1UsY0FBYyx3QkFEMUIsVUFBVSxFQUFFLFFBQ0EsY0FBYyxDQTJDMUI7Ozs7Z0RBQ0Q7QUFBQyxJQURELHFCQUFDO0FBQ0EsQ0FEQSxBQTNDRCxJQTJDQztBQUNELFNBNUNhLGNBQWM7QUFDMUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENvbHVtblN0YXRlRGlmZiwgQ29sdW1uU3RhdGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbHVtbi1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQUxMX0NPTFVNTl9DSEFOR0VTIH0gZnJvbSAnLi4vZW51bXMvY29sdW1uLWNoYW5nZXMuZW51bSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2x1bW5zU2VydmljZSB7XG4gIGNvbHVtbnM6IEJlaGF2aW9yU3ViamVjdDxDb2x1bW5TdGF0ZT5bXSA9IFtdO1xuICBwcml2YXRlIF9jYWNoZTogQ29sdW1uU3RhdGVbXSA9IFtdO1xuXG4gIGNhY2hlKCkge1xuICAgIHRoaXMuX2NhY2hlID0gdGhpcy5jb2x1bW5zLm1hcChzdWJqZWN0ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0geyAuLi5zdWJqZWN0LnZhbHVlIH07XG4gICAgICBkZWxldGUgdmFsdWUuY2hhbmdlcztcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhc0NhY2hlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2NhY2hlLmxlbmd0aDtcbiAgfVxuXG4gIHJlc2V0VG9MYXN0Q2FjaGUoKSB7XG4gICAgdGhpcy5fY2FjaGUuZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICAvLyBKdXN0IGVtaXQgdGhlIGV4YWN0IHZhbHVlIGZyb20gdGhlIGNhY2hlXG4gICAgICB0aGlzLmNvbHVtbnNbaW5kZXhdLm5leHQoeyAuLi5zdGF0ZSwgY2hhbmdlczogQUxMX0NPTFVNTl9DSEFOR0VTIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2NhY2hlID0gW107XG4gIH1cblxuICBnZXQgY29sdW1uU3RhdGVzKCk6IENvbHVtblN0YXRlW10ge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbnMubWFwKGNvbHVtbiA9PiBjb2x1bW4udmFsdWUpO1xuICB9XG5cbiAgZ2V0IGhhc0hpZGVhYmxlQ29sdW1ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5TdGF0ZXMuZmlsdGVyKHN0YXRlID0+IHN0YXRlLmhpZGVhYmxlKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZCB0byBlbWl0IGEgY2hhbmdlIHRvIGEgY29sdW1uIG9ubHkgd2hlbiB0aGVyZSBpcyBhbiBhY3R1YWwgZGlmZiB0byBwcm9jZXNzIGZvciB0aGF0IGNvbHVtblxuICBlbWl0U3RhdGVDaGFuZ2VBdChjb2x1bW5JbmRleDogbnVtYmVyLCBkaWZmOiBDb2x1bW5TdGF0ZURpZmYpIHtcbiAgICBpZiAoIXRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0U3RhdGVDaGFuZ2UodGhpcy5jb2x1bW5zW2NvbHVtbkluZGV4XSwgZGlmZik7XG4gIH1cblxuICBlbWl0U3RhdGVDaGFuZ2UoY29sdW1uOiBCZWhhdmlvclN1YmplY3Q8Q29sdW1uU3RhdGU+LCBkaWZmOiBDb2x1bW5TdGF0ZURpZmYpIHtcbiAgICBjb2x1bW4ubmV4dCh7IC4uLmNvbHVtbi52YWx1ZSwgLi4uZGlmZiB9KTtcbiAgfVxufVxuIl19