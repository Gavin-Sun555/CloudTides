import { __decorate } from "tslib";
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { ContentChildren, Directive } from '@angular/core';
import { DatagridCellRenderer } from './cell-renderer';
import { ColumnsService } from '../providers/columns.service';
import * as ɵngcc0 from '@angular/core';
var DatagridRowRenderer = /** @class */ (function () {
    function DatagridRowRenderer(columnsService) {
        this.columnsService = columnsService;
        this.subscriptions = [];
    }
    DatagridRowRenderer.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.setColumnState(); // case #3 and #4
        this.subscriptions.push(this.cells.changes.subscribe(function () {
            _this.setColumnState(); // case #2
            // Note on case #2: In the case of dynamic columns, when one column (header/cell together) gets deleted,
            // this.cells.changes emits before this.columnsService.columns gets updated in MainRenderer
            // when this.headers.changes emits as well. So that means there will be n+1 column state providers
            // when this.cells.changes emits. Hence, we should quit earlier there. But this method will be called
            // right after again when this.headers.changes emits. By then, there will be the same number of column state
            // providers as column headers.
        }));
    };
    DatagridRowRenderer.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    DatagridRowRenderer.prototype.setColumnState = function () {
        var _this = this;
        // This method runs in four cases:
        // 1. When the initial rows appear on the first page.
        //    In this case, the method will be called in DatagridMainRenderer.
        // 2. When columns (corresponding header/cells) get added and deleted.
        //    In this case, the method will be called in DatagridMainRenderer. (Read the note on this case above).
        // 3. When rows load asynchronously.
        //    In this case, the method will be called in this class.
        // 4. When rows load after switching pages.
        //    In this case, the method will be called in this class (Basically, same as the case 3).
        if (this.cells.length === this.columnsService.columns.length) {
            this.cells.forEach(function (cell, index) {
                if (_this.columnsService.columns[index]) {
                    cell.columnState = _this.columnsService.columns[index];
                }
            });
        }
    };
    DatagridRowRenderer.ctorParameters = function () { return [
        { type: ColumnsService }
    ]; };
    __decorate([
        ContentChildren(DatagridCellRenderer)
    ], DatagridRowRenderer.prototype, "cells", void 0);
DatagridRowRenderer.ɵfac = function DatagridRowRenderer_Factory(t) { return new (t || DatagridRowRenderer)(ɵngcc0.ɵɵdirectiveInject(ColumnsService)); };
DatagridRowRenderer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DatagridRowRenderer, selectors: [["clr-dg-row"], ["clr-dg-row-detail"]], contentQueries: function DatagridRowRenderer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DatagridCellRenderer, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cells = _t);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatagridRowRenderer, [{
        type: Directive,
        args: [{ selector: 'clr-dg-row, clr-dg-row-detail' }]
    }], function () { return [{ type: ColumnsService }]; }, { cells: [{
            type: ContentChildren,
            args: [DatagridCellRenderer]
        }] }); })();
    return DatagridRowRenderer;
}());
export { DatagridRowRenderer };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LXJlbmRlcmVyLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL3Jvdy1yZW5kZXJlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsT0FBTyxFQUFvQixlQUFlLEVBQUUsU0FBUyxFQUF3QixNQUFNLGVBQWUsQ0FBQztBQUVuRyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sOEJBQThCLENBQUM7O0FBSTlEO0FBQXVELElBR3JELDZCQUFvQixjQUE4QjtBQUFJLFFBQWxDLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtBQUFDLFFBaUIzQyxrQkFBYSxHQUFtQixFQUFFLENBQUM7QUFDN0MsSUFsQnVELENBQUM7QUFDeEQsSUFDRSxnREFBa0IsR0FBbEI7QUFBYyxRQUFkLGlCQWFDO0FBQ0gsUUFiSSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxpQkFBaUI7QUFDNUMsUUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDO0FBQzdCLFlBQUUsS0FBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsVUFBVTtBQUN6QyxZQUFRLHdHQUF3RztBQUNoSCxZQUFRLDJGQUEyRjtBQUNuRyxZQUFRLGtHQUFrRztBQUMxRyxZQUFRLHFHQUFxRztBQUM3RyxZQUFRLDRHQUE0RztBQUNwSCxZQUFRLCtCQUErQjtBQUN2QyxRQUFNLENBQUMsQ0FBQyxDQUNILENBQUM7QUFDTixJQUFFLENBQUM7QUFFSCxJQUVFLHlDQUFXLEdBQVg7QUFBYyxRQUNaLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLFdBQVcsRUFBRSxFQUFqQixDQUFpQixDQUFDLENBQUM7QUFDekQsSUFBRSxDQUFDO0FBRUgsSUFBUyw0Q0FBYyxHQUFyQjtBQUFjLFFBQWQsaUJBaUJDO0FBQ0gsUUFqQkksa0NBQWtDO0FBQ3RDLFFBQUkscURBQXFEO0FBQ3pELFFBQUksc0VBQXNFO0FBQzFFLFFBQUksc0VBQXNFO0FBQzFFLFFBQUksMEdBQTBHO0FBQzlHLFFBQUksb0NBQW9DO0FBQ3hDLFFBQUksNERBQTREO0FBQ2hFLFFBQUksMkNBQTJDO0FBQy9DLFFBQUksNEZBQTRGO0FBQ2hHLFFBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDbEUsWUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQUksRUFBRSxLQUFLO0FBQUksZ0JBQ2pDLElBQUksS0FBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDaEQsb0JBQVUsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoRSxpQkFBUztBQUNULFlBQU0sQ0FBQyxDQUFDLENBQUM7QUFDVCxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0Y7QUFDOEQsZ0JBMUN6QixjQUFjO0FBQUc7QUFFaEQsSUFKa0M7QUFBYSxRQUFuRCxlQUFlLENBQUMsb0JBQW9CLENBQUM7QUFBQyxzREFBK0M7SUFEM0UsbUJBQW1CLHdCQUQvQixTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsK0JBQStCLEVBQUUsQ0FBQyxRQUM1QyxtQkFBbUIsQ0E0Qy9COzs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCwwQkFBQztBQUNBLENBREEsQUE1Q0QsSUE0Q0M7QUFDRCxTQTdDYSxtQkFBbUI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZENlbGxSZW5kZXJlciB9IGZyb20gJy4vY2VsbC1yZW5kZXJlcic7XG5pbXBvcnQgeyBDb2x1bW5zU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9jb2x1bW5zLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1yb3csIGNsci1kZy1yb3ctZGV0YWlsJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkUm93UmVuZGVyZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBAQ29udGVudENoaWxkcmVuKERhdGFncmlkQ2VsbFJlbmRlcmVyKSBwcml2YXRlIGNlbGxzOiBRdWVyeUxpc3Q8RGF0YWdyaWRDZWxsUmVuZGVyZXI+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29sdW1uc1NlcnZpY2U6IENvbHVtbnNTZXJ2aWNlKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLnNldENvbHVtblN0YXRlKCk7IC8vIGNhc2UgIzMgYW5kICM0XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmNlbGxzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRDb2x1bW5TdGF0ZSgpOyAvLyBjYXNlICMyXG4gICAgICAgIC8vIE5vdGUgb24gY2FzZSAjMjogSW4gdGhlIGNhc2Ugb2YgZHluYW1pYyBjb2x1bW5zLCB3aGVuIG9uZSBjb2x1bW4gKGhlYWRlci9jZWxsIHRvZ2V0aGVyKSBnZXRzIGRlbGV0ZWQsXG4gICAgICAgIC8vIHRoaXMuY2VsbHMuY2hhbmdlcyBlbWl0cyBiZWZvcmUgdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zIGdldHMgdXBkYXRlZCBpbiBNYWluUmVuZGVyZXJcbiAgICAgICAgLy8gd2hlbiB0aGlzLmhlYWRlcnMuY2hhbmdlcyBlbWl0cyBhcyB3ZWxsLiBTbyB0aGF0IG1lYW5zIHRoZXJlIHdpbGwgYmUgbisxIGNvbHVtbiBzdGF0ZSBwcm92aWRlcnNcbiAgICAgICAgLy8gd2hlbiB0aGlzLmNlbGxzLmNoYW5nZXMgZW1pdHMuIEhlbmNlLCB3ZSBzaG91bGQgcXVpdCBlYXJsaWVyIHRoZXJlLiBCdXQgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAgLy8gcmlnaHQgYWZ0ZXIgYWdhaW4gd2hlbiB0aGlzLmhlYWRlcnMuY2hhbmdlcyBlbWl0cy4gQnkgdGhlbiwgdGhlcmUgd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgY29sdW1uIHN0YXRlXG4gICAgICAgIC8vIHByb3ZpZGVycyBhcyBjb2x1bW4gaGVhZGVycy5cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHVibGljIHNldENvbHVtblN0YXRlKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIHJ1bnMgaW4gZm91ciBjYXNlczpcbiAgICAvLyAxLiBXaGVuIHRoZSBpbml0aWFsIHJvd3MgYXBwZWFyIG9uIHRoZSBmaXJzdCBwYWdlLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBpbiBEYXRhZ3JpZE1haW5SZW5kZXJlci5cbiAgICAvLyAyLiBXaGVuIGNvbHVtbnMgKGNvcnJlc3BvbmRpbmcgaGVhZGVyL2NlbGxzKSBnZXQgYWRkZWQgYW5kIGRlbGV0ZWQuXG4gICAgLy8gICAgSW4gdGhpcyBjYXNlLCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGluIERhdGFncmlkTWFpblJlbmRlcmVyLiAoUmVhZCB0aGUgbm90ZSBvbiB0aGlzIGNhc2UgYWJvdmUpLlxuICAgIC8vIDMuIFdoZW4gcm93cyBsb2FkIGFzeW5jaHJvbm91c2x5LlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBpbiB0aGlzIGNsYXNzLlxuICAgIC8vIDQuIFdoZW4gcm93cyBsb2FkIGFmdGVyIHN3aXRjaGluZyBwYWdlcy5cbiAgICAvLyAgICBJbiB0aGlzIGNhc2UsIHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgaW4gdGhpcyBjbGFzcyAoQmFzaWNhbGx5LCBzYW1lIGFzIHRoZSBjYXNlIDMpLlxuICAgIGlmICh0aGlzLmNlbGxzLmxlbmd0aCA9PT0gdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zW2luZGV4XSkge1xuICAgICAgICAgIGNlbGwuY29sdW1uU3RhdGUgPSB0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==