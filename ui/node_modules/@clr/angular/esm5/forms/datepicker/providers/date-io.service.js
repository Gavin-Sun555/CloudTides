/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __read } from "tslib";
import { Injectable } from '@angular/core';
import { BIG_ENDIAN, DEFAULT_LOCALE_FORMAT, DELIMITER_REGEX, LITTLE_ENDIAN, LITTLE_ENDIAN_REGEX, MIDDLE_ENDIAN, MIDDLE_ENDIAN_REGEX, RTL_REGEX, USER_INPUT_REGEX, } from '../utils/constants';
import { getNumberOfDaysInTheMonth, parseToFourDigitYear } from '../utils/date-utils';
import { LocaleHelperService } from './locale-helper.service';
import { DayModel } from '../model/day.model';
import * as ɵngcc0 from '@angular/core';
var DateIOService = /** @class */ (function () {
    function DateIOService(_localeHelperService) {
        this._localeHelperService = _localeHelperService;
        this.disabledDates = {
            // This is the default range. It approximates the beginning of time to the end of time.
            // Unless a minDate or maxDate is set with the native HTML5 api the range is all dates
            // TODO: turn this into an Array of min/max ranges that allow configuration of multiple ranges.
            minDate: new DayModel(0, 0, 1),
            maxDate: new DayModel(9999, 11, 31),
        };
        this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
        this.localeDisplayFormat = LITTLE_ENDIAN;
        this.delimiters = ['/', '/'];
        this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
        this.initializeLocaleDisplayFormat();
    }
    DateIOService.prototype.setMinDate = function (date) {
        // NOTE: I'm expecting consumers to pass one of four things here:
        //       A proper date string(2019-11-11), null, undefined or empty string ('')
        if (!date) {
            // attribute binding was removed, reset back to the beginning of time
            this.disabledDates.minDate = new DayModel(0, 0, 1);
        }
        else {
            var _a = __read(date.split('-').map(function (n) { return parseInt(n, 10); }), 3), year = _a[0], month = _a[1], day = _a[2];
            this.disabledDates.minDate = new DayModel(year, month - 1, day);
        }
    };
    DateIOService.prototype.setMaxDate = function (date) {
        // NOTE: I'm expecting consumers to pass one of four things here:
        //       A proper date string(2019-11-11), null, undefined or empty string ('')
        if (!date) {
            // attribute binding was removed, reset forward to the end of time
            this.disabledDates.maxDate = new DayModel(9999, 11, 31);
        }
        else {
            var _a = __read(date.split('-').map(function (n) { return parseInt(n, 10); }), 3), year = _a[0], month = _a[1], day = _a[2];
            this.disabledDates.maxDate = new DayModel(year, month - 1, day);
        }
    };
    DateIOService.prototype.initializeLocaleDisplayFormat = function () {
        var format = this.cldrLocaleDateFormat.toLocaleLowerCase();
        if (LITTLE_ENDIAN_REGEX.test(format)) {
            this.localeDisplayFormat = LITTLE_ENDIAN;
        }
        else if (MIDDLE_ENDIAN_REGEX.test(format)) {
            this.localeDisplayFormat = MIDDLE_ENDIAN;
        }
        else {
            // everything else is set to BIG-ENDIAN FORMAT
            this.localeDisplayFormat = BIG_ENDIAN;
        }
        this.extractDelimiters();
    };
    DateIOService.prototype.extractDelimiters = function () {
        if (this.cldrLocaleDateFormat) {
            // Sanitize Date Format. Remove RTL characters.
            // FIXME: When we support RTL, remove this and handle it correctly.
            var localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, '');
            var delimiters = localeFormat.split(DELIMITER_REGEX);
            // NOTE: The split from the CLDR date format should always result
            // in an arary with 4 elements. The 1st and the 2nd values are the delimiters
            // we will use in order.
            // Eg: "dd/MM/y".split(/d+|m+|y+/i) results in ["", "/", "/", ""]
            if (delimiters && delimiters.length === 4) {
                this.delimiters = [delimiters[1], delimiters[2]];
            }
            else {
                console.error('Unexpected date format received. Delimiters extracted: ', delimiters);
            }
        }
    };
    DateIOService.prototype.toLocaleDisplayFormatString = function (date) {
        if (date) {
            if (isNaN(date.getTime())) {
                return '';
            }
            var dateNo = date.getDate();
            var monthNo = date.getMonth() + 1;
            var dateStr = dateNo > 9 ? dateNo.toString() : '0' + dateNo;
            var monthStr = monthNo > 9 ? monthNo.toString() : '0' + monthNo;
            if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
            }
            else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
            }
            else {
                return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
            }
        }
        return '';
    };
    Object.defineProperty(DateIOService.prototype, "placeholderText", {
        get: function () {
            var format = this.localeDisplayFormat.format;
            return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if the month entered by the user is valid or not.
     * Note: Month is 0 based.
     */
    DateIOService.prototype.isValidMonth = function (month) {
        return month > -1 && month < 12;
    };
    /**
     * Checks if the date is valid depending on the year and month provided.
     */
    DateIOService.prototype.isValidDate = function (year, month, date) {
        return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
    };
    /**
     * Validates the parameters provided and returns the date.
     * If the parameters are not
     * valid then return null.
     * NOTE: (Month here is 1 based since the user has provided that as an input)
     */
    DateIOService.prototype.validateAndGetDate = function (year, month, date) {
        // I don't know whats wrong with the TS compiler. It throws an error if I write
        // the below if statement. The error is:
        // Operator '!==' cannot be applied to types '2' and '4'
        // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
        /*
            if (year.length !== 2 || year.length !== 4) {
                return null;
            }
            */
        // Instead I have to write the logic like this x-(
        var y = +year;
        var m = +month - 1; // month is 0 based
        var d = +date;
        if (!this.isValidMonth(m) || !this.isValidDate(y, m, d)) {
            return null;
        }
        var result = parseToFourDigitYear(y);
        return result !== -1 ? new Date(result, m, d) : null;
    };
    DateIOService.prototype.getDateValueFromDateString = function (date) {
        if (!date) {
            return null;
        }
        var dateParts = date.match(USER_INPUT_REGEX);
        if (!dateParts || dateParts.length !== 3) {
            return null;
        }
        var _a = __read(dateParts, 3), firstPart = _a[0], secondPart = _a[1], thirdPart = _a[2];
        if (this.localeDisplayFormat === LITTLE_ENDIAN) {
            // secondPart is month && firstPart is date
            return this.validateAndGetDate(thirdPart, secondPart, firstPart);
        }
        else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
            // firstPart is month && secondPart is date
            return this.validateAndGetDate(thirdPart, firstPart, secondPart);
        }
        else {
            // secondPart is month && thirdPart is date
            return this.validateAndGetDate(firstPart, secondPart, thirdPart);
        }
    };
    DateIOService.ctorParameters = function () { return [
        { type: LocaleHelperService }
    ]; };
DateIOService.ɵfac = function DateIOService_Factory(t) { return new (t || DateIOService)(ɵngcc0.ɵɵinject(LocaleHelperService)); };
DateIOService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DateIOService, factory: function (t) { return DateIOService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateIOService, [{
        type: Injectable
    }], function () { return [{ type: LocaleHelperService }]; }, null); })();
    return DateIOService;
}());
export { DateIOService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1pby5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyJuZzovQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGUtaW8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUNMLFVBQVUsRUFDVixxQkFBcUIsRUFDckIsZUFBZSxFQUVmLGFBQWEsRUFDYixtQkFBbUIsRUFDbkIsYUFBYSxFQUNiLG1CQUFtQixFQUNuQixTQUFTLEVBQ1QsZ0JBQWdCLEdBQ2pCLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLG9CQUFvQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQUc5QztBQUNvQixJQVdsQix1QkFBb0Isb0JBQXlDO0FBQy9ELFFBRHNCLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBcUI7QUFBQyxRQVh2RCxrQkFBYSxHQUFjO0FBQ3BDLFlBQUksdUZBQXVGO0FBQzNGLFlBQUksc0ZBQXNGO0FBQzFGLFlBQUksK0ZBQStGO0FBQ25HLFlBQUksT0FBTyxFQUFFLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2xDLFlBQUksT0FBTyxFQUFFLElBQUksUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0FBQ3ZDLFNBQUcsQ0FBQztBQUNKLFFBQVMseUJBQW9CLEdBQVcscUJBQXFCLENBQUM7QUFDOUQsUUFBVSx3QkFBbUIsR0FBMkIsYUFBYSxDQUFDO0FBQ3RFLFFBQVUsZUFBVSxHQUFxQixDQUFDLEdBQUcsRUFBRSxHQUFH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QUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM3RCxRQUFJLElBQUksQ0FBQyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDOUMsWUFBTSxPQUFPLElBQUksQ0FBQztBQUNsQixTQUFLO0FBQ0wsUUFBVSxJQUFBLHlCQUE4QyxFQUE3QyxpQkFBUyxFQUFFLGtCQUFVLEVBQUUsaUJBQXNCLENBQUM7QUFDekQsUUFBSSxJQUFJLElBQUksQ0FBQyxtQkFBbUIsS0FBSyxhQUFhLEVBQUU7QUFDcEQsWUFBTSwyQ0FBMkM7QUFDakQsWUFBTSxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3ZFLFNBQUs7QUFBQyxhQUFLLElBQUksSUFBSSxDQUFDLG1CQUFtQixLQUFLLGFBQWEsRUFBRTtBQUMzRCxZQUFNLDJDQUEyQztBQUNqRCxZQUFNLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDdkUsU0FBSztBQUFDLGFBQUs7QUFDWCxZQUFNLDJDQUEyQztBQUNqRCxZQUFNLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDdkUsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNGO0FBQ3dELGdCQXRKYixtQkFBbUI7QUFBRztJQVpyRCxhQUFhLHdCQUR6QixVQUFVLEVBQUUsUUFDQSxhQUFhLENBaUt6Qjs7Ozs2RUFDRDtBQUFDLElBREQsb0JBQUM7QUFDQSxDQURBLEFBaktELElBaUtDO0FBQ0QsU0FsS2EsYUFBYTtBQUN6QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBCSUdfRU5ESUFOLFxuICBERUZBVUxUX0xPQ0FMRV9GT1JNQVQsXG4gIERFTElNSVRFUl9SRUdFWCxcbiAgSW5wdXREYXRlRGlzcGxheUZvcm1hdCxcbiAgTElUVExFX0VORElBTixcbiAgTElUVExFX0VORElBTl9SRUdFWCxcbiAgTUlERExFX0VORElBTixcbiAgTUlERExFX0VORElBTl9SRUdFWCxcbiAgUlRMX1JFR0VYLFxuICBVU0VSX0lOUFVUX1JFR0VYLFxufSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCwgcGFyc2VUb0ZvdXJEaWdpdFllYXIgfSBmcm9tICcuLi91dGlscy9kYXRlLXV0aWxzJztcblxuaW1wb3J0IHsgTG9jYWxlSGVscGVyU2VydmljZSB9IGZyb20gJy4vbG9jYWxlLWhlbHBlci5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZGF0ZS1yYW5nZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuLi9tb2RlbC9kYXkubW9kZWwnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZUlPU2VydmljZSB7XG4gIHB1YmxpYyBkaXNhYmxlZERhdGVzOiBEYXRlUmFuZ2UgPSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCByYW5nZS4gSXQgYXBwcm94aW1hdGVzIHRoZSBiZWdpbm5pbmcgb2YgdGltZSB0byB0aGUgZW5kIG9mIHRpbWUuXG4gICAgLy8gVW5sZXNzIGEgbWluRGF0ZSBvciBtYXhEYXRlIGlzIHNldCB3aXRoIHRoZSBuYXRpdmUgSFRNTDUgYXBpIHRoZSByYW5nZSBpcyBhbGwgZGF0ZXNcbiAgICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhbiBBcnJheSBvZiBtaW4vbWF4IHJhbmdlcyB0aGF0IGFsbG93IGNvbmZpZ3VyYXRpb24gb2YgbXVsdGlwbGUgcmFuZ2VzLlxuICAgIG1pbkRhdGU6IG5ldyBEYXlNb2RlbCgwLCAwLCAxKSxcbiAgICBtYXhEYXRlOiBuZXcgRGF5TW9kZWwoOTk5OSwgMTEsIDMxKSxcbiAgfTtcbiAgcHVibGljIGNsZHJMb2NhbGVEYXRlRm9ybWF0OiBzdHJpbmcgPSBERUZBVUxUX0xPQ0FMRV9GT1JNQVQ7XG4gIHByaXZhdGUgbG9jYWxlRGlzcGxheUZvcm1hdDogSW5wdXREYXRlRGlzcGxheUZvcm1hdCA9IExJVFRMRV9FTkRJQU47XG4gIHByaXZhdGUgZGVsaW1pdGVyczogW3N0cmluZywgc3RyaW5nXSA9IFsnLycsICcvJ107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbG9jYWxlSGVscGVyU2VydmljZTogTG9jYWxlSGVscGVyU2VydmljZSkge1xuICAgIHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQgPSB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZURhdGVGb3JtYXQ7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlRGlzcGxheUZvcm1hdCgpO1xuICB9XG5cbiAgcHVibGljIHNldE1pbkRhdGUoZGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gTk9URTogSSdtIGV4cGVjdGluZyBjb25zdW1lcnMgdG8gcGFzcyBvbmUgb2YgZm91ciB0aGluZ3MgaGVyZTpcbiAgICAvLyAgICAgICBBIHByb3BlciBkYXRlIHN0cmluZygyMDE5LTExLTExKSwgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5IHN0cmluZyAoJycpXG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAvLyBhdHRyaWJ1dGUgYmluZGluZyB3YXMgcmVtb3ZlZCwgcmVzZXQgYmFjayB0byB0aGUgYmVnaW5uaW5nIG9mIHRpbWVcbiAgICAgIHRoaXMuZGlzYWJsZWREYXRlcy5taW5EYXRlID0gbmV3IERheU1vZGVsKDAsIDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSBkYXRlLnNwbGl0KCctJykubWFwKG4gPT4gcGFyc2VJbnQobiwgMTApKTtcbiAgICAgIHRoaXMuZGlzYWJsZWREYXRlcy5taW5EYXRlID0gbmV3IERheU1vZGVsKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0TWF4RGF0ZShkYXRlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBOT1RFOiBJJ20gZXhwZWN0aW5nIGNvbnN1bWVycyB0byBwYXNzIG9uZSBvZiBmb3VyIHRoaW5ncyBoZXJlOlxuICAgIC8vICAgICAgIEEgcHJvcGVyIGRhdGUgc3RyaW5nKDIwMTktMTEtMTEpLCBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkgc3RyaW5nICgnJylcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nIHdhcyByZW1vdmVkLCByZXNldCBmb3J3YXJkIHRvIHRoZSBlbmQgb2YgdGltZVxuICAgICAgdGhpcy5kaXNhYmxlZERhdGVzLm1heERhdGUgPSBuZXcgRGF5TW9kZWwoOTk5OSwgMTEsIDMxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF0ZS5zcGxpdCgnLScpLm1hcChuID0+IHBhcnNlSW50KG4sIDEwKSk7XG4gICAgICB0aGlzLmRpc2FibGVkRGF0ZXMubWF4RGF0ZSA9IG5ldyBEYXlNb2RlbCh5ZWFyLCBtb250aCAtIDEsIGRheSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGlzcGxheUZvcm1hdCgpOiB2b2lkIHtcbiAgICBjb25zdCBmb3JtYXQ6IHN0cmluZyA9IHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoTElUVExFX0VORElBTl9SRUdFWC50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9IExJVFRMRV9FTkRJQU47XG4gICAgfSBlbHNlIGlmIChNSURETEVfRU5ESUFOX1JFR0VYLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID0gTUlERExFX0VORElBTjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXZlcnl0aGluZyBlbHNlIGlzIHNldCB0byBCSUctRU5ESUFOIEZPUk1BVFxuICAgICAgdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID0gQklHX0VORElBTjtcbiAgICB9XG4gICAgdGhpcy5leHRyYWN0RGVsaW1pdGVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RGVsaW1pdGVycygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGRyTG9jYWxlRGF0ZUZvcm1hdCkge1xuICAgICAgLy8gU2FuaXRpemUgRGF0ZSBGb3JtYXQuIFJlbW92ZSBSVEwgY2hhcmFjdGVycy5cbiAgICAgIC8vIEZJWE1FOiBXaGVuIHdlIHN1cHBvcnQgUlRMLCByZW1vdmUgdGhpcyBhbmQgaGFuZGxlIGl0IGNvcnJlY3RseS5cbiAgICAgIGNvbnN0IGxvY2FsZUZvcm1hdDogc3RyaW5nID0gdGhpcy5jbGRyTG9jYWxlRGF0ZUZvcm1hdC5yZXBsYWNlKFJUTF9SRUdFWCwgJycpO1xuICAgICAgY29uc3QgZGVsaW1pdGVyczogc3RyaW5nW10gPSBsb2NhbGVGb3JtYXQuc3BsaXQoREVMSU1JVEVSX1JFR0VYKTtcblxuICAgICAgLy8gTk9URTogVGhlIHNwbGl0IGZyb20gdGhlIENMRFIgZGF0ZSBmb3JtYXQgc2hvdWxkIGFsd2F5cyByZXN1bHRcbiAgICAgIC8vIGluIGFuIGFyYXJ5IHdpdGggNCBlbGVtZW50cy4gVGhlIDFzdCBhbmQgdGhlIDJuZCB2YWx1ZXMgYXJlIHRoZSBkZWxpbWl0ZXJzXG4gICAgICAvLyB3ZSB3aWxsIHVzZSBpbiBvcmRlci5cbiAgICAgIC8vIEVnOiBcImRkL01NL3lcIi5zcGxpdCgvZCt8bSt8eSsvaSkgcmVzdWx0cyBpbiBbXCJcIiwgXCIvXCIsIFwiL1wiLCBcIlwiXVxuICAgICAgaWYgKGRlbGltaXRlcnMgJiYgZGVsaW1pdGVycy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gW2RlbGltaXRlcnNbMV0sIGRlbGltaXRlcnNbMl1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBkYXRlIGZvcm1hdCByZWNlaXZlZC4gRGVsaW1pdGVycyBleHRyYWN0ZWQ6ICcsIGRlbGltaXRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyhkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRlTm86IG51bWJlciA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgY29uc3QgbW9udGhObzogbnVtYmVyID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgIGNvbnN0IGRhdGVTdHI6IHN0cmluZyA9IGRhdGVObyA+IDkgPyBkYXRlTm8udG9TdHJpbmcoKSA6ICcwJyArIGRhdGVObztcbiAgICAgIGNvbnN0IG1vbnRoU3RyOiBzdHJpbmcgPSBtb250aE5vID4gOSA/IG1vbnRoTm8udG9TdHJpbmcoKSA6ICcwJyArIG1vbnRoTm87XG4gICAgICBpZiAodGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID09PSBMSVRUTEVfRU5ESUFOKSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgbW9udGhTdHIgKyB0aGlzLmRlbGltaXRlcnNbMV0gKyBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTUlERExFX0VORElBTikge1xuICAgICAgICByZXR1cm4gbW9udGhTdHIgKyB0aGlzLmRlbGltaXRlcnNbMF0gKyBkYXRlU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSArIHRoaXMuZGVsaW1pdGVyc1swXSArIG1vbnRoU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZGF0ZVN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyVGV4dCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZvcm1hdDogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddID0gdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0LmZvcm1hdDtcbiAgICByZXR1cm4gZm9ybWF0WzBdICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgZm9ybWF0WzFdICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZm9ybWF0WzJdO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbW9udGggZW50ZXJlZCBieSB0aGUgdXNlciBpcyB2YWxpZCBvciBub3QuXG4gICAqIE5vdGU6IE1vbnRoIGlzIDAgYmFzZWQuXG4gICAqL1xuICBwcml2YXRlIGlzVmFsaWRNb250aChtb250aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGRhdGUgaXMgdmFsaWQgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyIGFuZCBtb250aCBwcm92aWRlZC5cbiAgICovXG4gIHByaXZhdGUgaXNWYWxpZERhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZGF0ZSA+IDAgJiYgZGF0ZSA8PSBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoKHllYXIsIG1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWQgYW5kIHJldHVybnMgdGhlIGRhdGUuXG4gICAqIElmIHRoZSBwYXJhbWV0ZXJzIGFyZSBub3RcbiAgICogdmFsaWQgdGhlbiByZXR1cm4gbnVsbC5cbiAgICogTk9URTogKE1vbnRoIGhlcmUgaXMgMSBiYXNlZCBzaW5jZSB0aGUgdXNlciBoYXMgcHJvdmlkZWQgdGhhdCBhcyBhbiBpbnB1dClcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVBbmRHZXREYXRlKHllYXI6IHN0cmluZywgbW9udGg6IHN0cmluZywgZGF0ZTogc3RyaW5nKTogRGF0ZSB7XG4gICAgLy8gSSBkb24ndCBrbm93IHdoYXRzIHdyb25nIHdpdGggdGhlIFRTIGNvbXBpbGVyLiBJdCB0aHJvd3MgYW4gZXJyb3IgaWYgSSB3cml0ZVxuICAgIC8vIHRoZSBiZWxvdyBpZiBzdGF0ZW1lbnQuIFRoZSBlcnJvciBpczpcbiAgICAvLyBPcGVyYXRvciAnIT09JyBjYW5ub3QgYmUgYXBwbGllZCB0byB0eXBlcyAnMicgYW5kICc0J1xuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEyNzk0I2lzc3VlY29tbWVudC0yNzAzNDI5MzZcbiAgICAvKlxuICAgICAgICBpZiAoeWVhci5sZW5ndGggIT09IDIgfHwgeWVhci5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAvLyBJbnN0ZWFkIEkgaGF2ZSB0byB3cml0ZSB0aGUgbG9naWMgbGlrZSB0aGlzIHgtKFxuICAgIGNvbnN0IHk6IG51bWJlciA9ICt5ZWFyO1xuICAgIGNvbnN0IG06IG51bWJlciA9ICttb250aCAtIDE7IC8vIG1vbnRoIGlzIDAgYmFzZWRcbiAgICBjb25zdCBkOiBudW1iZXIgPSArZGF0ZTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZE1vbnRoKG0pIHx8ICF0aGlzLmlzVmFsaWREYXRlKHksIG0sIGQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXIgPSBwYXJzZVRvRm91ckRpZ2l0WWVhcih5KTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSAtMSA/IG5ldyBEYXRlKHJlc3VsdCwgbSwgZCkgOiBudWxsO1xuICB9XG5cbiAgZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcoZGF0ZTogc3RyaW5nKTogRGF0ZSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVBhcnRzOiBzdHJpbmdbXSA9IGRhdGUubWF0Y2goVVNFUl9JTlBVVF9SRUdFWCk7XG4gICAgaWYgKCFkYXRlUGFydHMgfHwgZGF0ZVBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdFBhcnQsIHNlY29uZFBhcnQsIHRoaXJkUGFydF0gPSBkYXRlUGFydHM7XG4gICAgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTElUVExFX0VORElBTikge1xuICAgICAgLy8gc2Vjb25kUGFydCBpcyBtb250aCAmJiBmaXJzdFBhcnQgaXMgZGF0ZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbmRHZXREYXRlKHRoaXJkUGFydCwgc2Vjb25kUGFydCwgZmlyc3RQYXJ0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTUlERExFX0VORElBTikge1xuICAgICAgLy8gZmlyc3RQYXJ0IGlzIG1vbnRoICYmIHNlY29uZFBhcnQgaXMgZGF0ZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbmRHZXREYXRlKHRoaXJkUGFydCwgZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2Vjb25kUGFydCBpcyBtb250aCAmJiB0aGlyZFBhcnQgaXMgZGF0ZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbmRHZXREYXRlKGZpcnN0UGFydCwgc2Vjb25kUGFydCwgdGhpcmRQYXJ0KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==